<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrefixTreeMtasCounter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.codec.util.heatmap</a> &gt; <span class="el_source">PrefixTreeMtasCounter.java</span></div><h1>PrefixTreeMtasCounter.java</h1><pre class="source lang-java linenums">package mtas.codec.util.heatmap;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import mtas.codec.util.CodecComponent.ComponentHeatmap;
import mtas.codec.util.CodecComponent.SubComponentFunction;
import mtas.codec.util.CodecUtil;

import org.apache.lucene.index.LeafReaderContext;

import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.search.DocIdSet;
import org.apache.lucene.search.DocIdSetIterator;
import org.apache.lucene.spatial.prefix.AbstractVisitingPrefixTreeQuery;
import org.apache.lucene.spatial.prefix.PrefixTreeStrategy;
import org.apache.lucene.spatial.prefix.tree.Cell;
import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
import org.apache.lucene.util.Bits;

/**
 * Based on PrefixTreeFacetCounter. 
 */

public class PrefixTreeMtasCounter {

  /** A callback/visitor of gridlevel counts. */
<span class="fc" id="L30">  public abstract static class GridVisitor {</span>
    /** Called for cells with a leaf, or cells at the target gridlevel.  {@code count} is greater than zero.
     * When an ancestor cell is given with non-zero count, the count can be considered to be added to all cells
     * below. You won't necessarily get a cell at level {@code gridLevel} if the indexed data is courser (bigger).
     */
    public abstract void visit(Cell cell, CellValues cellValues);
        
  }
  


<span class="nc" id="L41">  private PrefixTreeMtasCounter() {</span>
<span class="nc" id="L42">  }</span>
  
  
  /** Lower-level per-leaf segment method. */
  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, 
                             final int number, final int[] docSet, final long[] values,
                             final long[][] args, final int[] positions,
                             ComponentHeatmap heatmap, final GridVisitor gridVisitor)
      throws IOException {
<span class="fc" id="L51">    final SpatialPrefixTree tree = strategy.getGrid();</span>
    
    Bits acceptDocs;
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">    if (number==0) {</span>
<span class="nc" id="L55">      acceptDocs = new Bits.MatchNoBits(context.reader().maxDoc());</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">    } else if (number == context.reader().maxDoc()) {</span>
<span class="fc" id="L57">      acceptDocs = new Bits.MatchAllBits(context.reader().maxDoc());</span>
    } else {
<span class="nc" id="L59">      acceptDocs = new Bits() {</span>
<span class="nc" id="L60">        int p = docSet[0];</span>
<span class="nc" id="L61">        int i = 0;</span>
      
        @Override
        public boolean get(int index) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">          if(index&lt;p) {</span>
<span class="nc" id="L66">            p=docSet[0];</span>
<span class="nc" id="L67">            i=0;</span>
          }
<span class="nc bnc" id="L69" title="All 2 branches missed.">          while(index&gt;p) {</span>
<span class="nc" id="L70">            i++; </span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">            if(i&lt;number) {</span>
<span class="nc" id="L72">              p=docSet[i];</span>
            } else {
<span class="nc" id="L74">              return false;</span>
            }
          } 
<span class="nc bnc" id="L77" title="All 2 branches missed.">          return index==p;</span>
        }
  
        @Override
        public int length() {
<span class="nc" id="L82">          return context.reader().maxDoc();</span>
        }
      };
    }  

    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely
    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).
    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.
<span class="fc" id="L90">    final int scanLevel = tree.getMaxLevels();</span>
    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree
    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">    new AbstractVisitingPrefixTreeQuery(heatmap.boundsShape, strategy.getFieldName(), tree, heatmap.gridLevel, scanLevel) {</span>

      @Override
      public String toString(String field) {
<span class="nc" id="L97">        return &quot;anonPrefixTreeQuery&quot;;//un-used</span>
      }

      @Override
      public DocIdSet getDocIdSet(LeafReaderContext contexts) throws IOException {
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">        assert heatmap.gridLevel == super.detailLevel;//same thing, FYI. (constant)</span>

<span class="fc" id="L104">        return new VisitorTemplate(context) {</span>

          @Override
          protected void start() throws IOException {
<span class="fc" id="L108">          }</span>

          @Override
          protected DocIdSet finish() throws IOException {
<span class="fc" id="L112">            return null;//unused;</span>
          }

          @Override
          protected boolean visitPrefix(Cell cell) throws IOException {
            // At gridLevel...
<span class="fc bfc" id="L118" title="All 2 branches covered.">            if (cell.getLevel() == heatmap.gridLevel) {</span>
              // Count docs
<span class="fc" id="L120">              visitLeaf(cell);//we're not a leaf but we treat it as such at grid level</span>
<span class="fc" id="L121">              return false;//don't descend further; this is enough detail</span>
            }

            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no
            // matching docs. We could do this at all levels or never but the closer we get to the grid level, the
            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially
            // due to &quot;pulsing&quot; in the codec.
            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)
<span class="fc bfc" id="L129" title="All 4 branches covered.">            if (cell.getLevel() == heatmap.gridLevel - 1 || termsEnum.docFreq() == 1) {</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">              if (!hasDocsAtThisTerm()) {</span>
<span class="nc" id="L131">                return false;</span>
              }
            }
<span class="fc" id="L134">            return true;</span>
          }

          @Override
          protected void visitLeaf(Cell cell) throws IOException {
<span class="fc" id="L139">            final CellValues cellValues = computeValuesAtThisTerm();</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            if (cellValues.valuesLength() &gt; 0) {</span>
<span class="fc" id="L141">              gridVisitor.visit(cell, cellValues);</span>
            }
<span class="fc" id="L143">          }</span>

          private CellValues computeValuesAtThisTerm() throws IOException {
<span class="fc" id="L146">            long[] termValues = new long[number];</span>
<span class="fc" id="L147">            Map&lt;String,Integer&gt;[] functionValuesError = new Map[heatmap.hm.functions.size()];</span>
<span class="fc" id="L148">            long[][] functionValuesLong = new long[heatmap.hm.functions.size()][];</span>
<span class="fc" id="L149">            double[][] functionValuesDouble = new double[heatmap.hm.functions.size()][];</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            for(int i=0; i&lt;heatmap.hm.functions.size(); i++) {</span>
<span class="fc" id="L151">              SubComponentFunction f = heatmap.hm.functions.get(i);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">              if(f.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="fc" id="L153">                functionValuesLong[i] = new long[number];</span>
<span class="fc" id="L154">                functionValuesDouble[i] = null;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">              } else if(f.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L156">                functionValuesLong[i] = null;</span>
<span class="nc" id="L157">                functionValuesDouble[i] = new double[number];</span>
              }  
<span class="fc" id="L159">              functionValuesError[i] = new HashMap&lt;&gt;();</span>
            }
<span class="fc" id="L161">            int valuesCounter=0;</span>
<span class="fc" id="L162">            int[] functionValuesCounter = new int[heatmap.hm.functions.size()];</span>
<span class="fc" id="L163">            int docSetCounter=0;</span>
            long functionValueLong;
            double functionValueDouble;
            String functionValueError;
<span class="fc" id="L167">            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);</span>
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS &amp;&amp; docSetCounter&lt;number) {</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">              while(postingsEnum.docID()&lt;docSet[docSetCounter]) {</span>
<span class="nc" id="L170">                postingsEnum.nextDoc();</span>
              }
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">              while(docSetCounter&lt;number &amp;&amp; docSet[docSetCounter]&lt;postingsEnum.docID()) {</span>
<span class="fc" id="L173">                docSetCounter++;</span>
              }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">              if(docSetCounter&gt;=number) {</span>
<span class="nc" id="L176">                break;</span>
              } else {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                if(postingsEnum.docID()==docSet[docSetCounter]) {</span>
<span class="fc" id="L179">                  termValues[valuesCounter] = values[docSetCounter];</span>
<span class="fc" id="L180">                  valuesCounter++;</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                  for(int i=0; i&lt;heatmap.hm.functions.size(); i++) {</span>
<span class="fc" id="L182">                    SubComponentFunction f = heatmap.hm.functions.get(i);</span>
                    try{
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">                      if(f.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
                      
<span class="fc" id="L186">                        functionValueLong = f.parserFunction.getValueLong(args[docSetCounter], positions[docSetCounter]); </span>
<span class="fc" id="L187">                        functionValuesLong[i][functionValuesCounter[i]] = functionValueLong;</span>
<span class="fc" id="L188">                        functionValuesCounter[i]++;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                      } else if(f.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {                      </span>
<span class="nc" id="L190">                        functionValueDouble = f.parserFunction.getValueDouble(args[docSetCounter], positions[docSetCounter]); </span>
<span class="nc" id="L191">                        functionValuesDouble[i][functionValuesCounter[i]] = functionValueDouble;</span>
<span class="nc" id="L192">                        functionValuesCounter[i]++;</span>
                      }
<span class="nc" id="L194">                    } catch(IOException e) {</span>
<span class="nc" id="L195">                      functionValueError = e.getMessage();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                      if(functionValuesError[i].containsKey(functionValueError)) {</span>
<span class="nc" id="L197">                        functionValuesError[i].put(functionValueError, functionValuesError[i].get(functionValueError)+1);</span>
                      } else {
<span class="nc" id="L199">                        functionValuesError[i].put(functionValueError, 1);</span>
                      }
<span class="fc" id="L201">                    }</span>
                  }                  
                }
              }  
            }
            //cut length of arrays
<span class="fc" id="L207">            termValues = Arrays.copyOf(termValues, valuesCounter);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            for(int i=0; i&lt;heatmap.hm.functions.size(); i++) {</span>
<span class="fc" id="L209">              SubComponentFunction f = heatmap.hm.functions.get(i);</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">              if(f.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="fc" id="L211">                functionValuesLong[i] = Arrays.copyOf(functionValuesLong[i], functionValuesCounter[i]);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">              } else if(f.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L213">                functionValuesDouble[i] = Arrays.copyOf(functionValuesDouble[i], functionValuesCounter[i]);</span>
              }
            }            
<span class="fc" id="L216">            return new CellValues(termValues, functionValuesLong, functionValuesDouble, functionValuesError);</span>
          }

          private boolean hasDocsAtThisTerm() throws IOException {
<span class="fc" id="L220">            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);</span>
<span class="fc" id="L221">            int nextDoc = postingsEnum.nextDoc();</span>
<span class="pc bpc" id="L222" title="2 of 4 branches missed.">            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS &amp;&amp; acceptDocs.get(nextDoc) == false) {</span>
<span class="nc" id="L223">              nextDoc = postingsEnum.nextDoc();</span>
            }
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;</span>
          }

<span class="fc" id="L228">        }.getDocIdSet();</span>
      }
<span class="fc" id="L230">    }.getDocIdSet(context);</span>
<span class="fc" id="L231">  }</span>
  
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>