<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CodecInfo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.codec.util</a> &gt; <span class="el_source">CodecInfo.java</span></div><h1>CodecInfo.java</h1><pre class="source lang-java linenums">package mtas.codec.util;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import mtas.analysis.token.MtasToken;
import mtas.analysis.token.MtasTokenString;
import mtas.codec.MtasCodecPostingsFormat;
import mtas.codec.tree.IntervalRBTree;
import mtas.codec.tree.IntervalTreeNodeData;
import mtas.codec.util.CodecSearchTree.MtasTreeHit;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.lucene.index.Terms;
import org.apache.lucene.store.IndexInput;

/**
 * The Class CodecInfo.
 */
public class CodecInfo {

  /** The log. */
<span class="fc" id="L32">  private static Log log = LogFactory.getLog(CodecInfo.class);</span>

  /** The index input list. */
  HashMap&lt;String, IndexInput&gt; indexInputList;

  /** The index input offset list. */
  HashMap&lt;String, Long&gt; indexInputOffsetList;

  /** The version. */
  int version;

  /** The field references. */
  private HashMap&lt;String, FieldReferences&gt; fieldReferences;

  /** The prefix references. */
  private HashMap&lt;String, LinkedHashMap&lt;String, Long&gt;&gt; prefixReferences;

  /**
   * Instantiates a new codec info.
   *
   * @param indexInputList
   *          the index input list
   * @param indexInputOffsetList
   *          the index input offset list
   * @param version
   *          the version
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public CodecInfo(HashMap&lt;String, IndexInput&gt; indexInputList,
      HashMap&lt;String, Long&gt; indexInputOffsetList, int version)
<span class="fc" id="L63">      throws IOException {</span>
<span class="fc" id="L64">    this.indexInputList = indexInputList;</span>
<span class="fc" id="L65">    this.indexInputOffsetList = indexInputOffsetList;</span>
<span class="fc" id="L66">    this.version = version;</span>
<span class="fc" id="L67">    init();</span>
<span class="fc" id="L68">  }</span>

  /**
   * Gets the codec info from terms.
   *
   * @param t
   *          the t
   * @return the codec info from terms
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static CodecInfo getCodecInfoFromTerms(Terms t) throws IOException {
    try {
<span class="fc" id="L82">      HashMap&lt;String, IndexInput&gt; indexInputList = null;</span>
<span class="fc" id="L83">      HashMap&lt;String, Long&gt; indexInputOffsetList = null;</span>
<span class="fc" id="L84">      Object version = null;</span>
<span class="fc" id="L85">      Method[] methods = t.getClass().getMethods();</span>
<span class="fc" id="L86">      Object[] emptyArgs = null;</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">      for (Method m : methods) {</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (m.getName().equals(&quot;getIndexInputList&quot;)) {</span>
<span class="fc" id="L89">          indexInputList = (HashMap&lt;String, IndexInput&gt;) m.invoke(t, emptyArgs);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        } else if (m.getName().equals(&quot;getIndexInputOffsetList&quot;)) {</span>
<span class="fc" id="L91">          indexInputOffsetList = (HashMap&lt;String, Long&gt;) m.invoke(t, emptyArgs);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        } else if (m.getName().equals(&quot;getVersion&quot;)) {</span>
<span class="fc" id="L93">          version = m.invoke(t, emptyArgs);</span>
        }
      }
<span class="pc bpc" id="L96" title="3 of 6 branches missed.">      if (indexInputList == null || indexInputOffsetList == null</span>
          || version == null) {
<span class="nc" id="L98">        throw new IOException(&quot;Reader doesn't provide MtasFieldsProducer&quot;);</span>
      } else {
<span class="fc" id="L100">        return new CodecInfo(indexInputList, indexInputOffsetList,</span>
<span class="fc" id="L101">            (int) version);</span>
      }
<span class="nc" id="L103">    } catch (IllegalAccessException | InvocationTargetException e) {</span>
<span class="nc" id="L104">      throw new IOException(&quot;Can't get codecInfo&quot;, e);</span>
    }
  }

  /**
   * Inits the.
   *
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private void init() throws IOException {
    // move to begin
<span class="fc" id="L116">    IndexInput inField = indexInputList.get(&quot;field&quot;);</span>
<span class="fc" id="L117">    inField.seek(indexInputOffsetList.get(&quot;field&quot;));</span>
    // store field references in memory
<span class="fc" id="L119">    fieldReferences = new HashMap&lt;String, FieldReferences&gt;();</span>
<span class="fc" id="L120">    boolean doInit = true;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">    while (doInit) {</span>
      try {
<span class="fc" id="L123">        String field = inField.readString();</span>
<span class="fc" id="L124">        long refIndexDoc = inField.readVLong();</span>
<span class="fc" id="L125">        long refIndexDocId = inField.readVLong();</span>
<span class="fc" id="L126">        int numberOfDocs = inField.readVInt();</span>
<span class="fc" id="L127">        inField.readVLong(); // refTerm</span>
<span class="fc" id="L128">        inField.readVInt(); // numberOfTerms</span>
<span class="fc" id="L129">        long refPrefix = inField.readVLong();</span>
<span class="fc" id="L130">        int numberOfPrefixes = inField.readVInt();</span>
<span class="fc" id="L131">        fieldReferences.put(field, new FieldReferences(refIndexDoc,</span>
            refIndexDocId, numberOfDocs, refPrefix, numberOfPrefixes));
<span class="fc" id="L133">      } catch (IOException e) {</span>
<span class="fc" id="L134">        log.debug(e);</span>
<span class="fc" id="L135">        doInit = false;</span>
<span class="fc" id="L136">      }</span>
    }
    // prefixReferences
<span class="fc" id="L139">    prefixReferences = new HashMap&lt;String, LinkedHashMap&lt;String, Long&gt;&gt;();</span>
<span class="fc" id="L140">  }</span>

  /**
   * Gets the object by id.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @param mtasId
   *          the mtas id
   * @return the object by id
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public MtasToken getObjectById(String field, int docId, int mtasId)
      throws IOException {
    try {
      Long ref;
      Long objectRefApproxCorrection;
<span class="nc" id="L160">      IndexDoc doc = getDoc(field, docId);</span>
<span class="nc" id="L161">      IndexInput inObjectId = indexInputList.get(&quot;indexObjectId&quot;);</span>
<span class="nc" id="L162">      IndexInput inObject = indexInputList.get(&quot;object&quot;);</span>
<span class="nc" id="L163">      IndexInput inTerm = indexInputList.get(&quot;term&quot;);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      if (doc.storageFlags == MtasCodecPostingsFormat.MTAS_STORAGE_BYTE) {</span>
<span class="nc" id="L165">        inObjectId.seek(doc.fpIndexObjectId + (mtasId * 1L));</span>
<span class="nc" id="L166">        objectRefApproxCorrection = Long.valueOf(inObjectId.readByte());</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">      } else if (doc.storageFlags == MtasCodecPostingsFormat.MTAS_STORAGE_SHORT) {</span>
<span class="nc" id="L168">        inObjectId.seek(doc.fpIndexObjectId + (mtasId * 2L));</span>
<span class="nc" id="L169">        objectRefApproxCorrection = Long.valueOf(inObjectId.readShort());</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">      } else if (doc.storageFlags == MtasCodecPostingsFormat.MTAS_STORAGE_INTEGER) {</span>
<span class="nc" id="L171">        inObjectId.seek(doc.fpIndexObjectId + (mtasId * 4L));</span>
<span class="nc" id="L172">        objectRefApproxCorrection = Long.valueOf(inObjectId.readInt());</span>
      } else {
<span class="nc" id="L174">        inObjectId.seek(doc.fpIndexObjectId + (mtasId * 8L));</span>
<span class="nc" id="L175">        objectRefApproxCorrection = Long.valueOf(inObjectId.readLong());</span>
      }
<span class="nc" id="L177">      ref = objectRefApproxCorrection + doc.objectRefApproxOffset</span>
          + (mtasId * (long) doc.objectRefApproxQuotient);
<span class="nc" id="L179">      return MtasCodecPostingsFormat.getToken(inObject, inTerm, ref);</span>
<span class="nc" id="L180">    } catch (Exception e) {</span>
<span class="nc" id="L181">      throw new IOException(e);</span>
    }
  }

  /**
   * Gets the objects by parent id.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @param position
   *          the position
   * @return the objects by parent id
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public List&lt;MtasTokenString&gt; getObjectsByParentId(String field, int docId,
      int position) throws IOException {
<span class="nc" id="L200">    IndexDoc doc = getDoc(field, docId);</span>
<span class="nc" id="L201">    IndexInput inIndexObjectParent = indexInputList.get(&quot;indexObjectParent&quot;);</span>
<span class="nc" id="L202">    ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; hits = CodecSearchTree.searchMtasTree(position,</span>
        inIndexObjectParent, doc.fpIndexObjectParent,
        doc.smallestObjectFilepointer);
<span class="nc" id="L205">    return getObjects(hits);</span>
  }

  /**
   * Gets the objects by position.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @param position
   *          the position
   * @return the objects by position
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public ArrayList&lt;MtasTokenString&gt; getObjectsByPosition(String field,
      int docId, int position) throws IOException {
<span class="nc" id="L223">    IndexDoc doc = getDoc(field, docId);</span>
<span class="nc" id="L224">    IndexInput inIndexObjectPosition = indexInputList</span>
<span class="nc" id="L225">        .get(&quot;indexObjectPosition&quot;);</span>
<span class="nc" id="L226">    ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; hits = CodecSearchTree.searchMtasTree(position,</span>
        inIndexObjectPosition, doc.fpIndexObjectPosition,
        doc.smallestObjectFilepointer);
<span class="nc" id="L229">    return getObjects(hits);</span>
  }

  /**
   * Gets the objects by positions.
   *
   * @param field the field
   * @param docId the doc id
   * @param startPosition the start position
   * @param endPosition the end position
   * @return the objects by positions
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public ArrayList&lt;MtasTokenString&gt; getObjectsByPositions(String field,
      int docId, int startPosition, int endPosition) throws IOException {
<span class="nc" id="L244">    IndexDoc doc = getDoc(field, docId);</span>
<span class="nc" id="L245">    IndexInput inIndexObjectPosition = indexInputList</span>
<span class="nc" id="L246">        .get(&quot;indexObjectPosition&quot;);</span>
<span class="nc" id="L247">    ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; hits = CodecSearchTree.searchMtasTree(</span>
        startPosition, endPosition, inIndexObjectPosition,
        doc.fpIndexObjectPosition, doc.smallestObjectFilepointer);
<span class="nc" id="L250">    return getObjects(hits);</span>
  }

  /**
   * Gets the prefix filtered objects by positions.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @param prefixes
   *          the prefixes
   * @param startPosition
   *          the start position
   * @param endPosition
   *          the end position
   * @return the prefix filtered objects by positions
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public List&lt;MtasTokenString&gt; getPrefixFilteredObjectsByPositions(String field,
      int docId, List&lt;String&gt; prefixes, int startPosition, int endPosition)
      throws IOException {
<span class="nc" id="L273">    IndexDoc doc = getDoc(field, docId);</span>
<span class="nc" id="L274">    IndexInput inIndexObjectPosition = indexInputList</span>
<span class="nc" id="L275">        .get(&quot;indexObjectPosition&quot;);</span>
<span class="nc bnc" id="L276" title="All 4 branches missed.">    if (doc != null &amp;&amp; startPosition&lt;=endPosition) {</span>
<span class="nc" id="L277">      ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; hits = CodecSearchTree.searchMtasTree(</span>
          startPosition, endPosition, inIndexObjectPosition,
          doc.fpIndexObjectPosition, doc.smallestObjectFilepointer);
<span class="nc" id="L280">      return getPrefixFilteredObjects(hits, prefixes);</span>
    } else {
<span class="nc" id="L282">      return new ArrayList&lt;&gt;();</span>
    }
  }

  /**
   * Gets the prefix filtered objects.
   *
   * @param hits
   *          the hits
   * @param prefixes
   *          the prefixes
   * @return the prefix filtered objects
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private List&lt;MtasTokenString&gt; getPrefixFilteredObjects(
      List&lt;MtasTreeHit&lt;?&gt;&gt; hits, List&lt;String&gt; prefixes) throws IOException {
<span class="nc" id="L299">    ArrayList&lt;MtasTokenString&gt; tokens = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L300">    IndexInput inObject = indexInputList.get(&quot;object&quot;);</span>
<span class="nc" id="L301">    IndexInput inTerm = indexInputList.get(&quot;term&quot;);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">    for (MtasTreeHit&lt;?&gt; hit : hits) {</span>
<span class="nc" id="L303">      MtasTokenString token = MtasCodecPostingsFormat.getToken(inObject, inTerm,</span>
<span class="nc" id="L304">          hit.ref);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">      if (token != null) {</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">        if (prefixes != null &amp;&amp; !prefixes.isEmpty()) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">          if (prefixes.contains(token.getPrefix())) {</span>
<span class="nc" id="L308">            tokens.add(token);</span>
          }
        } else {
<span class="nc" id="L311">          tokens.add(token);</span>
        }
      }
<span class="nc" id="L314">    }</span>
<span class="nc" id="L315">    return tokens;</span>
  }

  /**
   * Gets the positioned terms by prefixes and position.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @param prefixes
   *          the prefixes
   * @param position
   *          the position
   * @return the positioned terms by prefixes and position
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public List&lt;MtasTreeHit&lt;String&gt;&gt; getPositionedTermsByPrefixesAndPosition(
      String field, int docId, List&lt;String&gt; prefixes, int position)
      throws IOException {
<span class="nc" id="L336">    return getPositionedTermsByPrefixesAndPositionRange(field, docId, prefixes,</span>
        position, position);
  }

  /**
   * Gets the positioned terms by prefixes and position range.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @param prefixes
   *          the prefixes
   * @param startPosition
   *          the start position
   * @param endPosition
   *          the end position
   * @return the positioned terms by prefixes and position range
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public List&lt;MtasTreeHit&lt;String&gt;&gt; getPositionedTermsByPrefixesAndPositionRange(
      String field, int docId, List&lt;String&gt; prefixes, int startPosition,
      int endPosition) throws IOException {
<span class="nc" id="L360">    IndexDoc doc = getDoc(field, docId);</span>
<span class="nc" id="L361">    IndexInput inIndexObjectPosition = indexInputList</span>
<span class="nc" id="L362">        .get(&quot;indexObjectPosition&quot;);</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">    if (doc != null &amp;&amp; startPosition&lt;=endPosition) {</span>
<span class="nc" id="L364">      ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; hitItems = CodecSearchTree.searchMtasTree(</span>
          startPosition, endPosition, inIndexObjectPosition,
          doc.fpIndexObjectPosition, doc.smallestObjectFilepointer);
<span class="nc" id="L367">      List&lt;MtasTreeHit&lt;String&gt;&gt; hits = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L368">      Map&lt;String, Integer&gt; prefixIds = getPrefixesIds(field, prefixes);</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">      if (prefixIds != null &amp;&amp; prefixIds.size() &gt; 0) {</span>
<span class="nc" id="L370">        ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; filteredHitItems = new ArrayList&lt;MtasTreeHit&lt;?&gt;&gt;();</span>

<span class="nc bnc" id="L372" title="All 2 branches missed.">        for (MtasTreeHit&lt;?&gt; hitItem : hitItems) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">          if (prefixIds.containsValue(hitItem.additionalId)) {</span>
<span class="nc" id="L374">            filteredHitItems.add(hitItem);</span>
          }
<span class="nc" id="L376">        }</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (filteredHitItems.size() &gt; 0) {</span>
<span class="nc" id="L378">          ArrayList&lt;MtasTokenString&gt; objects = getObjects(filteredHitItems);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">          for (MtasTokenString token : objects) {</span>
<span class="nc" id="L380">            MtasTreeHit&lt;String&gt; hit = new MtasTreeHit&lt;String&gt;(</span>
<span class="nc" id="L381">                token.getPositionStart(), token.getPositionEnd(),</span>
<span class="nc" id="L382">                token.getTokenRef(), 0, 0, token.getValue());</span>
<span class="nc" id="L383">            hits.add(hit);</span>
<span class="nc" id="L384">          }</span>
        }
      }
<span class="nc" id="L387">      return hits;</span>
    } else {
<span class="nc" id="L389">      return new ArrayList&lt;MtasTreeHit&lt;String&gt;&gt;();</span>
    }
  }

  /**
   * Collect terms by prefixes for list of hit positions.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @param prefixes
   *          the prefixes
   * @param positionsHits
   *          the positions hits
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public void collectTermsByPrefixesForListOfHitPositions(String field,
      int docId, ArrayList&lt;String&gt; prefixes,
      ArrayList&lt;IntervalTreeNodeData&lt;String&gt;&gt; positionsHits)
      throws IOException {
<span class="fc" id="L411">    IndexDoc doc = getDoc(field, docId);</span>
<span class="fc" id="L412">    IndexInput inIndexObjectPosition = indexInputList</span>
<span class="fc" id="L413">        .get(&quot;indexObjectPosition&quot;);</span>
<span class="fc" id="L414">    IndexInput inTerm = indexInputList.get(&quot;term&quot;);</span>
    // create tree interval hits
<span class="fc" id="L416">    IntervalRBTree&lt;String&gt; positionTree = new IntervalRBTree&lt;String&gt;(</span>
        positionsHits);

    // find prefixIds
<span class="fc" id="L420">    Map&lt;String, Integer&gt; prefixIds = getPrefixesIds(field, prefixes);</span>
    // search matching tokens
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">    if (prefixIds != null) {</span>
<span class="fc" id="L423">      CodecSearchTree.searchMtasTreeWithIntervalTree(prefixIds.values(),</span>
          positionTree, inIndexObjectPosition, doc.fpIndexObjectPosition,
          doc.smallestObjectFilepointer);

      // reverse list
<span class="fc" id="L428">      Map&lt;Integer, String&gt; idPrefixes = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">      for (Entry&lt;String, Integer&gt; entry : prefixIds.entrySet()) {</span>
<span class="fc" id="L430">        idPrefixes.put(entry.getValue(), entry.getKey());</span>
<span class="fc" id="L431">      }</span>
      // term administration
<span class="fc" id="L433">      Map&lt;Long, String&gt; refTerms = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L435" title="All 2 branches covered.">      for (IntervalTreeNodeData&lt;String&gt; positionHit : positionsHits) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        for (MtasTreeHit&lt;String&gt; hit : positionHit.list) {</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">          if (hit.idData == null) {</span>
<span class="fc" id="L438">            hit.idData = idPrefixes.get(hit.additionalId);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if (!refTerms.containsKey(hit.additionalRef)) {</span>
<span class="fc" id="L440">              refTerms.put(hit.additionalRef,</span>
<span class="fc" id="L441">                  MtasCodecPostingsFormat.getTerm(inTerm, hit.additionalRef));</span>
            }
<span class="fc" id="L443">            hit.refData = refTerms.get(hit.additionalRef);</span>
          }
<span class="fc" id="L445">        }</span>
<span class="fc" id="L446">      }</span>
    }
<span class="fc" id="L448">  }</span>

  /**
   * Gets the objects.
   *
   * @param hits
   *          the hits
   * @return the objects
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public ArrayList&lt;MtasTokenString&gt; getObjects(List&lt;MtasTreeHit&lt;?&gt;&gt; hits)
      throws IOException {
<span class="nc" id="L461">    ArrayList&lt;MtasTokenString&gt; tokens = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L462">    IndexInput inObject = indexInputList.get(&quot;object&quot;);</span>
<span class="nc" id="L463">    IndexInput inTerm = indexInputList.get(&quot;term&quot;);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">    for (MtasTreeHit&lt;?&gt; hit : hits) {</span>
<span class="nc" id="L465">      MtasTokenString token = MtasCodecPostingsFormat.getToken(inObject, inTerm,</span>
<span class="nc" id="L466">          hit.ref);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">      if (token != null) {</span>
<span class="nc" id="L468">        tokens.add(token);</span>
      }
<span class="nc" id="L470">    }</span>
<span class="nc" id="L471">    return tokens;</span>
  }

  /**
   * Gets the terms.
   *
   * @param refs
   *          the refs
   * @return the terms
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public ArrayList&lt;MtasTreeHit&lt;String&gt;&gt; getTerms(ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; refs)
      throws IOException {
    try {
<span class="nc" id="L486">      ArrayList&lt;MtasTreeHit&lt;String&gt;&gt; terms = new ArrayList&lt;MtasTreeHit&lt;String&gt;&gt;();</span>
<span class="nc" id="L487">      IndexInput inTerm = indexInputList.get(&quot;term&quot;);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">      for (MtasTreeHit&lt;?&gt; hit : refs) {</span>
<span class="nc" id="L489">        inTerm.seek(hit.ref);</span>
<span class="nc" id="L490">        String term = inTerm.readString();</span>
<span class="nc" id="L491">        MtasTreeHit&lt;String&gt; newHit = new MtasTreeHit&lt;String&gt;(hit.startPosition,</span>
            hit.endPosition, hit.ref, hit.additionalId, hit.additionalRef,
            term);
<span class="nc" id="L494">        terms.add(newHit);</span>
<span class="nc" id="L495">      }</span>
<span class="nc" id="L496">      return terms;</span>
<span class="nc" id="L497">    } catch (Exception e) {</span>
<span class="nc" id="L498">      throw new IOException(e);</span>
    }
  }

  /**
   * Gets the prefixes ids.
   *
   * @param field
   *          the field
   * @param prefixes
   *          the prefixes
   * @return the prefixes ids
   */
  Map&lt;String, Integer&gt; getPrefixesIds(String field, List&lt;String&gt; prefixes) {
<span class="fc" id="L512">    LinkedHashMap&lt;String, Long&gt; refs = getPrefixRefs(field);</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">    if (refs != null) {</span>
<span class="fc" id="L514">      List&lt;String&gt; list = new ArrayList&lt;&gt;(refs.keySet());</span>
<span class="fc" id="L515">      Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">      for (String prefix : prefixes) {</span>
<span class="fc" id="L517">        int id = list.indexOf(prefix);</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        if (id &gt;= 0) {</span>
<span class="fc" id="L519">          result.put(prefix, id + 1);</span>
        }
<span class="fc" id="L521">      }</span>
<span class="fc" id="L522">      return result;</span>
    } else {
<span class="nc" id="L524">      return null;</span>
    }
  }

  /**
   * Gets the prefixes.
   *
   * @param field the field
   * @return the prefixes
   */
  public Set&lt;String&gt; getPrefixes(String field) {
<span class="nc" id="L535">    LinkedHashMap&lt;String, Long&gt; prefixRefs = this.getPrefixRefs(field);</span>
<span class="nc" id="L536">    return prefixRefs.keySet();</span>
  }
  
  /**
   * Gets the prefixes.
   *
   * @param field
   *          the field
   * @return the prefixes
   */
  private LinkedHashMap&lt;String, Long&gt; getPrefixRefs(String field) {
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="fc" id="L548">      FieldReferences fr = fieldReferences.get(field);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">      if (!prefixReferences.containsKey(field)) {</span>
<span class="fc" id="L550">        LinkedHashMap&lt;String, Long&gt; refs = new LinkedHashMap&lt;String, Long&gt;();</span>
        try {
<span class="fc" id="L552">          IndexInput inPrefix = indexInputList.get(&quot;prefix&quot;);</span>
<span class="fc" id="L553">          inPrefix.seek(fr.refPrefix);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">          for (int i = 0; i &lt; fr.numberOfPrefixes; i++) {</span>
<span class="fc" id="L555">            Long ref = inPrefix.getFilePointer();</span>
<span class="fc" id="L556">            String prefix = inPrefix.readString();</span>
<span class="fc" id="L557">            refs.put(prefix, ref);</span>
          }
<span class="nc" id="L559">        } catch (Exception e) {</span>
<span class="nc" id="L560">          log.error(e);</span>
<span class="nc" id="L561">          refs.clear();</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">        prefixReferences.put(field, refs);</span>
<span class="fc" id="L564">        return refs;</span>
      } else {
<span class="fc" id="L566">        return prefixReferences.get(field);</span>
      }
    } else {
<span class="nc" id="L569">      return null;</span>
    }
  }

  /**
   * Gets the doc.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @return the doc
   */
  public IndexDoc getDoc(String field, int docId) {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="fc" id="L584">      FieldReferences fr = fieldReferences.get(field);</span>
      try {
<span class="fc" id="L586">        IndexInput inIndexDocId = indexInputList.get(&quot;indexDocId&quot;);</span>
<span class="fc" id="L587">        ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; list = CodecSearchTree.searchMtasTree(docId,</span>
            inIndexDocId, fr.refIndexDocId, fr.refIndexDoc);
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (list.size() == 1) {</span>
<span class="fc" id="L590">          return new IndexDoc(list.get(0).ref);</span>
        }
<span class="nc" id="L592">      } catch (IOException e) {</span>
<span class="nc" id="L593">        log.debug(e);</span>
<span class="nc" id="L594">        return null;</span>
<span class="nc" id="L595">      }</span>
    }
<span class="nc" id="L597">    return null;</span>
  }

  /**
   * Gets the next doc.
   *
   * @param field
   *          the field
   * @param previousDocId
   *          the previous doc id
   * @return the next doc
   */
  public IndexDoc getNextDoc(String field, int previousDocId) {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="fc" id="L611">      FieldReferences fr = fieldReferences.get(field);</span>
      try {
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (previousDocId &lt; 0) {</span>
<span class="fc" id="L614">          return new IndexDoc(fr.refIndexDoc);</span>
        } else {
<span class="fc" id="L616">          int nextDocId = previousDocId + 1;</span>
<span class="fc" id="L617">          IndexInput inIndexDocId = indexInputList.get(&quot;indexDocId&quot;);</span>
<span class="fc" id="L618">          ArrayList&lt;MtasTreeHit&lt;?&gt;&gt; list = CodecSearchTree.advanceMtasTree(</span>
              nextDocId, inIndexDocId, fr.refIndexDocId, fr.refIndexDoc);
<span class="fc bfc" id="L620" title="All 2 branches covered.">          if (list.size() == 1) {</span>
<span class="fc" id="L621">            IndexInput inDoc = indexInputList.get(&quot;doc&quot;);</span>
<span class="fc" id="L622">            inDoc.seek(list.get(0).ref);</span>
<span class="fc" id="L623">            return new IndexDoc(inDoc.getFilePointer());</span>
          }
        }
<span class="nc" id="L626">      } catch (IOException e) {</span>
<span class="nc" id="L627">        log.debug(e);</span>
<span class="nc" id="L628">        return null;</span>
<span class="fc" id="L629">      }</span>
    }
<span class="fc" id="L631">    return null;</span>
  }

  /**
   * Gets the number of docs.
   *
   * @param field
   *          the field
   * @return the number of docs
   */
  public int getNumberOfDocs(String field) {
<span class="nc bnc" id="L642" title="All 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="nc" id="L643">      FieldReferences fr = fieldReferences.get(field);</span>
<span class="nc" id="L644">      return fr.numberOfDocs;</span>
    } else {
<span class="nc" id="L646">      return 0;</span>
    }
  }

  /**
   * Gets the number of positions.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @return the number of positions
   */
  public Integer getNumberOfPositions(String field, int docId) {
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="fc" id="L661">      IndexDoc doc = getDoc(field, docId);</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">      if (doc != null) {</span>
<span class="fc" id="L663">        return 1 + doc.maxPosition - doc.minPosition;</span>
      }
    }
<span class="nc" id="L666">    return null;</span>
  }

  /**
   * Gets the all number of positions.
   *
   * @param field
   *          the field
   * @param docBase
   *          the doc base
   * @return the all number of positions
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public HashMap&lt;Integer, Integer&gt; getAllNumberOfPositions(String field,
      int docBase) throws IOException {
<span class="fc" id="L682">    HashMap&lt;Integer, Integer&gt; numbers = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="fc" id="L684">      FieldReferences fr = fieldReferences.get(field);</span>
<span class="fc" id="L685">      IndexInput inIndexDoc = indexInputList.get(&quot;doc&quot;);</span>
<span class="fc" id="L686">      inIndexDoc.seek(fr.refIndexDoc);</span>
      IndexDoc doc;
<span class="fc bfc" id="L688" title="All 2 branches covered.">      for (int i = 0; i &lt; fr.numberOfDocs; i++) {</span>
<span class="fc" id="L689">        doc = new IndexDoc(null);</span>
<span class="fc" id="L690">        numbers.put((doc.docId + docBase),</span>
<span class="fc" id="L691">            (1 + doc.maxPosition - doc.minPosition));</span>
      }
    }
<span class="fc" id="L694">    return numbers;</span>
  }

  /**
   * Gets the number of tokens.
   *
   * @param field
   *          the field
   * @param docId
   *          the doc id
   * @return the number of tokens
   */
  public Integer getNumberOfTokens(String field, int docId) {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="fc" id="L708">      IndexDoc doc = getDoc(field, docId);</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">      if (doc != null) {</span>
<span class="fc" id="L710">        return doc.size;</span>
      }
    }
<span class="nc" id="L713">    return null;</span>
  }

  /**
   * Gets the all number of tokens.
   *
   * @param field
   *          the field
   * @param docBase
   *          the doc base
   * @return the all number of tokens
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public HashMap&lt;Integer, Integer&gt; getAllNumberOfTokens(String field,
      int docBase) throws IOException {
<span class="fc" id="L729">    HashMap&lt;Integer, Integer&gt; numbers = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">    if (fieldReferences.containsKey(field)) {</span>
<span class="fc" id="L731">      FieldReferences fr = fieldReferences.get(field);</span>
<span class="fc" id="L732">      IndexInput inIndexDoc = indexInputList.get(&quot;doc&quot;);</span>
<span class="fc" id="L733">      inIndexDoc.seek(fr.refIndexDoc);</span>
      IndexDoc doc;
<span class="fc bfc" id="L735" title="All 2 branches covered.">      for (int i = 0; i &lt; fr.numberOfDocs; i++) {</span>
<span class="fc" id="L736">        doc = new IndexDoc(null);</span>
<span class="fc" id="L737">        numbers.put((doc.docId + docBase), doc.size);</span>
      }
    }
<span class="fc" id="L740">    return numbers;</span>
  }

  /**
   * The Class IndexDoc.
   */
  public class IndexDoc {

    /** The doc id. */
    public int docId;

    /** The fp index object id. */
    public long fpIndexObjectId;

    /** The fp index object position. */
    public long fpIndexObjectPosition;

    /** The fp index object parent. */
    public long fpIndexObjectParent;

    /** The smallest object filepointer. */
    public long smallestObjectFilepointer;

    /** The object ref approx offset. */
    public long objectRefApproxOffset;

    /** The object ref approx quotient. */
    public int objectRefApproxQuotient;

    /** The storage flags. */
    public byte storageFlags;

    /** The size. */
    public int size;

    /** The min position. */
    public int minPosition;

    /** The max position. */
    public int maxPosition;

    /**
     * Instantiates a new index doc.
     *
     * @param ref
     *          the ref
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="fc" id="L789">    public IndexDoc(Long ref) throws IOException {</span>
      try {
<span class="fc" id="L791">        IndexInput inIndexDoc = indexInputList.get(&quot;doc&quot;);</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">        if (ref != null) {</span>
<span class="fc" id="L793">          inIndexDoc.seek(ref);</span>
        }
<span class="fc" id="L795">        docId = inIndexDoc.readVInt(); // docId</span>
<span class="fc" id="L796">        fpIndexObjectId = inIndexDoc.readVLong(); // ref indexObjectId</span>
<span class="fc" id="L797">        fpIndexObjectPosition = inIndexDoc.readVLong(); // ref</span>
                                                        // indexObjectPosition
<span class="fc" id="L799">        fpIndexObjectParent = inIndexDoc.readVLong(); // ref indexObjectParent</span>
<span class="fc" id="L800">        smallestObjectFilepointer = inIndexDoc.readVLong(); // offset</span>
<span class="fc" id="L801">        objectRefApproxQuotient = inIndexDoc.readVInt(); // slope</span>
<span class="fc" id="L802">        objectRefApproxOffset = inIndexDoc.readZLong(); // offset</span>
<span class="fc" id="L803">        storageFlags = inIndexDoc.readByte(); // flag</span>
<span class="fc" id="L804">        size = inIndexDoc.readVInt(); // number of objects</span>
<span class="fc" id="L805">        minPosition = inIndexDoc.readVInt(); // minimum position</span>
<span class="fc" id="L806">        maxPosition = inIndexDoc.readVInt(); // maximum position</span>
<span class="nc" id="L807">      } catch (Exception e) {</span>
<span class="nc" id="L808">        throw new IOException(e);</span>
<span class="fc" id="L809">      }</span>
<span class="fc" id="L810">    }</span>
  }

  /**
   * The Class FieldReferences.
   */
  private static class FieldReferences {

    /** The ref index doc. */
    public long refIndexDoc;

    /** The ref index doc id. */
    public long refIndexDocId;

    /** The ref prefix. */
    public long refPrefix;

    /** The number of docs. */
    public int numberOfDocs;

    /** The number of prefixes. */
    public int numberOfPrefixes;

    /**
     * Instantiates a new field references.
     *
     * @param refIndexDoc
     *          the ref index doc
     * @param refIndexDocId
     *          the ref index doc id
     * @param numberOfDocs
     *          the number of docs
     * @param refPrefix
     *          the ref prefix
     * @param numberOfPrefixes
     *          the number of prefixes
     */
    public FieldReferences(long refIndexDoc, long refIndexDocId,
<span class="fc" id="L848">        int numberOfDocs, long refPrefix, int numberOfPrefixes) {</span>
<span class="fc" id="L849">      this.refIndexDoc = refIndexDoc;</span>
<span class="fc" id="L850">      this.refIndexDocId = refIndexDocId;</span>
<span class="fc" id="L851">      this.numberOfDocs = numberOfDocs;</span>
<span class="fc" id="L852">      this.refPrefix = refPrefix;</span>
<span class="fc" id="L853">      this.numberOfPrefixes = numberOfPrefixes;</span>
<span class="fc" id="L854">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>