<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CodecCollector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.codec.util</a> &gt; <span class="el_source">CodecCollector.java</span></div><h1>CodecCollector.java</h1><pre class="source lang-java linenums">package mtas.codec.util;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import mtas.analysis.token.MtasToken;
import mtas.analysis.token.MtasTokenString;
import mtas.codec.MtasCodecPostingsFormat;
import mtas.codec.tree.IntervalTreeNodeData;
import mtas.codec.util.CodecComponent.ComponentDocument;
import mtas.codec.util.CodecComponent.ComponentFacet;
import mtas.codec.util.CodecComponent.ComponentField;
import mtas.codec.util.CodecComponent.ComponentGroup;
import mtas.codec.util.CodecComponent.ComponentHeatmap;
import mtas.codec.util.CodecComponent.ComponentCollection;
import mtas.codec.util.CodecComponent.ComponentKwic;
import mtas.codec.util.CodecComponent.ComponentList;
import mtas.codec.util.CodecComponent.ComponentPage;
import mtas.codec.util.CodecComponent.ComponentPosition;
import mtas.codec.util.CodecComponent.ComponentSpan;
import mtas.codec.util.CodecComponent.ComponentTermVector;
import mtas.codec.util.CodecComponent.ComponentToken;
import mtas.codec.util.CodecComponent.GroupHit;
import mtas.codec.util.CodecComponent.KwicHit;
import mtas.codec.util.CodecComponent.KwicToken;
import mtas.codec.util.CodecComponent.ListHit;
import mtas.codec.util.CodecComponent.ListToken;
import mtas.codec.util.CodecComponent.Match;
import mtas.codec.util.CodecComponent.PageRangeData;
import mtas.codec.util.CodecComponent.PageSetData;
import mtas.codec.util.CodecComponent.PageWordData;
import mtas.codec.util.CodecComponent.SubComponentDistance;
import mtas.codec.util.CodecComponent.SubComponentFunction;
import mtas.codec.util.CodecInfo.IndexDoc;
import mtas.codec.util.CodecSearchTree.MtasTreeHit;
import mtas.codec.util.collector.MtasDataCollector;
import mtas.codec.util.heatmap.HeatmapMtasCounter;
import mtas.parser.function.ParseException;
import mtas.parser.function.util.MtasFunctionParserFunction;
import mtas.search.spans.MtasSpanAndQuery;
import mtas.search.spans.MtasSpanFollowedByQuery;
import mtas.search.spans.MtasSpanMatchAllQuery;
import mtas.search.spans.MtasSpanPrecededByQuery;
import mtas.search.spans.MtasSpanSequenceItem;
import mtas.search.spans.MtasSpanSequenceQuery;
import mtas.search.spans.MtasSpanTermQuery;
import mtas.search.spans.util.MtasSpanQuery;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.DocValuesType;
import org.apache.lucene.index.FieldInfo;
import org.apache.lucene.index.FieldInfos;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexableField;
import org.apache.lucene.index.LeafReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.NumericDocValues;
import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.index.SortedDocValues;
import org.apache.lucene.index.SortedNumericDocValues;
import org.apache.lucene.index.SortedSetDocValues;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.search.DocIdSetIterator;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.spans.SpanWeight;
import org.apache.lucene.search.spans.Spans;
import org.apache.lucene.util.Bits;
import org.apache.lucene.util.BytesRef;
import org.apache.lucene.util.automaton.Automaton;
import org.apache.lucene.util.automaton.ByteRunAutomaton;
import org.apache.lucene.util.automaton.CompiledAutomaton;
import org.apache.lucene.util.automaton.RegExp;
import org.apache.solr.legacy.LegacyNumericUtils;
import org.apache.solr.schema.NumberType;

/**
 * The Class CodecCollector.
 */
public class CodecCollector {

  /** The Constant log. */
<span class="fc" id="L105">  private static final Log log = LogFactory.getLog(CodecCollector.class);</span>

  /**
   * Instantiates a new codec collector.
   */
<span class="nc" id="L110">  public CodecCollector() {</span>
<span class="nc" id="L111">  }</span>

  /**
   * Collect field.
   *
   * @param field
   *          the field
   * @param searcher
   *          the searcher
   * @param reader
   *          the reader
   * @param rawReader
   *          the raw reader
   * @param fullDocList
   *          the full doc list
   * @param fullDocSet
   *          the full doc set
   * @param fieldInfo
   *          the field info
   * @param spansQueryWeight
   *          the spans query weight
   * @param status
   *          the status
   * @throws IllegalAccessException
   *           the illegal access exception
   * @throws IllegalArgumentException
   *           the illegal argument exception
   * @throws InvocationTargetException
   *           the invocation target exception
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public static void collectField(String field, IndexSearcher searcher, IndexReader reader, IndexReader rawReader,
      List&lt;Integer&gt; fullDocList, List&lt;Integer&gt; fullDocSet, ComponentField fieldInfo,
      Map&lt;MtasSpanQuery, SpanWeight&gt; spansQueryWeight, Status status)
      throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException {

<span class="fc" id="L148">    Map&lt;Integer, List&lt;Integer&gt;&gt; docSets = new HashMap&lt;&gt;();</span>

<span class="fc" id="L150">    ListIterator&lt;LeafReaderContext&gt; iterator = reader.leaves().listIterator();</span>
<span class="fc" id="L151">    long numberOfDocumentsFound = 0;</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">    if (status != null) {</span>
<span class="fc" id="L153">      status.init(reader.numDocs(), reader.leaves().size());</span>
<span class="pc bpc" id="L154" title="1 of 4 branches missed.">      if (fullDocSet != null &amp;&amp; status.numberDocumentsFound == null) {</span>
<span class="fc" id="L155">        status.numberDocumentsFound = numberOfDocumentsFound;</span>
      }
    }

<span class="fc bfc" id="L159" title="All 2 branches covered.">    while (iterator.hasNext()) {</span>
<span class="fc" id="L160">      LeafReaderContext lrc = iterator.next();</span>
<span class="fc" id="L161">      LeafReader r = lrc.reader();</span>
      // compute relevant docSet/docList
<span class="fc" id="L163">      List&lt;Integer&gt; docSet = null;</span>
<span class="fc" id="L164">      List&lt;Integer&gt; docList = null;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">      if (fullDocSet != null) {</span>
<span class="fc" id="L166">        docSet = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L167">        docSets.put(lrc.ord, docSet);</span>
<span class="fc" id="L168">        Iterator&lt;Integer&gt; docSetIterator = fullDocSet.iterator();</span>
<span class="fc" id="L169">        Integer docSetId = null;</span>
<span class="fc" id="L170">        Bits liveDocs = lrc.reader().getLiveDocs();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        while (docSetIterator.hasNext()) {</span>
<span class="fc" id="L172">          docSetId = docSetIterator.next();</span>
          // just to make sure to ignore deleted documents
<span class="pc bpc" id="L174" title="1 of 6 branches missed.">          if ((docSetId &gt;= lrc.docBase) &amp;&amp; (docSetId &lt; lrc.docBase + lrc.reader().maxDoc())</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">              &amp;&amp; (liveDocs == null || liveDocs.get((docSetId - lrc.docBase)))) {</span>
<span class="fc" id="L176">            docSet.add(docSetId);</span>
          }
        }
<span class="fc" id="L179">        Collections.sort(docSet);</span>
<span class="fc" id="L180">        numberOfDocumentsFound += docSet.size();</span>
<span class="fc" id="L181">        status.numberDocumentsFound = Math.max(status.numberDocumentsFound, numberOfDocumentsFound);</span>
      }
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">      if (fullDocList != null) {</span>
<span class="fc" id="L184">        docList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L185">        Iterator&lt;Integer&gt; docListIterator = fullDocList.iterator();</span>
<span class="fc" id="L186">        Integer docListId = null;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        while (docListIterator.hasNext()) {</span>
<span class="fc" id="L188">          docListId = docListIterator.next();</span>
<span class="fc bfc" id="L189" title="All 4 branches covered.">          if ((docListId &gt;= lrc.docBase) &amp;&amp; (docListId &lt; lrc.docBase + lrc.reader().maxDoc())) {</span>
<span class="fc" id="L190">            docList.add(docListId);</span>
          }
        }
<span class="fc" id="L193">        Collections.sort(docList);</span>
      }

<span class="fc" id="L196">      Terms t = rawReader.leaves().get(lrc.ord).reader().terms(field);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">      CodecInfo mtasCodecInfo = t == null ? null : CodecInfo.getCodecInfoFromTerms(t);</span>

<span class="fc" id="L199">      collectSpansPositionsAndTokens(spansQueryWeight, searcher, mtasCodecInfo, r, lrc, field, t, docSet, docList,</span>
<span class="fc" id="L200">          fieldInfo, rawReader.leaves().get(lrc.ord).reader().getFieldInfos(), status);</span>
<span class="fc" id="L201">      collectPrefixes(rawReader.leaves().get(lrc.ord).reader().getFieldInfos(), field, fieldInfo, status);</span>

<span class="pc bpc" id="L203" title="1 of 2 branches missed.">      if (status != null) {</span>
        Integer segmentNumber;
        Long documentNumber;
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if ((segmentNumber = status.subNumberSegmentsFinished.get(field)) != null) {</span>
<span class="fc" id="L207">          status.subNumberSegmentsFinished.put(field, segmentNumber + 1);</span>
<span class="fc" id="L208">          status.subNumberSegmentsFinishedTotal++;</span>
<span class="fc" id="L209">          status.numberSegmentsFinished = Collections.max(status.subNumberSegmentsFinished.values());</span>
        }
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if ((documentNumber = status.subNumberDocumentsFinished.get(field)) != null) {</span>
<span class="fc" id="L212">          status.subNumberDocumentsFinished.put(field, documentNumber + r.numDocs());</span>
<span class="fc" id="L213">          status.subNumberDocumentsFinishedTotal += +r.numDocs();</span>
<span class="fc" id="L214">          status.numberDocumentsFinished = Collections.max(status.subNumberDocumentsFinished.values());</span>
        }
      }
<span class="fc" id="L217">    }</span>

    // check termvectors
<span class="fc bfc" id="L220" title="All 4 branches covered.">    if (!fieldInfo.termVectorList.isEmpty() &amp;&amp; needSecondRoundTermvector(fieldInfo.termVectorList)) {</span>
      // check positions
<span class="fc" id="L222">      boolean needPositions = false;</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">      if (!fieldInfo.termVectorList.isEmpty()) {</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (ComponentTermVector ctv : fieldInfo.termVectorList) {</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">          if (!needPositions) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">            needPositions = ctv.functions != null ? ctv.functionNeedPositions() : needPositions;</span>
          }
<span class="fc" id="L228">        }</span>
      }
<span class="fc" id="L230">      Map&lt;Integer, Integer&gt; positionsData = null;</span>

      // loop
<span class="fc" id="L233">      iterator = reader.leaves().listIterator();</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">      while (iterator.hasNext()) {</span>
<span class="fc" id="L235">        LeafReaderContext lrc = iterator.next();</span>
<span class="fc" id="L236">        LeafReader r = lrc.reader();</span>
<span class="fc" id="L237">        List&lt;Integer&gt; docSet = docSets.get(lrc.ord);</span>
<span class="fc" id="L238">        Terms t = rawReader.leaves().get(lrc.ord).reader().terms(field);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (needPositions) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">          CodecInfo mtasCodecInfo = t == null ? null : CodecInfo.getCodecInfoFromTerms(t);</span>
<span class="nc" id="L241">          positionsData = computePositions(mtasCodecInfo, r, lrc, field, docSet);</span>
        }
<span class="fc" id="L243">        createTermvectorSecondRound(fieldInfo.termVectorList, positionsData, docSets.get(lrc.ord), t, r, lrc, status);</span>
<span class="fc" id="L244">      }</span>

    }
<span class="fc" id="L247">  }</span>

  /**
   * Collect collection.
   *
   * @param reader
   *          the reader
   * @param docSet
   *          the doc set
   * @param collectionInfo
   *          the collection info
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  public static void collectCollection(IndexReader reader, List&lt;Integer&gt; docSet, ComponentCollection collectionInfo)
      throws IOException {
<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (collectionInfo.action().equals(ComponentCollection.ACTION_CHECK)) {</span>
      // can't do anything in lucene for check
<span class="fc bfc" id="L265" title="All 2 branches covered.">    } else if (collectionInfo.action().equals(ComponentCollection.ACTION_LIST)) {</span>
      // can't do anything in lucene for list
<span class="fc bfc" id="L267" title="All 2 branches covered.">    } else if (collectionInfo.action().equals(ComponentCollection.ACTION_CREATE)) {</span>
<span class="fc" id="L268">      BytesRef term = null;</span>
<span class="fc" id="L269">      PostingsEnum postingsEnum = null;</span>
      Integer docId;
<span class="fc" id="L271">      Integer termDocId = -1;</span>
      Terms terms;
      LeafReaderContext lrc;
      LeafReader r;
<span class="fc" id="L275">      ListIterator&lt;LeafReaderContext&gt; iterator = reader.leaves().listIterator();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">      while (iterator.hasNext()) {</span>
<span class="fc" id="L277">        lrc = iterator.next();</span>
<span class="fc" id="L278">        r = lrc.reader();</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (String field : collectionInfo.fields()) {</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">          if ((terms = r.terms(field)) != null) {</span>
<span class="fc" id="L281">            TermsEnum termsEnum = terms.iterator();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            while ((term = termsEnum.next()) != null) {</span>
<span class="fc" id="L283">              Iterator&lt;Integer&gt; docIterator = docSet.iterator();</span>
<span class="fc" id="L284">              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);</span>
<span class="fc" id="L285">              termDocId = -1;</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">              while (docIterator.hasNext()) {</span>
<span class="fc" id="L287">                docId = docIterator.next() - lrc.docBase;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">                if ((docId &gt;= termDocId)</span>
<span class="fc bfc" id="L289" title="All 4 branches covered.">                    &amp;&amp; ((docId.equals(termDocId)) || ((termDocId = postingsEnum.advance(docId)).equals(docId)))) {</span>
<span class="fc" id="L290">                  collectionInfo.addValue(term.utf8ToString());</span>
<span class="fc" id="L291">                  break;</span>
                }
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                if (termDocId.equals(PostingsEnum.NO_MORE_DOCS)) {</span>
<span class="nc" id="L294">                  break;</span>
                }
              }
<span class="fc" id="L297">            }</span>
          }
<span class="fc" id="L299">        }</span>
      }
    }
<span class="fc" id="L302">  }</span>

  /**
   * Collect spans positions and tokens.
   *
   * @param spansQueryWeight
   *          the spans query weight
   * @param searcher
   *          the searcher
   * @param mtasCodecInfo
   *          the mtas codec info
   * @param r
   *          the r
   * @param lrc
   *          the lrc
   * @param field
   *          the field
   * @param t
   *          the t
   * @param docSet
   *          the doc set
   * @param docList
   *          the doc list
   * @param fieldInfo
   *          the field info
   * @param fieldInfos
   *          the field infos
   * @param status
   *          the status
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void collectSpansPositionsAndTokens(Map&lt;MtasSpanQuery, SpanWeight&gt; spansQueryWeight,
      IndexSearcher searcher, CodecInfo mtasCodecInfo, LeafReader r, LeafReaderContext lrc, String field, Terms t,
      List&lt;Integer&gt; docSet, List&lt;Integer&gt; docList, ComponentField fieldInfo, FieldInfos fieldInfos, Status status)
      throws IOException {

<span class="fc" id="L339">    boolean needSpans = false;</span>
<span class="fc" id="L340">    boolean needPositions = false;</span>
<span class="fc" id="L341">    boolean needTokens = false;</span>

    // results
<span class="fc" id="L344">    Map&lt;Integer, Integer&gt; positionsData = null;</span>
<span class="fc" id="L345">    Map&lt;Integer, Integer&gt; tokensData = null;</span>
<span class="fc" id="L346">    Set&lt;MtasSpanQuery&gt; spansNumberByPositions = null;</span>
<span class="fc" id="L347">    Map&lt;MtasSpanQuery, Map&lt;Integer, Integer&gt;&gt; spansNumberData = null;</span>
<span class="fc" id="L348">    Map&lt;MtasSpanQuery, Map&lt;Integer, List&lt;Match&gt;&gt;&gt; spansMatchData = null;</span>
<span class="fc" id="L349">    Map&lt;String, SortedMap&lt;String, int[]&gt;&gt; facetData = null;</span>
<span class="fc" id="L350">    Map&lt;String, String&gt; facetDataType = null;</span>

    // collect position stats
<span class="fc bfc" id="L353" title="All 2 branches covered.">    if (!fieldInfo.statsPositionList.isEmpty()) {</span>
<span class="fc" id="L354">      needPositions = true;</span>
    }
    // collect token stats
<span class="fc bfc" id="L357" title="All 2 branches covered.">    if (!fieldInfo.statsTokenList.isEmpty()) {</span>
<span class="fc" id="L358">      needTokens = true;</span>
    }
<span class="fc bfc" id="L360" title="All 2 branches covered.">    if (!fieldInfo.termVectorList.isEmpty()) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      for (ComponentTermVector ctv : fieldInfo.termVectorList) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (!needPositions) {</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">          needPositions = (ctv.functions == null ? ctv.subComponentFunction.parserFunction.needPositions()</span>
<span class="fc" id="L364">              : ctv.functionNeedPositions());</span>
        }
<span class="fc" id="L366">      }</span>
    }

    // compute from spans for selected docs
<span class="fc bfc" id="L370" title="All 2 branches covered.">    if (!fieldInfo.spanQueryList.isEmpty()) {</span>
      // check for statsSpans
<span class="fc" id="L372">      spansNumberByPositions = new HashSet&lt;&gt;();</span>
<span class="fc" id="L373">      spansNumberData = new HashMap&lt;&gt;();</span>
<span class="fc" id="L374">      spansMatchData = new HashMap&lt;&gt;();</span>
<span class="fc" id="L375">      facetData = new HashMap&lt;&gt;();</span>
<span class="fc" id="L376">      facetDataType = new HashMap&lt;&gt;();</span>
      // spans
<span class="fc bfc" id="L378" title="All 2 branches covered.">      if (!fieldInfo.statsSpanList.isEmpty()) {</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        for (ComponentSpan cs : fieldInfo.statsSpanList) {</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">          needPositions = (!needPositions) ? cs.parser.needPositions() : needPositions;</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">          needPositions = (!needPositions) ? cs.functionNeedPositions() : needPositions;</span>
<span class="pc bpc" id="L382" title="1 of 4 branches missed.">          needSpans = (!needSpans) ? cs.parser.needArgumentsNumber() &gt; 0 : needSpans;</span>
<span class="fc" id="L383">          HashSet&lt;Integer&gt; arguments = cs.parser.needArgument();</span>
<span class="fc" id="L384">          arguments.addAll(cs.functionNeedArguments());</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">          for (int a : arguments) {</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (cs.queries.length &gt; a) {</span>
<span class="fc" id="L387">              MtasSpanQuery q = cs.queries[a];</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">              if (!spansNumberData.containsKey(q)) {</span>
<span class="fc" id="L389">                spansNumberData.put(q, new HashMap&lt;Integer, Integer&gt;());</span>
              }
            }
<span class="fc" id="L392">          }</span>
<span class="fc" id="L393">        }</span>
      }
      // kwic
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">      if (!fieldInfo.kwicList.isEmpty()) {</span>
<span class="nc" id="L397">        needSpans = true;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        for (ComponentKwic ck : fieldInfo.kwicList) {</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">          if (!spansMatchData.containsKey(ck.query)) {</span>
<span class="nc" id="L400">            spansMatchData.put(ck.query, new HashMap&lt;Integer, List&lt;Match&gt;&gt;());</span>
          }
<span class="nc" id="L402">        }</span>
      }
      // list
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">      if (!fieldInfo.listList.isEmpty()) {</span>
<span class="nc" id="L406">        needSpans = true;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        for (ComponentList cl : fieldInfo.listList) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">          if (!spansMatchData.containsKey(cl.spanQuery)) {</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (cl.number &gt; 0) {</span>
              // only if needed
<span class="nc bnc" id="L411" title="All 2 branches missed.">              if (cl.position &lt; (cl.start + cl.number)) {</span>
<span class="nc" id="L412">                spansMatchData.put(cl.spanQuery, new HashMap&lt;Integer, List&lt;Match&gt;&gt;());</span>
              } else {
<span class="nc" id="L414">                spansNumberData.put(cl.spanQuery, new HashMap&lt;Integer, Integer&gt;());</span>
              }
<span class="nc bnc" id="L416" title="All 2 branches missed.">            } else if (!spansNumberData.containsKey(cl.spanQuery)) {</span>
<span class="nc" id="L417">              spansNumberData.put(cl.spanQuery, new HashMap&lt;Integer, Integer&gt;());</span>
            }
          }
<span class="nc" id="L420">        }</span>
      }
      // group
<span class="fc bfc" id="L423" title="All 2 branches covered.">      if (!fieldInfo.groupList.isEmpty()) {</span>
<span class="fc" id="L424">        needSpans = true;</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        for (ComponentGroup cg : fieldInfo.groupList) {</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">          if (!spansMatchData.containsKey(cg.spanQuery)) {</span>
<span class="fc" id="L427">            spansMatchData.put(cg.spanQuery, new HashMap&lt;Integer, List&lt;Match&gt;&gt;());</span>
          }
<span class="fc" id="L429">        }</span>
      }
      // heatmap
<span class="fc bfc" id="L432" title="All 2 branches covered.">      if (!fieldInfo.heatmapList.isEmpty()) {</span>
<span class="fc" id="L433">        needSpans = true;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        for (ComponentHeatmap ch : fieldInfo.heatmapList) {</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">          needPositions = (!needPositions) ? ch.parser.needPositions() : needPositions;</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">          needPositions = (!needPositions) ? ch.hm.functionNeedPositions() : needPositions;</span>
<span class="pc bpc" id="L437" title="3 of 4 branches missed.">          needSpans = (!needSpans) ? ch.parser.needArgumentsNumber() &gt; 0 : needSpans;</span>
<span class="fc" id="L438">          HashSet&lt;Integer&gt; arguments = ch.parser.needArgument();</span>
<span class="fc" id="L439">          arguments.addAll(ch.hm.functionNeedArguments());</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">          for (int a : arguments) {</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            if (ch.queries.length &gt; a) {</span>
<span class="fc" id="L442">              MtasSpanQuery q = ch.queries[a];</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">              if (!spansNumberData.containsKey(q)) {</span>
<span class="fc" id="L444">                spansNumberData.put(q, new HashMap&lt;Integer, Integer&gt;());</span>
              }
            }
<span class="fc" id="L447">          }</span>
<span class="fc" id="L448">        }</span>
      }
      // facet
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">      if (!fieldInfo.facetList.isEmpty()) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        for (ComponentFacet cf : fieldInfo.facetList) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">          needPositions = !needPositions ? cf.baseParserNeedPositions() : needPositions;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">          needPositions = !needPositions ? cf.functionNeedPositions() : needPositions;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">          for (int i = 0; i &lt; cf.baseFields.length; i++) {</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">            needSpans = !needSpans ? cf.baseParsers[i].needArgumentsNumber() &gt; 0 : needSpans;</span>
<span class="nc" id="L457">            HashSet&lt;Integer&gt; arguments = cf.baseParsers[i].needArgument();</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            for (int a : arguments) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">              if (cf.spanQueries.length &gt; a) {</span>
<span class="nc" id="L460">                MtasSpanQuery q = cf.spanQueries[a];</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                if (!spansNumberData.containsKey(q)) {</span>
<span class="nc" id="L462">                  spansNumberData.put(q, new HashMap&lt;Integer, Integer&gt;());</span>
                }
              }
<span class="nc" id="L465">            }</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            for (MtasFunctionParserFunction function : cf.baseFunctionParserFunctions[i]) {</span>
<span class="nc bnc" id="L467" title="All 4 branches missed.">              needSpans = !needSpans ? function.needArgumentsNumber() &gt; 0 : needSpans;</span>
<span class="nc" id="L468">              arguments = function.needArgument();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">              for (int a : arguments) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (cf.spanQueries.length &gt; a) {</span>
<span class="nc" id="L471">                  MtasSpanQuery q = cf.spanQueries[a];</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                  if (!spansNumberData.containsKey(q)) {</span>
<span class="nc" id="L473">                    spansNumberData.put(q, new HashMap&lt;Integer, Integer&gt;());</span>
                  }
                }
<span class="nc" id="L476">              }</span>
            }
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (!facetData.containsKey(cf.baseFields[i])) {</span>
<span class="nc" id="L479">              facetData.put(cf.baseFields[i], new TreeMap&lt;String, int[]&gt;());</span>
<span class="nc" id="L480">              facetDataType.put(cf.baseFields[i], cf.baseFieldTypes[i]);</span>
            }
          }
<span class="nc" id="L483">        }</span>
      }
      // termvector
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">      if (!fieldInfo.termVectorList.isEmpty()) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        for (ComponentTermVector ctv : fieldInfo.termVectorList) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">          if ((ctv.subComponentFunction.parserFunction != null</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">              &amp;&amp; ctv.subComponentFunction.parserFunction.needPositions())</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">              || (ctv.functions != null &amp;&amp; ctv.functionNeedPositions())) {</span>
<span class="nc" id="L491">            needPositions = true;</span>
          }
<span class="nc" id="L493">        }</span>
      }
    }

<span class="fc bfc" id="L497" title="All 2 branches covered.">    if (needSpans) {</span>
      Map&lt;Integer, Integer&gt; numberData;
      Map&lt;Integer, List&lt;Match&gt;&gt; matchData;
      // collect values for facetFields
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">      for (Entry&lt;String, SortedMap&lt;String, int[]&gt;&gt; entry : facetData.entrySet()) {</span>
<span class="nc" id="L502">        FieldInfo fi = fieldInfos.fieldInfo(entry.getKey());</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (fi != null) {</span>
          // prefer to use pointvalue
<span class="nc bnc" id="L505" title="All 2 branches missed.">          if (!fi.getDocValuesType().equals(DocValuesType.NONE)) {</span>
<span class="nc" id="L506">            Iterator&lt;Integer&gt; docIterator = docSet.iterator();</span>
            // numeric or sorted
<span class="nc bnc" id="L508" title="All 2 branches missed.">            if (fi.getDocValuesType().equals(DocValuesType.NUMERIC)</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">                || fi.getDocValuesType().equals(DocValuesType.SORTED)</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                || fi.getDocValuesType().equals(DocValuesType.SORTED_SET)</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                || fi.getDocValuesType().equals(DocValuesType.SORTED_NUMERIC)</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                || fi.getDocValuesType().equals(DocValuesType.BINARY)) {</span>
              // create map of values to corresponding docIds
<span class="nc" id="L514">              Map&lt;Object, List&lt;Integer&gt;&gt; facetDataSubList = new HashMap&lt;&gt;();</span>
              // numeric
<span class="nc bnc" id="L516" title="All 2 branches missed.">              if (fi.getDocValuesType().equals(DocValuesType.NUMERIC)) {</span>
<span class="nc" id="L517">                NumericDocValues docValues = r.getContext().reader().getNumericDocValues(entry.getKey());</span>
                int docId;
<span class="nc bnc" id="L519" title="All 2 branches missed.">                while (docIterator.hasNext()) {</span>
<span class="nc" id="L520">                  docId = docIterator.next() - lrc.docBase;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                  if (docValues.advanceExact(docId)) {</span>
<span class="nc" id="L522">                    long value = docValues.longValue();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                    if (!facetDataSubList.containsKey(value)) {</span>
<span class="nc" id="L524">                      List&lt;Integer&gt; facetDataSubListItem = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L525">                      facetDataSubListItem.add(docId + lrc.docBase);</span>
<span class="nc" id="L526">                      facetDataSubList.put(value, facetDataSubListItem);</span>
<span class="nc" id="L527">                    } else {</span>
<span class="nc" id="L528">                      facetDataSubList.get(value).add(docId + lrc.docBase);</span>
                    }
<span class="nc" id="L530">                  }</span>
                }
                // sorted numeric
<span class="nc bnc" id="L533" title="All 2 branches missed.">              } else if (fi.getDocValuesType().equals(DocValuesType.SORTED_NUMERIC)) {</span>
<span class="nc" id="L534">                SortedNumericDocValues docValues = r.getContext().reader().getSortedNumericDocValues(entry.getKey());</span>
                int docId;
<span class="nc bnc" id="L536" title="All 2 branches missed.">                while (docIterator.hasNext()) {</span>
<span class="nc" id="L537">                  docId = docIterator.next() - lrc.docBase;</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                  if (docValues.advanceExact(docId)) {</span>
<span class="nc" id="L539">                    int n = docValues.docValueCount();</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L541">                      long value = docValues.nextValue();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                      if (!facetDataSubList.containsKey(value)) {</span>
<span class="nc" id="L543">                        List&lt;Integer&gt; facetDataSubListItem = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L544">                        facetDataSubListItem.add(docId + lrc.docBase);</span>
<span class="nc" id="L545">                        facetDataSubList.put(value, facetDataSubListItem);</span>
<span class="nc" id="L546">                      } else {</span>
<span class="nc" id="L547">                        facetDataSubList.get(value).add(docId + lrc.docBase);</span>
                      }
                    }
<span class="nc" id="L550">                  }</span>
                }
                // sorted set
<span class="nc bnc" id="L553" title="All 2 branches missed.">              } else if (fi.getDocValuesType().equals(DocValuesType.SORTED_SET)) {</span>
<span class="nc" id="L554">                SortedSetDocValues docValues = r.getContext().reader().getSortedSetDocValues(entry.getKey());</span>
                int docId;
<span class="nc" id="L556">                Map&lt;Long, String&gt; dictionary = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                while (docIterator.hasNext()) {</span>
<span class="nc" id="L558">                  docId = docIterator.next() - lrc.docBase;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                  if (docValues.advanceExact(docId)) {</span>
                    long tmpValue;
                    String value;
<span class="nc bnc" id="L562" title="All 2 branches missed.">                    while ((tmpValue = docValues.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                      if (!dictionary.containsKey(tmpValue)) {</span>
<span class="nc" id="L564">                        value = docValues.lookupOrd(tmpValue).utf8ToString();</span>
<span class="nc" id="L565">                        dictionary.put(tmpValue, value);</span>
                      } else {
<span class="nc" id="L567">                        value = dictionary.get(tmpValue);</span>
                      }
<span class="nc bnc" id="L569" title="All 2 branches missed.">                      if (!facetDataSubList.containsKey(value)) {</span>
<span class="nc" id="L570">                        List&lt;Integer&gt; facetDataSubListItem = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L571">                        facetDataSubListItem.add(docId + lrc.docBase);</span>
<span class="nc" id="L572">                        facetDataSubList.put(value, facetDataSubListItem);</span>
<span class="nc" id="L573">                      } else {</span>
<span class="nc" id="L574">                        facetDataSubList.get(value).add(docId + lrc.docBase);</span>
                      }
                    }
<span class="nc" id="L577">                  }</span>
                }
                // sorted
<span class="nc bnc" id="L580" title="All 2 branches missed.">              } else if (fi.getDocValuesType().equals(DocValuesType.SORTED)) {</span>
<span class="nc" id="L581">                SortedDocValues docValues = r.getContext().reader().getSortedDocValues(entry.getKey());</span>
                int docId;
<span class="nc bnc" id="L583" title="All 2 branches missed.">                while (docIterator.hasNext()) {</span>
<span class="nc" id="L584">                  docId = docIterator.next() - lrc.docBase;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                  if (docValues.advanceExact(docId)) {</span>
<span class="nc" id="L586">                    String value = docValues.binaryValue().utf8ToString();</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                    if (!facetDataSubList.containsKey(value)) {</span>
<span class="nc" id="L588">                      List&lt;Integer&gt; facetDataSubListItem = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L589">                      facetDataSubListItem.add(docId + lrc.docBase);</span>
<span class="nc" id="L590">                      facetDataSubList.put(value, facetDataSubListItem);</span>
<span class="nc" id="L591">                    } else {</span>
<span class="nc" id="L592">                      facetDataSubList.get(value).add(docId + lrc.docBase);</span>
                    }
<span class="nc" id="L594">                  }</span>
                }
              }
<span class="nc bnc" id="L597" title="All 2 branches missed.">              if (!facetDataSubList.isEmpty()) {</span>
<span class="nc" id="L598">                SortedMap&lt;String, int[]&gt; facetDataList = entry.getValue();</span>
<span class="nc" id="L599">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;);</span>
<span class="nc" id="L600">                sdf.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                for (Entry&lt;Object, List&lt;Integer&gt;&gt; facetEntry : facetDataSubList.entrySet()) {</span>
<span class="nc" id="L602">                  int[] docIdList = facetEntry.getValue().stream().mapToInt(i -&gt; i).toArray();</span>
                  String termValue;
<span class="nc bnc" id="L604" title="All 2 branches missed.">                  if (facetDataType.get(entry.getKey()).equals(NumberType.DATE.name())) {</span>
<span class="nc" id="L605">                    Date date = new Date((Long) facetEntry.getKey());</span>
<span class="nc" id="L606">                    termValue = sdf.format(date);</span>
<span class="nc" id="L607">                  } else {</span>
<span class="nc" id="L608">                    termValue = facetEntry.getKey().toString();</span>
                  }
<span class="nc bnc" id="L610" title="All 2 branches missed.">                  if (!facetDataList.containsKey(termValue)) {</span>
<span class="nc" id="L611">                    facetDataList.put(termValue, docIdList);</span>
                  } else {
<span class="nc" id="L613">                    int[] oldList = facetDataList.get(termValue);</span>
<span class="nc" id="L614">                    int[] newList = new int[oldList.length + docIdList.length];</span>
<span class="nc" id="L615">                    System.arraycopy(oldList, 0, newList, 0, oldList.length);</span>
<span class="nc" id="L616">                    System.arraycopy(docIdList, 0, newList, oldList.length, docIdList.length);</span>
<span class="nc" id="L617">                    facetDataList.put(termValue, newList);</span>
                  }
<span class="nc" id="L619">                }</span>
              }
<span class="nc" id="L621">            } else {</span>
<span class="nc" id="L622">              throw new IOException(&quot;facets for docValues of type &quot; + fi.getDocValuesType() + &quot; not implemented&quot;);</span>
            }
<span class="nc bnc" id="L624" title="All 2 branches missed.">          } else if (!docSet.isEmpty()) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (facetDataType.get(entry.getKey()).equals(ComponentFacet.TYPE_POINTFIELD_WITHOUT_DOCVALUES)) {</span>
<span class="nc" id="L626">              throw new IOException(&quot;can't create facets for pointField without docValues&quot;);</span>
            }
<span class="nc" id="L628">            Terms fft = r.terms(entry.getKey());</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (fft != null) {</span>
<span class="nc" id="L630">              TermsEnum termsEnum = fft.iterator();</span>
<span class="nc" id="L631">              BytesRef term = null;</span>
<span class="nc" id="L632">              PostingsEnum postingsEnum = null;</span>
<span class="nc" id="L633">              SortedMap&lt;String, int[]&gt; facetDataList = entry.getValue();</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">              while ((term = termsEnum.next()) != null) {</span>
                int docId;
<span class="nc" id="L636">                int termDocId = -1;</span>
<span class="nc" id="L637">                int[] facetDataSublist = new int[docSet.size()];</span>
<span class="nc" id="L638">                int facetDataSublistCounter = 0;</span>
<span class="nc" id="L639">                Iterator&lt;Integer&gt; docIterator = docSet.iterator();</span>
<span class="nc" id="L640">                postingsEnum = termsEnum.postings(postingsEnum);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                while (docIterator.hasNext()) {</span>
<span class="nc" id="L642">                  docId = docIterator.next() - lrc.docBase;</span>
<span class="nc bnc" id="L643" title="All 4 branches missed.">                  if (docId &gt;= termDocId</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                      &amp;&amp; ((docId == termDocId) || ((termDocId = postingsEnum.advance(docId)) == docId))) {</span>
<span class="nc" id="L645">                    facetDataSublist[facetDataSublistCounter] = docId + lrc.docBase;</span>
<span class="nc" id="L646">                    facetDataSublistCounter++;</span>
                  }
                }
<span class="nc bnc" id="L649" title="All 2 branches missed.">                if (facetDataSublistCounter &gt; 0) {</span>
<span class="nc" id="L650">                  String termValue = null;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                  if (facetDataType.get(entry.getKey()).equals(NumberType.INTEGER.name())) {</span>
                    // only values without shifting bits
<span class="nc bnc" id="L653" title="All 2 branches missed.">                    if (term.bytes[term.offset] == LegacyNumericUtils.SHIFT_START_INT) {</span>
<span class="nc" id="L654">                      termValue = Integer.toString(LegacyNumericUtils.prefixCodedToInt(term));</span>
                    } else {
                      continue;
                    }
<span class="nc bnc" id="L658" title="All 2 branches missed.">                  } else if (facetDataType.get(entry.getKey()).equals(NumberType.LONG.name())) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                    if (term.bytes[term.offset] == LegacyNumericUtils.SHIFT_START_LONG) {</span>
<span class="nc" id="L660">                      termValue = Long.toString(LegacyNumericUtils.prefixCodedToLong(term));</span>
                    } else {
                      continue;
                    }
                  } else {
<span class="nc" id="L665">                    termValue = term.utf8ToString();</span>
                  }
<span class="nc bnc" id="L667" title="All 2 branches missed.">                  if (!facetDataList.containsKey(termValue)) {</span>
<span class="nc" id="L668">                    facetDataList.put(termValue, Arrays.copyOf(facetDataSublist, facetDataSublistCounter));</span>
                  } else {
<span class="nc" id="L670">                    int[] oldList = facetDataList.get(termValue);</span>
<span class="nc" id="L671">                    int[] newList = new int[oldList.length + facetDataSublistCounter];</span>
<span class="nc" id="L672">                    System.arraycopy(oldList, 0, newList, 0, oldList.length);</span>
<span class="nc" id="L673">                    System.arraycopy(facetDataSublist, 0, newList, oldList.length, facetDataSublistCounter);</span>
<span class="nc" id="L674">                    facetDataList.put(termValue, newList);</span>
                  }
                }
<span class="nc" id="L677">              }</span>
            }
          }
        }
<span class="nc" id="L681">      }</span>

      // collect matches and numbers for queries
<span class="fc bfc" id="L684" title="All 2 branches covered.">      for (MtasSpanQuery sq : fieldInfo.spanQueryList) {</span>
        // what to collect : numbers
<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (spansNumberData.containsKey(sq)) {</span>
<span class="fc" id="L687">          numberData = spansNumberData.get(sq);</span>
        } else {
<span class="fc" id="L689">          numberData = null;</span>
        }
        // what to collect: matches
<span class="fc bfc" id="L692" title="All 2 branches covered.">        if (spansMatchData.containsKey(sq)) {</span>
<span class="fc" id="L693">          matchData = spansMatchData.get(sq);</span>
        } else {
<span class="fc" id="L695">          matchData = null;</span>
        }
<span class="fc" id="L697">        boolean doNormalCollection = true;</span>
        // if only number is needed, possibly termvectors can be used
<span class="fc bfc" id="L699" title="All 4 branches covered.">        if ((numberData != null) &amp;&amp; (matchData == null)) {</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">          if (sq.isMatchAllPositionsQuery()) {</span>
<span class="fc" id="L701">            spansNumberByPositions.add(sq);</span>
<span class="fc" id="L702">            needPositions = true;</span>
<span class="fc" id="L703">            doNormalCollection = false;</span>
          }
        }
        // collect (if termvector collection didn't work)
<span class="pc bpc" id="L707" title="1 of 6 branches missed.">        if (doNormalCollection &amp;&amp; ((numberData != null) || (matchData != null))) {</span>
<span class="fc" id="L708">          Spans spans = spansQueryWeight.get(sq).getSpans(lrc, SpanWeight.Postings.POSITIONS);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">          if (spans != null) {</span>
            Iterator&lt;Integer&gt; it;
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">            if (docSet != null) {</span>
<span class="fc" id="L712">              it = docSet.iterator();</span>
            } else {
<span class="nc" id="L714">              it = docList.iterator();</span>
            }
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">            if (it.hasNext()) {</span>
<span class="fc" id="L717">              int docId = it.next();</span>
              int number;
              ArrayList&lt;Match&gt; matchDataList;
<span class="fc" id="L720">              Integer spansDocId = null;</span>
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">              while (docId != DocIdSetIterator.NO_MORE_DOCS) {</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">                if (spans.advance((docId - lrc.docBase)) == DocIdSetIterator.NO_MORE_DOCS) {</span>
<span class="fc" id="L723">                  break;</span>
                }
<span class="fc" id="L725">                spansDocId = spans.docID() + lrc.docBase;</span>
<span class="pc bpc" id="L726" title="1 of 4 branches missed.">                while ((docId &lt; spansDocId) &amp;&amp; it.hasNext()) {</span>
<span class="fc" id="L727">                  docId = it.next();</span>
                }
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">                if (docId &lt; spansDocId) {</span>
<span class="nc" id="L730">                  break;</span>
                }
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">                if (spansDocId.equals(docId)) {</span>
<span class="fc" id="L733">                  number = 0;</span>
<span class="fc" id="L734">                  matchDataList = new ArrayList&lt;&gt;();</span>
                  int tmpStartPosition;
<span class="fc bfc" id="L736" title="All 2 branches covered.">                  while ((tmpStartPosition = spans.nextStartPosition()) != Spans.NO_MORE_POSITIONS) {</span>
<span class="fc" id="L737">                    number++;</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">                    if (matchData != null) {</span>
<span class="fc" id="L739">                      Match m = new Match(tmpStartPosition, spans.endPosition());</span>
<span class="fc" id="L740">                      matchDataList.add(m);</span>
<span class="fc" id="L741">                    }</span>
                  }
<span class="fc bfc" id="L743" title="All 2 branches covered.">                  if ((numberData != null)) {</span>
<span class="fc" id="L744">                    numberData.put(spansDocId, number);</span>
                  }
<span class="fc bfc" id="L746" title="All 2 branches covered.">                  if ((matchData != null)) {</span>
<span class="fc" id="L747">                    matchData.put(spansDocId, matchDataList);</span>
                  }
<span class="fc bfc" id="L749" title="All 2 branches covered.">                  if (it.hasNext()) {</span>
<span class="fc" id="L750">                    docId = it.next();</span>
                  } else {
                    break;
                  }
<span class="fc" id="L754">                }</span>
              }
            }
          }
        }
<span class="fc" id="L759">      }</span>
    }

    // collect position stats
<span class="fc bfc" id="L763" title="All 2 branches covered.">    if (needPositions) {</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">      if (mtasCodecInfo != null) {</span>
        // for relatively small numbers, compute only what is needed
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if (docSet.size() &lt; Math.log(r.maxDoc())) {</span>
<span class="fc" id="L767">          positionsData = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">          for (int docId : docSet) {</span>
<span class="fc" id="L769">            positionsData.put(docId, mtasCodecInfo.getNumberOfPositions(field, (docId - lrc.docBase)));</span>
<span class="fc" id="L770">          }</span>
          // compute everything, only use what is needed
        } else {
<span class="fc" id="L773">          positionsData = mtasCodecInfo.getAllNumberOfPositions(field, lrc.docBase);</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">          for (int docId : docSet) {</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">            if (!positionsData.containsKey(docId)) {</span>
<span class="nc" id="L776">              positionsData.put(docId, 0);</span>
            }
<span class="fc" id="L778">          }</span>
        }
      } else {
<span class="nc" id="L781">        positionsData = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        for (int docId : docSet) {</span>
<span class="nc" id="L783">          positionsData.put(docId, 0);</span>
<span class="nc" id="L784">        }</span>
      }
<span class="pc bpc" id="L786" title="1 of 4 branches missed.">      if (spansNumberByPositions != null &amp;&amp; spansNumberData != null) {</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">        for (MtasSpanQuery sq : spansNumberByPositions) {</span>
<span class="fc" id="L788">          Map&lt;Integer, Integer&gt; numberData = spansNumberData.get(sq);</span>
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">          positionsData.forEach((k, v) -&gt; numberData.put(k, v != null ? v : 0));</span>
<span class="fc" id="L790">        }</span>
      }
    }

    // collect token stats
<span class="fc bfc" id="L795" title="All 2 branches covered.">    if (needTokens) {</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">      if (mtasCodecInfo != null) {</span>
        // for relatively small numbers, compute only what is needed
<span class="fc bfc" id="L798" title="All 2 branches covered.">        if (docSet.size() &lt; Math.log(r.maxDoc())) {</span>
<span class="fc" id="L799">          tokensData = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">          for (int docId : docSet) {</span>
<span class="fc" id="L801">            tokensData.put(docId, mtasCodecInfo.getNumberOfTokens(field, (docId - lrc.docBase)));</span>
<span class="fc" id="L802">          }</span>
          // compute everything, only use what is needed
        } else {
<span class="fc" id="L805">          tokensData = mtasCodecInfo.getAllNumberOfTokens(field, lrc.docBase);</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">          for (int docId : docSet) {</span>
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">            if (!tokensData.containsKey(docId)) {</span>
<span class="nc" id="L808">              tokensData.put(docId, 0);</span>
            }
<span class="fc" id="L810">          }</span>
        }
      } else {
<span class="nc" id="L813">        tokensData = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        for (int docId : docSet) {</span>
<span class="nc" id="L815">          tokensData.put(docId, 0);</span>
<span class="nc" id="L816">        }</span>
      }
    }

<span class="fc bfc" id="L820" title="All 2 branches covered.">    if (!fieldInfo.statsPositionList.isEmpty()) {</span>
      // create positions
<span class="fc" id="L822">      createPositions(fieldInfo.statsPositionList, positionsData, docSet);</span>
    }
<span class="fc bfc" id="L824" title="All 2 branches covered.">    if (!fieldInfo.statsTokenList.isEmpty()) {</span>
      // create positions
<span class="fc" id="L826">      createTokens(fieldInfo.statsTokenList, tokensData, docSet);</span>
    }
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">    if (!fieldInfo.pageList.isEmpty()) {</span>
      // create pages
<span class="nc" id="L830">      createPages(fieldInfo.pageList, docList, fieldInfos.fieldInfo(field), field, lrc.docBase,</span>
          fieldInfo.uniqueKeyField, mtasCodecInfo, searcher);
    }
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">    if (!fieldInfo.documentList.isEmpty()) {</span>
      // create document
<span class="nc" id="L835">      createDocument(fieldInfo.documentList, docList, fieldInfo.uniqueKeyField, searcher, t, lrc);</span>
    }
<span class="fc bfc" id="L837" title="All 2 branches covered.">    if (!fieldInfo.spanQueryList.isEmpty()) {</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">      if (!fieldInfo.statsSpanList.isEmpty()) {</span>
        // create stats
<span class="fc" id="L840">        createStats(fieldInfo.statsSpanList, positionsData, spansNumberData,</span>
<span class="fc" id="L841">            docSet.toArray(new Integer[docSet.size()]));</span>
      }
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">      if (!fieldInfo.listList.isEmpty()) {</span>
        // create list
<span class="nc" id="L845">        createList(fieldInfo.listList, spansNumberData, spansMatchData, docSet, field, lrc.docBase,</span>
            fieldInfo.uniqueKeyField, mtasCodecInfo, searcher);
      }
<span class="fc bfc" id="L848" title="All 2 branches covered.">      if (!fieldInfo.groupList.isEmpty()) {</span>
        // create group
<span class="fc" id="L850">        createGroup(fieldInfo.groupList, spansMatchData, docSet, fieldInfos.fieldInfo(field), field, lrc.docBase,</span>
            mtasCodecInfo, searcher, lrc, status);
      }
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">      if (!fieldInfo.kwicList.isEmpty()) {</span>
        // create kwic
<span class="nc" id="L855">        createKwic(fieldInfo.kwicList, spansMatchData, docList, field, lrc.docBase, fieldInfo.uniqueKeyField,</span>
            mtasCodecInfo, searcher);
      }
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">      if (!fieldInfo.facetList.isEmpty()) {</span>
        // create facets
<span class="nc" id="L860">        createFacet(fieldInfo.facetList, positionsData, spansNumberData, facetData, docSet);</span>
      }
<span class="fc bfc" id="L862" title="All 2 branches covered.">      if (!fieldInfo.heatmapList.isEmpty()) {</span>
        // create heatmaps
<span class="fc" id="L864">        createHeatmaps(fieldInfo.heatmapList, positionsData, spansNumberData,</span>
            docSet, r, lrc);
      }
    }
<span class="fc bfc" id="L868" title="All 2 branches covered.">    if (!fieldInfo.termVectorList.isEmpty()) {</span>
<span class="fc" id="L869">      createTermvectorFull(fieldInfo.termVectorList, positionsData, docSet, t, r, lrc);</span>
<span class="fc" id="L870">      createTermvectorFirstRound(fieldInfo.termVectorList, positionsData, docSet, t, r, lrc);</span>
    }
<span class="fc" id="L872">  }</span>

  /**
   * Collect known prefixes.
   *
   * @param fi
   *          the fi
   * @return the sets the
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static Set&lt;String&gt; collectKnownPrefixes(FieldInfo fi) throws IOException {
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">    if (fi != null) {</span>
<span class="fc" id="L885">      HashSet&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc" id="L886">      String singlePositionPrefixes = fi</span>
<span class="fc" id="L887">          .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SINGLE_POSITION);</span>
<span class="fc" id="L888">      String multiplePositionPrefixes = fi</span>
<span class="fc" id="L889">          .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_MULTIPLE_POSITION);</span>
<span class="fc" id="L890">      String setPositionPrefixes = fi</span>
<span class="fc" id="L891">          .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SET_POSITION);</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">      if (singlePositionPrefixes != null) {</span>
<span class="fc" id="L893">        String[] prefixes = singlePositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">        for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L895">          String item = prefixes[i].trim();</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">          if (!item.equals(&quot;&quot;)) {</span>
<span class="fc" id="L897">            result.add(item);</span>
          }
        }
      }
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">      if (multiplePositionPrefixes != null) {</span>
<span class="fc" id="L902">        String[] prefixes = multiplePositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">        for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L904">          String item = prefixes[i].trim();</span>
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">          if (!item.equals(&quot;&quot;)) {</span>
<span class="fc" id="L906">            result.add(item);</span>
          }
        }
      }
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">      if (setPositionPrefixes != null) {</span>
<span class="fc" id="L911">        String[] prefixes = setPositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">        for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L913">          String item = prefixes[i].trim();</span>
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">          if (!item.equals(&quot;&quot;)) {</span>
<span class="fc" id="L915">            result.add(item);</span>
          }
        }
      }
<span class="fc" id="L919">      return result;</span>
    } else {
<span class="nc" id="L921">      return Collections.emptySet();</span>
    }
  }

  /**
   * Collect intersection prefixes.
   *
   * @param fi
   *          the fi
   * @return the sets the
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static Set&lt;String&gt; collectIntersectionPrefixes(FieldInfo fi) throws IOException {
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">    if (fi != null) {</span>
<span class="fc" id="L936">      Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc" id="L937">      String intersectingPrefixes = fi</span>
<span class="fc" id="L938">          .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_INTERSECTION);</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">      if (intersectingPrefixes != null) {</span>
<span class="fc" id="L940">        String[] prefixes = intersectingPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">        for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L942">          String item = prefixes[i].trim();</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">          if (!item.equals(&quot;&quot;)) {</span>
<span class="fc" id="L944">            result.add(item);</span>
          }
        }
      }
<span class="fc" id="L948">      return result;</span>
    } else {
<span class="nc" id="L950">      return Collections.emptySet();</span>
    }
  }

  /**
   * Collect prefixes.
   *
   * @param fieldInfos
   *          the field infos
   * @param field
   *          the field
   * @param fieldInfo
   *          the field info
   * @param status
   *          the status
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void collectPrefixes(FieldInfos fieldInfos, String field, ComponentField fieldInfo, Status status)
      throws IOException {
<span class="fc bfc" id="L970" title="All 2 branches covered.">    if (fieldInfo.prefix != null) {</span>
<span class="fc" id="L971">      FieldInfo fi = fieldInfos.fieldInfo(field);</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">      if (fi != null) {</span>
<span class="fc" id="L973">        String singlePositionPrefixes = fi</span>
<span class="fc" id="L974">            .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SINGLE_POSITION);</span>
<span class="fc" id="L975">        String multiplePositionPrefixes = fi</span>
<span class="fc" id="L976">            .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_MULTIPLE_POSITION);</span>
<span class="fc" id="L977">        String setPositionPrefixes = fi</span>
<span class="fc" id="L978">            .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SET_POSITION);</span>
<span class="fc" id="L979">        String intersectingPrefixes = fi</span>
<span class="fc" id="L980">            .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_INTERSECTION);</span>
<span class="pc bpc" id="L981" title="1 of 2 branches missed.">        if (singlePositionPrefixes != null) {</span>
<span class="fc" id="L982">          String[] prefixes = singlePositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">          for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L984">            fieldInfo.prefix.addSinglePosition(prefixes[i]);</span>
          }
        }
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">        if (multiplePositionPrefixes != null) {</span>
<span class="fc" id="L988">          String[] prefixes = multiplePositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">          for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L990">            fieldInfo.prefix.addMultiplePosition(prefixes[i]);</span>
          }
        }
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">        if (setPositionPrefixes != null) {</span>
<span class="fc" id="L994">          String[] prefixes = setPositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">          for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L996">            fieldInfo.prefix.addSetPosition(prefixes[i]);</span>
          }
        }
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">        if (intersectingPrefixes != null) {</span>
<span class="fc" id="L1000">          String[] prefixes = intersectingPrefixes.split(Pattern.quote(MtasToken.DELIMITER));</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">          for (int i = 0; i &lt; prefixes.length; i++) {</span>
<span class="fc" id="L1002">            fieldInfo.prefix.addIntersecting(prefixes[i]);</span>
          }
        }
      }
    }
<span class="fc" id="L1007">  }</span>

  /**
   * Collect spans for occurences.
   *
   * @param occurences
   *          the occurences
   * @param prefixes
   *          the prefixes
   * @param field
   *          the field
   * @param searcher
   *          the searcher
   * @param lrc
   *          the lrc
   * @return the map
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static Map&lt;GroupHit, Spans&gt; collectSpansForOccurences(Set&lt;GroupHit&gt; occurences, Set&lt;String&gt; prefixes,
      String field, IndexSearcher searcher, LeafReaderContext lrc) throws IOException {
<span class="nc" id="L1028">    Map&lt;GroupHit, Spans&gt; list = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1029">    IndexReader reader = searcher.getIndexReader();</span>
<span class="nc" id="L1030">    final float boost = 0;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">    for (GroupHit hit : occurences) {</span>
<span class="nc" id="L1032">      MtasSpanQuery queryHit = createQueryFromGroupHit(prefixes, field, hit);</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">      if (queryHit != null) {</span>
<span class="nc" id="L1034">        MtasSpanQuery queryHitRewritten = queryHit.rewrite(reader);</span>
<span class="nc" id="L1035">        SpanWeight weight = queryHitRewritten.createWeight(searcher, false, boost);</span>
<span class="nc" id="L1036">        Spans spans = weight.getSpans(lrc, SpanWeight.Postings.POSITIONS);</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (spans != null) {</span>
<span class="nc" id="L1038">          list.put(hit, spans);</span>
        }
      }
<span class="nc" id="L1041">    }</span>
<span class="nc" id="L1042">    return list;</span>
  }

  /**
   * Creates the query from group hit.
   *
   * @param prefixes
   *          the prefixes
   * @param field
   *          the field
   * @param hit
   *          the hit
   * @return the mtas span query
   */
  private static MtasSpanQuery createQueryFromGroupHit(Set&lt;String&gt; prefixes, String field, GroupHit hit) {
    // initial check
<span class="nc bnc" id="L1058" title="All 6 branches missed.">    if (prefixes == null || field == null || hit == null) {</span>
<span class="nc" id="L1059">      return null;</span>
    } else {
<span class="nc" id="L1061">      MtasSpanQuery query = null;</span>
      // check for missing
<span class="nc bnc" id="L1063" title="All 4 branches missed.">      if (hit.missingLeft != null &amp;&amp; hit.missingLeft.length &gt; 0) {</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        for (int i = 0; i &lt; hit.missingLeft.length; i++) {</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">          if (hit.missingLeft[i].size() != hit.unknownLeft[i].size()) {</span>
<span class="nc" id="L1066">            return null;</span>
          }
        }
      }
<span class="nc bnc" id="L1070" title="All 4 branches missed.">      if (hit.missingHit != null &amp;&amp; hit.missingHit.length &gt; 0) {</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        for (int i = 0; i &lt; hit.missingHit.length; i++) {</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">          if (hit.missingHit[i].size() != hit.unknownHit[i].size()) {</span>
<span class="nc" id="L1073">            return null;</span>
          }
        }
      }
<span class="nc bnc" id="L1077" title="All 4 branches missed.">      if (hit.missingRight != null &amp;&amp; hit.missingRight.length &gt; 0) {</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">        for (int i = 0; i &lt; hit.missingRight.length; i++) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">          if (hit.missingRight[i].size() != hit.unknownRight[i].size()) {</span>
<span class="nc" id="L1080">            return null;</span>
          }
        }
      }
<span class="nc" id="L1084">      MtasSpanQuery hitQuery = createSubQueryFromGroupHit(hit.dataHit, false, field);</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">      if (hitQuery != null) {</span>
<span class="nc" id="L1086">        query = hitQuery;</span>
<span class="nc" id="L1087">        MtasSpanQuery leftHitQuery = createSubQueryFromGroupHit(hit.dataLeft, true, field);</span>
<span class="nc" id="L1088">        MtasSpanQuery rightHitQuery = createSubQueryFromGroupHit(hit.dataRight, false, field);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (leftHitQuery != null) {</span>
<span class="nc" id="L1090">          query = new MtasSpanPrecededByQuery(query, leftHitQuery);</span>
        }
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (rightHitQuery != null) {</span>
<span class="nc" id="L1093">          query = new MtasSpanFollowedByQuery(query, rightHitQuery);</span>
        }
      }
<span class="nc" id="L1096">      return query;</span>
    }
  }

  /**
   * Creates the sub query from group hit.
   *
   * @param subHit
   *          the sub hit
   * @param reverse
   *          the reverse
   * @param field
   *          the field
   * @return the mtas span query
   */
  private static MtasSpanQuery createSubQueryFromGroupHit(List&lt;String&gt;[] subHit, boolean reverse, String field) {
<span class="nc" id="L1112">    MtasSpanQuery query = null;</span>
<span class="nc bnc" id="L1113" title="All 4 branches missed.">    if (subHit != null &amp;&amp; subHit.length &gt; 0) {</span>
<span class="nc" id="L1114">      List&lt;MtasSpanSequenceItem&gt; items = new ArrayList&lt;&gt;();</span>
      List&lt;String&gt; subHitItem;
<span class="nc bnc" id="L1116" title="All 2 branches missed.">      for (int i = 0; i &lt; subHit.length; i++) {</span>
<span class="nc" id="L1117">        MtasSpanQuery item = null;</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (reverse) {</span>
<span class="nc" id="L1119">          subHitItem = subHit[(subHit.length - i - 1)];</span>
        } else {
<span class="nc" id="L1121">          subHitItem = subHit[i];</span>
        }
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (subHitItem.isEmpty()) {</span>
<span class="nc" id="L1124">          item = new MtasSpanMatchAllQuery(field);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        } else if (subHitItem.size() == 1) {</span>
<span class="nc" id="L1126">          Term term = new Term(field, subHitItem.get(0));</span>
<span class="nc" id="L1127">          item = new MtasSpanTermQuery(term);</span>
<span class="nc" id="L1128">        } else {</span>
<span class="nc" id="L1129">          MtasSpanQuery[] subList = new MtasSpanQuery[subHitItem.size()];</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">          for (int j = 0; j &lt; subHitItem.size(); j++) {</span>
<span class="nc" id="L1131">            Term term = new Term(field, subHitItem.get(j));</span>
<span class="nc" id="L1132">            subList[j] = new MtasSpanTermQuery(term);</span>
          }
<span class="nc" id="L1134">          item = new MtasSpanAndQuery(subList);</span>
        }
<span class="nc" id="L1136">        items.add(new MtasSpanSequenceItem(item, false));</span>
      }
<span class="nc" id="L1138">      query = new MtasSpanSequenceQuery(items, null, null);</span>
    }
<span class="nc" id="L1140">    return query;</span>
  }

  /**
   * Compute positions.
   *
   * @param mtasCodecInfo
   *          the mtas codec info
   * @param r
   *          the r
   * @param lrc
   *          the lrc
   * @param field
   *          the field
   * @param docSet
   *          the doc set
   * @return the map
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static Map&lt;Integer, Integer&gt; computePositions(CodecInfo mtasCodecInfo, LeafReader r, LeafReaderContext lrc,
      String field, List&lt;Integer&gt; docSet) throws IOException {
    HashMap&lt;Integer, Integer&gt; positionsData;
<span class="nc bnc" id="L1163" title="All 2 branches missed.">    if (mtasCodecInfo != null) {</span>
      // for relatively small numbers, compute only what is needed
<span class="nc bnc" id="L1165" title="All 2 branches missed.">      if (docSet.size() &lt; Math.log(r.maxDoc())) {</span>
<span class="nc" id="L1166">        positionsData = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        for (int docId : docSet) {</span>
<span class="nc" id="L1168">          positionsData.put(docId, mtasCodecInfo.getNumberOfPositions(field, (docId - lrc.docBase)));</span>
<span class="nc" id="L1169">        }</span>
        // compute everything, only use what is needed
      } else {
<span class="nc" id="L1172">        positionsData = mtasCodecInfo.getAllNumberOfPositions(field, lrc.docBase);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">        for (int docId : docSet) {</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">          if (!positionsData.containsKey(docId)) {</span>
<span class="nc" id="L1175">            positionsData.put(docId, 0);</span>
          }
<span class="nc" id="L1177">        }</span>
      }
    } else {
<span class="nc" id="L1180">      positionsData = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">      for (int docId : docSet) {</span>
<span class="nc" id="L1182">        positionsData.put(docId, 0);</span>
<span class="nc" id="L1183">      }</span>
    }
<span class="nc" id="L1185">    return positionsData;</span>
  }

  /**
   * Compute arguments.
   *
   * @param spansNumberData
   *          the spans number data
   * @param queries
   *          the queries
   * @param docSet
   *          the doc set
   * @return the map
   */
  private static Map&lt;Integer, long[]&gt; computeArguments(Map&lt;MtasSpanQuery, Map&lt;Integer, Integer&gt;&gt; spansNumberData,
      MtasSpanQuery[] queries, Integer[] docSet) {
<span class="fc" id="L1201">    Map&lt;Integer, long[]&gt; args = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">    for (int q = 0; q &lt; queries.length; q++) {</span>
<span class="fc" id="L1203">      Map&lt;Integer, Integer&gt; tmpData = spansNumberData.get(queries[q]);</span>
<span class="fc" id="L1204">      long[] tmpList = null;</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">      for (int docId : docSet) {</span>
<span class="pc bpc" id="L1206" title="1 of 4 branches missed.">        if (tmpData != null &amp;&amp; tmpData.containsKey(docId)) {</span>
<span class="fc bfc" id="L1207" title="All 2 branches covered.">          if (!args.containsKey(docId)) {</span>
<span class="fc" id="L1208">            tmpList = new long[queries.length];</span>
          } else {
<span class="fc" id="L1210">            tmpList = args.get(docId);</span>
          }
<span class="fc" id="L1212">          tmpList[q] = tmpData.get(docId);</span>
<span class="fc" id="L1213">          args.put(docId, tmpList);</span>
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">        } else if (!args.containsKey(docId)) {</span>
<span class="fc" id="L1215">          tmpList = new long[queries.length];</span>
<span class="fc" id="L1216">          args.put(docId, tmpList);</span>
        }
      }
    }
<span class="fc" id="L1220">    return args;</span>
  }

  /**
   * Intersected doc list.
   *
   * @param facetDocList
   *          the facet doc list
   * @param docSet
   *          the doc set
   * @return the integer[]
   */
  private static Integer[] intersectedDocList(int[] facetDocList, Integer[] docSet) {
<span class="nc bnc" id="L1233" title="All 4 branches missed.">    if (facetDocList != null &amp;&amp; docSet != null) {</span>
<span class="nc" id="L1234">      Integer[] c = new Integer[Math.min(facetDocList.length, docSet.length)];</span>
<span class="nc" id="L1235">      int ai = 0;</span>
<span class="nc" id="L1236">      int bi = 0;</span>
<span class="nc" id="L1237">      int ci = 0;</span>
<span class="nc bnc" id="L1238" title="All 4 branches missed.">      while (ai &lt; facetDocList.length &amp;&amp; bi &lt; docSet.length) {</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">        if (facetDocList[ai] &lt; docSet[bi]) {</span>
<span class="nc" id="L1240">          ai++;</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        } else if (facetDocList[ai] &gt; docSet[bi]) {</span>
<span class="nc" id="L1242">          bi++;</span>
        } else {
<span class="nc bnc" id="L1244" title="All 4 branches missed.">          if (ci == 0 || facetDocList[ai] != c[ci - 1]) {</span>
<span class="nc" id="L1245">            c[ci++] = facetDocList[ai];</span>
          }
<span class="nc" id="L1247">          ai++;</span>
<span class="nc" id="L1248">          bi++;</span>
        }
      }
<span class="nc" id="L1251">      return Arrays.copyOfRange(c, 0, ci);</span>
    }
<span class="nc" id="L1253">    return new Integer[] {};</span>
  }

  /**
   * Creates the positions.
   *
   * @param statsPositionList
   *          the stats position list
   * @param positionsData
   *          the positions data
   * @param docSet
   *          the doc set
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createPositions(List&lt;ComponentPosition&gt; statsPositionList, Map&lt;Integer, Integer&gt; positionsData,
      List&lt;Integer&gt; docSet) throws IOException {
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">    if (statsPositionList != null) {</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">      for (ComponentPosition position : statsPositionList) {</span>
<span class="fc" id="L1272">        position.dataCollector.initNewList(1);</span>
        Integer tmpValue;
<span class="fc" id="L1274">        long[] values = new long[docSet.size()];</span>
        int value;
<span class="fc" id="L1276">        int number = 0;</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        for (int docId : docSet) {</span>
<span class="fc" id="L1278">          tmpValue = positionsData.get(docId);</span>
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">          value = tmpValue == null ? 0 : tmpValue.intValue();</span>
<span class="fc bfc" id="L1280" title="All 6 branches covered.">          if (((position.minimumLong == null) || (value &gt;= position.minimumLong))</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">              &amp;&amp; ((position.maximumLong == null) || (value &lt;= position.maximumLong))) {</span>
<span class="fc" id="L1282">            values[number] = value;</span>
<span class="fc" id="L1283">            number++;</span>
          }
<span class="fc" id="L1285">        }</span>
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">        if (number &gt; 0) {</span>
<span class="fc" id="L1287">          position.dataCollector.add(values, number);</span>
        }
<span class="fc" id="L1289">        position.dataCollector.closeNewList();</span>
<span class="fc" id="L1290">      }</span>
    }
<span class="fc" id="L1292">  }</span>

  /**
   * Creates the tokens.
   *
   * @param statsTokenList
   *          the stats token list
   * @param tokensData
   *          the tokens data
   * @param docSet
   *          the doc set
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createTokens(List&lt;ComponentToken&gt; statsTokenList, Map&lt;Integer, Integer&gt; tokensData,
      List&lt;Integer&gt; docSet) throws IOException {
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">    if (statsTokenList != null) {</span>
<span class="fc bfc" id="L1309" title="All 2 branches covered.">      for (ComponentToken token : statsTokenList) {</span>
<span class="fc" id="L1310">        token.dataCollector.initNewList(1);</span>
        Integer tmpValue;
<span class="fc" id="L1312">        long[] values = new long[docSet.size()];</span>
        int value;
<span class="fc" id="L1314">        int number = 0;</span>
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">        if (tokensData != null) {</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">          for (int docId : docSet) {</span>
<span class="fc" id="L1317">            tmpValue = tokensData.get(docId);</span>
<span class="pc bpc" id="L1318" title="1 of 2 branches missed.">            value = tmpValue == null ? 0 : tmpValue.intValue();</span>
<span class="pc bpc" id="L1319" title="1 of 6 branches missed.">            if (((token.minimumLong == null) || (value &gt;= token.minimumLong))</span>
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">                &amp;&amp; ((token.maximumLong == null) || (value &lt;= token.maximumLong))) {</span>
<span class="fc" id="L1321">              values[number] = value;</span>
<span class="fc" id="L1322">              number++;</span>
            }
<span class="fc" id="L1324">          }</span>
        }
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">        if (number &gt; 0) {</span>
<span class="fc" id="L1327">          token.dataCollector.add(values, number);</span>
        }
<span class="fc" id="L1329">        token.dataCollector.closeNewList();</span>
<span class="fc" id="L1330">      }</span>
    }
<span class="fc" id="L1332">  }</span>

  /**
   * Creates the stats.
   *
   * @param statsSpanList
   *          the stats span list
   * @param positionsData
   *          the positions data
   * @param spansNumberData
   *          the spans number data
   * @param docSet
   *          the doc set
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createStats(List&lt;ComponentSpan&gt; statsSpanList, Map&lt;Integer, Integer&gt; positionsData,
      Map&lt;MtasSpanQuery, Map&lt;Integer, Integer&gt;&gt; spansNumberData, Integer[] docSet) throws IOException {
<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">    if (statsSpanList != null) {</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">      for (ComponentSpan span : statsSpanList) {</span>
<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">        if (span.parser.needArgumentsNumber() &gt; span.queries.length) {</span>
<span class="nc" id="L1353">          throw new IOException(</span>
<span class="nc" id="L1354">              &quot;function &quot; + span.parser + &quot; expects (at least) &quot; + span.parser.needArgumentsNumber() + &quot; queries&quot;);</span>
        }
        // collect
<span class="fc" id="L1357">        Map&lt;Integer, long[]&gt; args = computeArguments(spansNumberData, span.queries, docSet);</span>
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">        if (span.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
          // try to call functionParser as little as possible
<span class="pc bpc" id="L1360" title="1 of 8 branches missed.">          if (span.statsType.equals(CodecUtil.STATS_BASIC) &amp;&amp; (span.minimumLong == null) &amp;&amp; (span.maximumLong == null)</span>
              &amp;&amp; (span.functions == null
<span class="pc bpc" id="L1362" title="3 of 6 branches missed.">                  || (span.functionBasic() &amp;&amp; span.functionSumRule() &amp;&amp; !span.functionNeedPositions()))) {</span>
            // initialise
<span class="fc" id="L1364">            int length = span.parser.needArgumentsNumber();</span>
<span class="fc" id="L1365">            long[] valueSum = new long[length];</span>
<span class="fc" id="L1366">            long valuePositions = 0;</span>
            // collect
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">            if (docSet.length &gt; 0) {</span>
              long[] tmpArgs;
<span class="fc bfc" id="L1370" title="All 2 branches covered.">              for (int docId : docSet) {</span>
<span class="fc" id="L1371">                tmpArgs = args.get(docId);</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                valuePositions += (positionsData == null) ? 0 : positionsData.get(docId);</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">                if (tmpArgs != null) {</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">                  for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L1375">                    valueSum[i] += tmpArgs[i];</span>
                  }
                }
              }
              long valueLong;
<span class="fc" id="L1380">              span.dataCollector.initNewList(1);</span>
              try {
<span class="fc" id="L1382">                valueLong = span.parser.getValueLong(valueSum, valuePositions);</span>
<span class="fc" id="L1383">                span.dataCollector.add(valueLong, docSet.length);</span>
<span class="nc" id="L1384">              } catch (IOException e) {</span>
<span class="nc" id="L1385">                log.debug(e);</span>
<span class="nc" id="L1386">                span.dataCollector.error(e.getMessage(), 1);</span>
<span class="fc" id="L1387">              }</span>
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">              if (span.functions != null) {</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">                for (SubComponentFunction function : span.functions) {</span>
<span class="fc" id="L1390">                  function.dataCollector.initNewList(1);</span>
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">                  if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
                    try {
<span class="fc" id="L1393">                      valueLong = function.parserFunction.getValueLong(valueSum, valuePositions);</span>
<span class="fc" id="L1394">                      function.dataCollector.add(valueLong, docSet.length);</span>
<span class="nc" id="L1395">                    } catch (IOException e) {</span>
<span class="nc" id="L1396">                      log.debug(e);</span>
<span class="nc" id="L1397">                      function.dataCollector.error(e.getMessage(), 1);</span>
<span class="pc" id="L1398">                    }</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">                  } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
                    try {
<span class="nc" id="L1401">                      double valueDouble = function.parserFunction.getValueDouble(valueSum, valuePositions);</span>
<span class="nc" id="L1402">                      function.dataCollector.add(valueDouble, docSet.length);</span>
<span class="nc" id="L1403">                    } catch (IOException e) {</span>
<span class="nc" id="L1404">                      log.debug(e);</span>
<span class="nc" id="L1405">                      function.dataCollector.error(e.getMessage(), 1);</span>
<span class="nc" id="L1406">                    }</span>
                  } else {
<span class="nc" id="L1408">                    throw new IOException(&quot;can't handle function dataType &quot; + function.dataType);</span>
                  }
<span class="fc" id="L1410">                  function.dataCollector.closeNewList();</span>
<span class="fc" id="L1411">                }</span>
              }
<span class="fc" id="L1413">              span.dataCollector.closeNewList();</span>
            }
<span class="fc" id="L1415">          } else {</span>
            // collect
<span class="pc bpc" id="L1417" title="1 of 2 branches missed.">            if (docSet.length &gt; 0) {</span>
<span class="fc" id="L1418">              int number = 0;</span>
              int positions;
              long valueLong;
              double valueDouble;
<span class="fc" id="L1422">              long[] values = new long[docSet.length];</span>
<span class="fc" id="L1423">              long[][] functionValuesLong = null;</span>
<span class="fc" id="L1424">              double[][] functionValuesDouble = null;</span>
<span class="fc" id="L1425">              span.dataCollector.initNewList(1);</span>
<span class="pc bpc" id="L1426" title="1 of 2 branches missed.">              if (span.functions != null) {</span>
<span class="fc" id="L1427">                functionValuesLong = new long[span.functions.size()][];</span>
<span class="fc" id="L1428">                functionValuesDouble = new double[span.functions.size()][];</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">                for (int i = 0; i &lt; span.functions.size(); i++) {</span>
<span class="fc" id="L1430">                  SubComponentFunction function = span.functions.get(i);</span>
<span class="pc bpc" id="L1431" title="1 of 2 branches missed.">                  if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="fc" id="L1432">                    functionValuesLong[i] = new long[docSet.length];</span>
<span class="fc" id="L1433">                    functionValuesDouble[i] = null;</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                  } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L1435">                    functionValuesLong[i] = null;</span>
<span class="nc" id="L1436">                    functionValuesDouble[i] = new double[docSet.length];</span>
                  }
<span class="fc" id="L1438">                  function.dataCollector.initNewList(1);</span>
                }
              }
<span class="fc bfc" id="L1441" title="All 2 branches covered.">              for (int docId : docSet) {</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">                if (positionsData == null) {</span>
<span class="fc" id="L1443">                  positions = 0;</span>
                } else {
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">                  positions = (positionsData.get(docId) == null ? 0 : positionsData.get(docId));</span>
                }
<span class="fc" id="L1447">                valueLong = span.parser.getValueLong(args.get(docId), positions);</span>
<span class="fc bfc" id="L1448" title="All 6 branches covered.">                if (((span.minimumLong == null) || (valueLong &gt;= span.minimumLong))</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">                    &amp;&amp; ((span.maximumLong == null) || (valueLong &lt;= span.maximumLong))) {</span>
<span class="fc" id="L1450">                  values[number] = valueLong;</span>
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">                  if (span.functions != null) {</span>
<span class="fc bfc" id="L1452" title="All 2 branches covered.">                    for (int i = 0; i &lt; span.functions.size(); i++) {</span>
<span class="fc" id="L1453">                      SubComponentFunction function = span.functions.get(i);</span>
                      try {
<span class="pc bpc" id="L1455" title="1 of 2 branches missed.">                        if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="fc" id="L1456">                          valueLong = function.parserFunction.getValueLong(args.get(docId), positions);</span>
<span class="fc" id="L1457">                          functionValuesLong[i][number] = valueLong;</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">                        } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L1459">                          valueDouble = function.parserFunction.getValueDouble(args.get(docId), positions);</span>
<span class="nc" id="L1460">                          functionValuesDouble[i][number] = valueDouble;</span>
                        }
<span class="nc" id="L1462">                      } catch (IOException e) {</span>
<span class="nc" id="L1463">                        log.debug(e);</span>
<span class="nc" id="L1464">                        function.dataCollector.error(e.getMessage(), 1);</span>
<span class="fc" id="L1465">                      }</span>
                    }
                  }
<span class="fc" id="L1468">                  number++;</span>
                }
              }
<span class="fc bfc" id="L1471" title="All 2 branches covered.">              if (number &gt; 0) {</span>
<span class="fc" id="L1472">                span.dataCollector.add(values, number);</span>
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">                if (span.functions != null) {</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">                  for (int i = 0; i &lt; span.functions.size(); i++) {</span>
<span class="fc" id="L1475">                    SubComponentFunction function = span.functions.get(i);</span>
<span class="pc bpc" id="L1476" title="1 of 2 branches missed.">                    if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="fc" id="L1477">                      function.dataCollector.add(functionValuesLong[i], number);</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                    } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L1479">                      function.dataCollector.add(functionValuesDouble[i], number);</span>
                    }
                  }
                }
              }
<span class="fc" id="L1484">              span.dataCollector.closeNewList();</span>
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">              if (span.functions != null) {</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">                for (SubComponentFunction function : span.functions) {</span>
<span class="fc" id="L1487">                  function.dataCollector.closeNewList();</span>
<span class="fc" id="L1488">                }</span>
              }
<span class="fc" id="L1490">            }</span>
          }
        } else {
<span class="nc" id="L1493">          throw new IOException(&quot;unexpected dataType &quot; + span.dataType);</span>
        }
<span class="fc" id="L1495">      }</span>
    }
<span class="fc" id="L1497">  }</span>

  /**
   * Creates the list.
   *
   * @param listList
   *          the list list
   * @param spansNumberData
   *          the spans number data
   * @param spansMatchData
   *          the spans match data
   * @param docSet
   *          the doc set
   * @param field
   *          the field
   * @param docBase
   *          the doc base
   * @param uniqueKeyField
   *          the unique key field
   * @param mtasCodecInfo
   *          the mtas codec info
   * @param searcher
   *          the searcher
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createList(List&lt;ComponentList&gt; listList,
      Map&lt;MtasSpanQuery, Map&lt;Integer, Integer&gt;&gt; spansNumberData,
      Map&lt;MtasSpanQuery, Map&lt;Integer, List&lt;Match&gt;&gt;&gt; spansMatchData, List&lt;Integer&gt; docSet, String field, int docBase,
      String uniqueKeyField, CodecInfo mtasCodecInfo, IndexSearcher searcher) throws IOException {
<span class="nc bnc" id="L1527" title="All 2 branches missed.">    if (listList != null) {</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">      for (ComponentList list : listList) {</span>
        // collect not only stats
<span class="nc bnc" id="L1530" title="All 2 branches missed.">        if (list.number &gt; 0) {</span>
<span class="nc" id="L1531">          Map&lt;Integer, List&lt;Match&gt;&gt; matchData = spansMatchData.get(list.spanQuery);</span>
<span class="nc" id="L1532">          Map&lt;Integer, Integer&gt; numberData = spansNumberData.get(list.spanQuery);</span>
          List&lt;Match&gt; matchList;
          Integer matchNumber;
<span class="nc bnc" id="L1535" title="All 2 branches missed.">          if (list.output.equals(ComponentList.LIST_OUTPUT_HIT)) {</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">            for (int docId : docSet) {</span>
<span class="nc bnc" id="L1537" title="All 4 branches missed.">              if (matchData != null &amp;&amp; (matchList = matchData.get(docId)) != null) {</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">                if (list.position &lt; (list.start + list.number)) {</span>
<span class="nc" id="L1539">                  boolean getDoc = false;</span>
                  Match m;
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                  for (int i = 0; i &lt; matchList.size(); i++) {</span>
<span class="nc bnc" id="L1542" title="All 4 branches missed.">                    if ((list.position &gt;= list.start) &amp;&amp; (list.position &lt; (list.start + list.number))) {</span>
<span class="nc" id="L1543">                      m = matchList.get(i);</span>
<span class="nc" id="L1544">                      getDoc = true;</span>
<span class="nc" id="L1545">                      int startPosition = m.startPosition;</span>
<span class="nc" id="L1546">                      int endPosition = m.endPosition - 1;</span>
<span class="nc" id="L1547">                      List&lt;MtasTreeHit&lt;String&gt;&gt; terms = mtasCodecInfo.getPositionedTermsByPrefixesAndPositionRange(</span>
                          field, (docId - docBase), list.prefixes, startPosition - list.left, endPosition + list.right);
                      // construct hit
<span class="nc" id="L1550">                      Map&lt;Integer, List&lt;String&gt;&gt; kwicListHits = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                      for (int position = Math.max(0, startPosition - list.left); position &lt;= (endPosition</span>
<span class="nc" id="L1552">                          + list.right); position++) {</span>
<span class="nc" id="L1553">                        kwicListHits.put(position, new ArrayList&lt;String&gt;());</span>
                      }
                      List&lt;String&gt; termList;
<span class="nc bnc" id="L1556" title="All 2 branches missed.">                      for (MtasTreeHit&lt;String&gt; term : terms) {</span>
<span class="nc" id="L1557">                        for (int position = Math.max((startPosition - list.left), term.startPosition); position &lt;= Math</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">                            .min((endPosition + list.right), term.endPosition); position++) {</span>
<span class="nc" id="L1559">                          termList = kwicListHits.get(position);</span>
<span class="nc" id="L1560">                          termList.add(term.data);</span>
                        }
<span class="nc" id="L1562">                      }</span>
<span class="nc" id="L1563">                      list.hits.add(new ListHit(docId, i, m, kwicListHits));</span>
                    }
<span class="nc" id="L1565">                    list.position++;</span>
                  }
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                  if (getDoc) {</span>
                    // get unique id
<span class="nc" id="L1569">                    Document doc = searcher.doc(docId, new HashSet&lt;String&gt;(Arrays.asList(uniqueKeyField)));</span>
<span class="nc" id="L1570">                    IndexableField indxfld = doc.getField(uniqueKeyField);</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">                    if (indxfld != null) {</span>
<span class="nc" id="L1572">                      list.uniqueKey.put(docId, indxfld.stringValue());</span>
                    }
                    // get additional fields
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                    if (!list.fieldNames.isEmpty()) {</span>
                      Map&lt;String, Object&gt; docFieldValues;
<span class="nc bnc" id="L1577" title="All 2 branches missed.">                      if (list.fieldValues.containsKey(docId)) {</span>
<span class="nc" id="L1578">                        docFieldValues = list.fieldValues.get(docId);</span>
                      } else {
<span class="nc" id="L1580">                        docFieldValues = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1581">                        list.fieldValues.put(docId, docFieldValues);</span>
                      }
                      IndexableField[] indxflds;
                      Object fieldValue;
                      List&lt;Object&gt; fieldValues;
                      String finalFieldName, indexFieldName;
<span class="nc" id="L1587">                      Pattern patternAlias = Pattern.compile(&quot;^([^:]+):([^:]+)$&quot;);</span>
                      Matcher matcherAlias;
<span class="nc bnc" id="L1589" title="All 2 branches missed.">                      for (String fieldName : list.fieldNames) {</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">                        if (fieldName.equals(&quot;*&quot;)) {</span>
<span class="nc" id="L1591">                          finalFieldName = null;</span>
<span class="nc" id="L1592">                          indexFieldName = null;</span>
<span class="nc" id="L1593">                          List&lt;IndexableField&gt; indxfldsList = doc.getFields();</span>
<span class="nc" id="L1594">                          indxflds = (IndexableField[]) indxfldsList.toArray(new IndexableField[indxfldsList.size()]);</span>
<span class="nc" id="L1595">                        } else {</span>
                          // implement aliases
<span class="nc" id="L1597">                          matcherAlias = patternAlias.matcher(fieldName);</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">                          if (matcherAlias.find()) {</span>
<span class="nc" id="L1599">                            finalFieldName = matcherAlias.group(1);</span>
<span class="nc" id="L1600">                            indexFieldName = matcherAlias.group(2);</span>
                          } else {
<span class="nc" id="L1602">                            finalFieldName = fieldName;</span>
<span class="nc" id="L1603">                            indexFieldName = fieldName;</span>
                          }
                          // get values
<span class="nc" id="L1606">                          indxflds = doc.getFields(indexFieldName);</span>
                        }
                        // store single or multiple values
<span class="nc bnc" id="L1609" title="All 2 branches missed.">                        if (indxflds.length == 1) {</span>
                          // handle wildcard
<span class="nc bnc" id="L1611" title="All 2 branches missed.">                          if (indexFieldName == null) {</span>
<span class="nc" id="L1612">                            finalFieldName = indxflds[0].name();</span>
                          }
<span class="nc bnc" id="L1614" title="All 2 branches missed.">                          if ((fieldValue = indxflds[0].numericValue()) != null) {</span>
<span class="nc" id="L1615">                            docFieldValues.put(finalFieldName, fieldValue);</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">                          } else if ((fieldValue = indxflds[0].stringValue()) != null) {</span>
<span class="nc" id="L1617">                            docFieldValues.put(finalFieldName, fieldValue);</span>
                          }
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                        } else if (indxflds.length &gt; 1) {</span>
<span class="nc" id="L1620">                          fieldValues = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">                          for (int i = 0; i &lt; indxflds.length; i++) {</span>
                            // handle wildcard
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                            if (indexFieldName == null) {</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">                              if (finalFieldName == null) {</span>
<span class="nc" id="L1625">                                finalFieldName = indxflds[0].name();</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">                              } else if (!finalFieldName.equals(indxflds[i].name())) {</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">                                if (!fieldValues.isEmpty()) {</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                                  if (fieldValues.size() == 1) {</span>
<span class="nc" id="L1629">                                    docFieldValues.put(finalFieldName, fieldValues.get(0));</span>
                                  } else {
<span class="nc" id="L1631">                                    docFieldValues.put(finalFieldName, fieldValues);</span>
                                  }
<span class="nc" id="L1633">                                  fieldValues = new ArrayList&lt;&gt;();</span>
                                }
<span class="nc" id="L1635">                                finalFieldName = indxflds[i].name();</span>
                              }
                            }
<span class="nc bnc" id="L1638" title="All 2 branches missed.">                            if ((fieldValue = indxflds[i].numericValue()) != null) {</span>
<span class="nc" id="L1639">                              fieldValues.add(fieldValue);</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                            } else if ((fieldValue = indxflds[i].stringValue()) != null) {</span>
<span class="nc" id="L1641">                              fieldValues.add(fieldValue);</span>
                            }
                          }
<span class="nc bnc" id="L1644" title="All 2 branches missed.">                          if (!fieldValues.isEmpty()) {</span>
<span class="nc bnc" id="L1645" title="All 2 branches missed.">                            if (fieldValues.size() == 1) {</span>
<span class="nc" id="L1646">                              docFieldValues.put(finalFieldName, fieldValues.get(0));</span>
                            } else {
<span class="nc" id="L1648">                              docFieldValues.put(finalFieldName, fieldValues);</span>
                            }
                          }
                        }
<span class="nc" id="L1652">                      }</span>
                    }
                    // get other doc info
<span class="nc" id="L1655">                    list.subTotal.put(docId, matchList.size());</span>
<span class="nc" id="L1656">                    IndexDoc mDoc = mtasCodecInfo.getDoc(field, (docId - docBase));</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">                    if (mDoc != null) {</span>
<span class="nc" id="L1658">                      list.minPosition.put(docId, mDoc.minPosition);</span>
<span class="nc" id="L1659">                      list.maxPosition.put(docId, mDoc.maxPosition);</span>
                    }
                  }
<span class="nc" id="L1662">                } else {</span>
<span class="nc" id="L1663">                  list.position += matchList.size();</span>
                }
<span class="nc bnc" id="L1665" title="All 4 branches missed.">              } else if (numberData != null &amp;&amp; (matchNumber = numberData.get(docId)) != null) {</span>
<span class="nc" id="L1666">                list.position += matchNumber;</span>
              }
<span class="nc" id="L1668">            }</span>
<span class="nc" id="L1669">            list.total = list.position;</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">          } else if (list.output.equals(ComponentList.LIST_OUTPUT_TOKEN)) {</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">            for (int docId : docSet) {</span>
<span class="nc bnc" id="L1672" title="All 4 branches missed.">              if (matchData != null &amp;&amp; (matchList = matchData.get(docId)) != null) {</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">                if (list.position &lt; (list.start + list.number)) {</span>
<span class="nc" id="L1674">                  boolean getDoc = false;</span>
                  Match m;
<span class="nc bnc" id="L1676" title="All 2 branches missed.">                  for (int i = 0; i &lt; matchList.size(); i++) {</span>
<span class="nc bnc" id="L1677" title="All 4 branches missed.">                    if ((list.position &gt;= list.start) &amp;&amp; (list.position &lt; (list.start + list.number))) {</span>
<span class="nc" id="L1678">                      m = matchList.get(i);</span>
<span class="nc" id="L1679">                      getDoc = true;</span>
<span class="nc" id="L1680">                      int startPosition = m.startPosition;</span>
<span class="nc" id="L1681">                      int endPosition = m.endPosition - 1;</span>
                      List&lt;MtasTokenString&gt; tokens;
<span class="nc" id="L1683">                      tokens = mtasCodecInfo.getPrefixFilteredObjectsByPositions(field, (docId - docBase),</span>
                          list.prefixes, startPosition - list.left, endPosition + list.right);
<span class="nc" id="L1685">                      list.tokens.add(new ListToken(docId, i, m, tokens));</span>
                    }
<span class="nc" id="L1687">                    list.position++;</span>
                  }
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                  if (getDoc) {</span>
                    // get unique id
<span class="nc" id="L1691">                    Document doc = searcher.doc(docId, new HashSet&lt;String&gt;(Arrays.asList(uniqueKeyField)));</span>
<span class="nc" id="L1692">                    IndexableField indxfld = doc.getField(uniqueKeyField);</span>
                    // get other doc info
<span class="nc bnc" id="L1694" title="All 2 branches missed.">                    if (indxfld != null) {</span>
<span class="nc" id="L1695">                      list.uniqueKey.put(docId, indxfld.stringValue());</span>
                    }
<span class="nc" id="L1697">                    list.subTotal.put(docId, matchList.size());</span>
<span class="nc" id="L1698">                    IndexDoc mDoc = mtasCodecInfo.getDoc(field, (docId - docBase));</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">                    if (mDoc != null) {</span>
<span class="nc" id="L1700">                      list.minPosition.put(docId, mDoc.minPosition);</span>
<span class="nc" id="L1701">                      list.maxPosition.put(docId, mDoc.maxPosition);</span>
                    }
                  }
<span class="nc" id="L1704">                } else {</span>
<span class="nc" id="L1705">                  list.position += matchList.size();</span>
                }
<span class="nc bnc" id="L1707" title="All 4 branches missed.">              } else if (numberData != null &amp;&amp; (matchNumber = numberData.get(docId)) != null) {</span>
<span class="nc" id="L1708">                list.position += matchNumber;</span>
              }
<span class="nc" id="L1710">            }</span>
<span class="nc" id="L1711">            list.total = list.position;</span>
          }

<span class="nc" id="L1714">        } else {</span>
<span class="nc" id="L1715">          Map&lt;Integer, Integer&gt; data = spansNumberData.get(list.spanQuery);</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">          if (data != null) {</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">            for (int docId : docSet) {</span>
<span class="nc" id="L1718">              Integer matchNumber = data.get(docId);</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">              if (matchNumber != null) {</span>
<span class="nc" id="L1720">                list.position += matchNumber;</span>
              }
<span class="nc" id="L1722">            }</span>
<span class="nc" id="L1723">            list.total = list.position;</span>
          }
        }
<span class="nc" id="L1726">      }</span>
    }
<span class="nc" id="L1728">  }</span>

  /**
   * Creates the group.
   *
   * @param groupList
   *          the group list
   * @param spansMatchData
   *          the spans match data
   * @param docSet
   *          the doc set
   * @param fieldInfo
   *          the field info
   * @param field
   *          the field
   * @param docBase
   *          the doc base
   * @param mtasCodecInfo
   *          the mtas codec info
   * @param searcher
   *          the searcher
   * @param lrc
   *          the lrc
   * @param status
   *          the status
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createGroup(List&lt;ComponentGroup&gt; groupList,
      Map&lt;MtasSpanQuery, Map&lt;Integer, List&lt;Match&gt;&gt;&gt; spansMatchData, List&lt;Integer&gt; docSet, FieldInfo fieldInfo,
      String field, int docBase, CodecInfo mtasCodecInfo, IndexSearcher searcher, LeafReaderContext lrc, Status status)
      throws IOException {

<span class="pc bpc" id="L1761" title="2 of 4 branches missed.">    if (mtasCodecInfo != null &amp;&amp; groupList != null) {</span>
      List&lt;Match&gt; matchList;
      Map&lt;Integer, List&lt;Match&gt;&gt; matchData;
<span class="fc bfc" id="L1764" title="All 2 branches covered.">      for (ComponentGroup group : groupList) {</span>
<span class="fc" id="L1765">        group.dataCollector.setWithTotal();</span>
<span class="pc bpc" id="L1766" title="1 of 2 branches missed.">        if (!group.prefixes.isEmpty()) {</span>
<span class="fc" id="L1767">          matchData = spansMatchData.get(group.spanQuery);</span>
<span class="fc" id="L1768">          Set&lt;String&gt; knownPrefixes = collectKnownPrefixes(fieldInfo);</span>
<span class="fc" id="L1769">          Set&lt;String&gt; intersectionPrefixes = collectIntersectionPrefixes(fieldInfo);</span>
<span class="fc" id="L1770">          boolean intersectionGroupPrefixes = intersectionPrefixes(group, intersectionPrefixes);</span>
<span class="fc" id="L1771">          boolean availablePrefixes = availablePrefixes(group, knownPrefixes);</span>
          // sort match lists
<span class="pc bpc" id="L1773" title="1 of 2 branches missed.">          if (!intersectionGroupPrefixes) {</span>
<span class="fc bfc" id="L1774" title="All 2 branches covered.">            for (Entry&lt;Integer, List&lt;Match&gt;&gt; entry : matchData.entrySet()) {</span>
<span class="fc" id="L1775">              sortMatchList(entry.getValue());</span>
<span class="fc" id="L1776">            }</span>
          }
          // init
<span class="fc" id="L1779">          group.dataCollector.initNewList(1);</span>
          int docId;

<span class="fc" id="L1782">          Map&lt;GroupHit, Long&gt; occurencesSum = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1783">          Map&lt;GroupHit, Integer&gt; occurencesN = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1784">          Set&lt;GroupHit&gt; occurencesInCurrentDocument = new HashSet&lt;&gt;();</span>

<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">          if (!availablePrefixes) {</span>
<span class="nc" id="L1787">            HashMap&lt;Integer, GroupHit&gt; hits = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">            for (int docCounter = 0; docCounter &lt; docSet.size(); docCounter++) {</span>
<span class="nc" id="L1789">              occurencesInCurrentDocument.clear();</span>
<span class="nc" id="L1790">              docId = docSet.get(docCounter);</span>
              GroupHit hit;
              GroupHit hitKey;
<span class="nc bnc" id="L1793" title="All 6 branches missed.">              if (matchData != null &amp;&amp; (matchList = matchData.get(docId)) != null &amp;&amp; !matchList.isEmpty()) {</span>
<span class="nc" id="L1794">                Iterator&lt;Match&gt; it = matchList.listIterator();</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">                while (it.hasNext()) {</span>
<span class="nc" id="L1796">                  Match m = it.next();</span>
<span class="nc" id="L1797">                  IntervalTreeNodeData&lt;String&gt; positionHit = createPositionHit(m, group);</span>
<span class="nc" id="L1798">                  int length = m.endPosition - m.startPosition;</span>
<span class="nc" id="L1799">                  hitKey = null;</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">                  if (!hits.containsKey(length)) {</span>
<span class="nc" id="L1801">                    hit = new GroupHit(positionHit.list, positionHit.start, positionHit.end, positionHit.hitStart,</span>
                        positionHit.hitEnd, group, knownPrefixes);
<span class="nc" id="L1803">                    hits.put(length, hit);</span>
                  } else {
<span class="nc" id="L1805">                    hit = hits.get(length);</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">                    for (GroupHit hitKeyItem : occurencesSum.keySet()) {</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">                      if (hitKeyItem.equals(hit)) {</span>
<span class="nc" id="L1808">                        hitKey = hitKeyItem;</span>
<span class="nc" id="L1809">                        break;</span>
                      }
<span class="nc" id="L1811">                    }</span>
                  }
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                  if (hitKey == null) {</span>
<span class="nc" id="L1814">                    occurencesSum.put(hit, Long.valueOf(1));</span>
<span class="nc" id="L1815">                    occurencesN.put(hit, 1);</span>
<span class="nc" id="L1816">                    occurencesInCurrentDocument.add(hit);</span>
                  } else {
<span class="nc" id="L1818">                    occurencesSum.put(hitKey, occurencesSum.get(hitKey) + 1);</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">                    if (!occurencesInCurrentDocument.contains(hitKey)) {</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">                      if (occurencesN.containsKey(hitKey)) {</span>
<span class="nc" id="L1821">                        occurencesN.put(hitKey, occurencesN.get(hitKey) + 1);</span>
                      } else {
<span class="nc" id="L1823">                        occurencesN.put(hitKey, 1);</span>
                      }
<span class="nc" id="L1825">                      occurencesInCurrentDocument.add(hitKey);</span>
                    }
                  }
<span class="nc" id="L1828">                }</span>
              }
            }
<span class="nc" id="L1831">          } else {</span>
<span class="fc" id="L1832">            int maximumNumberOfDocuments = 0;</span>
<span class="fc" id="L1833">            int boundaryMinimumNumberOfDocuments = 1;</span>
<span class="fc" id="L1834">            int boundaryMaximumNumberOfDocuments = 5;</span>
<span class="fc" id="L1835">            Set&lt;GroupHit&gt; administrationOccurrences = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1836" title="All 2 branches covered.">            for (int docCounter = 0; docCounter &lt; docSet.size(); docCounter++) {</span>
<span class="fc" id="L1837">              occurencesInCurrentDocument.clear();</span>
<span class="fc" id="L1838">              docId = docSet.get(docCounter);</span>
<span class="pc bpc" id="L1839" title="3 of 6 branches missed.">              if (matchData != null &amp;&amp; (matchList = matchData.get(docId)) != null &amp;&amp; !matchList.isEmpty()) {</span>
                // loop over matches
<span class="fc" id="L1841">                Iterator&lt;Match&gt; it = matchList.listIterator();</span>
<span class="fc" id="L1842">                ArrayList&lt;IntervalTreeNodeData&lt;String&gt;&gt; positionsHits = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1843" title="All 2 branches covered.">                while (it.hasNext()) {</span>
<span class="fc" id="L1844">                  Match m = it.next();</span>
<span class="fc" id="L1845">                  positionsHits.add(createPositionHit(m, group));</span>
<span class="fc" id="L1846">                }</span>
<span class="fc" id="L1847">                mtasCodecInfo.collectTermsByPrefixesForListOfHitPositions(field, (docId - docBase), group.prefixes,</span>
                    positionsHits);
                // administration
<span class="fc bfc" id="L1850" title="All 2 branches covered.">                for (IntervalTreeNodeData&lt;String&gt; positionHit : positionsHits) {</span>
<span class="fc" id="L1851">                  GroupHit hit = new GroupHit(positionHit.list, positionHit.start, positionHit.end,</span>
                      positionHit.hitStart, positionHit.hitEnd, group, knownPrefixes);
<span class="fc" id="L1853">                  GroupHit hitKey = null;</span>
<span class="fc bfc" id="L1854" title="All 2 branches covered.">                  for (GroupHit hitKeyItem : occurencesSum.keySet()) {</span>
<span class="fc bfc" id="L1855" title="All 2 branches covered.">                    if (hitKeyItem.equals(hit)) {</span>
<span class="fc" id="L1856">                      hitKey = hitKeyItem;</span>
<span class="fc" id="L1857">                      break;</span>
                    }
<span class="fc" id="L1859">                  }</span>
<span class="fc bfc" id="L1860" title="All 2 branches covered.">                  if (hitKey == null) {</span>
<span class="fc" id="L1861">                    occurencesSum.put(hit, Long.valueOf(1));</span>
<span class="fc" id="L1862">                    occurencesN.put(hit, 1);</span>
<span class="fc" id="L1863">                    occurencesInCurrentDocument.add(hit);</span>
                  } else {
<span class="fc" id="L1865">                    occurencesSum.put(hitKey, occurencesSum.get(hitKey) + 1);</span>
<span class="fc bfc" id="L1866" title="All 2 branches covered.">                    if (!occurencesInCurrentDocument.contains(hitKey)) {</span>
<span class="pc bpc" id="L1867" title="1 of 2 branches missed.">                      if (occurencesN.containsKey(hitKey)) {</span>
<span class="fc" id="L1868">                        occurencesN.put(hitKey, occurencesN.get(hitKey) + 1);</span>
                      } else {
<span class="nc" id="L1870">                        occurencesN.put(hitKey, 1);</span>
                      }
<span class="fc" id="L1872">                      occurencesInCurrentDocument.add(hitKey);</span>
                    }
                  }
<span class="fc" id="L1875">                }</span>
<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">                if (!intersectionGroupPrefixes) {</span>
<span class="fc bfc" id="L1877" title="All 2 branches covered.">                  for (GroupHit groupHit : occurencesInCurrentDocument) {</span>
<span class="fc" id="L1878">                    int tmpNumber = occurencesN.get(groupHit);</span>
<span class="fc" id="L1879">                    maximumNumberOfDocuments = Math.max(maximumNumberOfDocuments, tmpNumber);</span>
<span class="fc bfc" id="L1880" title="All 2 branches covered.">                    if (tmpNumber &gt; boundaryMinimumNumberOfDocuments) {</span>
<span class="fc" id="L1881">                      administrationOccurrences.add(groupHit);</span>
                    }
<span class="fc" id="L1883">                  }</span>
                  // collect spans
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">                  if (maximumNumberOfDocuments &gt; boundaryMaximumNumberOfDocuments) {</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">                    if (!administrationOccurrences.isEmpty()) {</span>
<span class="nc" id="L1887">                      Map&lt;GroupHit, Spans&gt; list = collectSpansForOccurences(administrationOccurrences, knownPrefixes,</span>
                          field, searcher, lrc);
<span class="nc bnc" id="L1889" title="All 2 branches missed.">                      if (list.size() &gt; 0) {</span>
<span class="nc" id="L1890">                        collectGroupUsingSpans(list, docSet, docBase, docCounter, matchData, occurencesSum,</span>
                            occurencesN);
                      }
                    }
<span class="nc" id="L1894">                    administrationOccurrences.clear();</span>
<span class="nc" id="L1895">                    maximumNumberOfDocuments = 0;</span>
<span class="nc" id="L1896">                    boundaryMinimumNumberOfDocuments = (int) Math.ceil(boundaryMinimumNumberOfDocuments * 1.2);</span>
<span class="nc" id="L1897">                    boundaryMaximumNumberOfDocuments = (int) Math.ceil(boundaryMaximumNumberOfDocuments * 1.2);</span>
                  }
                }
              }
            }
          }

<span class="fc bfc" id="L1904" title="All 2 branches covered.">          for (Entry&lt;GroupHit, Long&gt; entry : occurencesSum.entrySet()) {</span>
<span class="fc" id="L1905">            group.dataCollector.add(entry.getKey().toString(), entry.getValue(), occurencesN.get(entry.getKey()));</span>
<span class="fc" id="L1906">          }</span>
<span class="fc" id="L1907">          group.dataCollector.closeNewList();</span>
        }
<span class="fc" id="L1909">      }</span>
    }
<span class="fc" id="L1911">  }</span>

  /**
   * Available prefixes.
   *
   * @param group
   *          the group
   * @param knownPrefixes
   *          the known prefixes
   * @return true, if successful
   */
  private static boolean availablePrefixes(ComponentGroup group, Set&lt;String&gt; knownPrefixes) {
<span class="pc bpc" id="L1923" title="1 of 2 branches missed.">    if (knownPrefixes != null) {</span>
<span class="pc bpc" id="L1924" title="1 of 2 branches missed.">      for (String prefix : group.prefixes) {</span>
<span class="pc bpc" id="L1925" title="1 of 2 branches missed.">        if (knownPrefixes.contains(prefix)) {</span>
<span class="fc" id="L1926">          return true;</span>
        }
<span class="nc" id="L1928">      }</span>
    }
<span class="nc" id="L1930">    return false;</span>
  }

  /**
   * Intersection prefixes.
   *
   * @param group
   *          the group
   * @param intersectionPrefixes
   *          the intersection prefixes
   * @return true, if successful
   */
  private static boolean intersectionPrefixes(ComponentGroup group, Set&lt;String&gt; intersectionPrefixes) {
<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">    if (intersectionPrefixes != null) {</span>
<span class="fc bfc" id="L1944" title="All 2 branches covered.">      for (String prefix : group.prefixes) {</span>
<span class="pc bpc" id="L1945" title="1 of 2 branches missed.">        if (intersectionPrefixes.contains(prefix)) {</span>
<span class="nc" id="L1946">          return true;</span>
        }
<span class="fc" id="L1948">      }</span>
    }
<span class="fc" id="L1950">    return false;</span>
  }

  /**
   * Creates the position hit.
   *
   * @param m
   *          the m
   * @param group
   *          the group
   * @return the interval tree node data
   */
  private static IntervalTreeNodeData&lt;String&gt; createPositionHit(Match m, ComponentGroup group) {
<span class="fc" id="L1963">    Integer start = null;</span>
<span class="fc" id="L1964">    Integer end = null;</span>
<span class="fc bfc" id="L1965" title="All 6 branches covered.">    if (group.hitInside != null || group.hitInsideLeft != null || group.hitInsideRight != null) {</span>
<span class="fc" id="L1966">      start = m.startPosition;</span>
<span class="fc" id="L1967">      end = m.endPosition - 1;</span>
    } else {
<span class="fc" id="L1969">      start = null;</span>
<span class="fc" id="L1970">      end = null;</span>
    }
<span class="fc bfc" id="L1972" title="All 2 branches covered.">    if (group.hitLeft != null) {</span>
<span class="fc" id="L1973">      start = m.startPosition;</span>
<span class="fc" id="L1974">      end = Math.max(m.startPosition + group.hitLeft.length - 1, m.endPosition - 1);</span>
    }
<span class="fc bfc" id="L1976" title="All 2 branches covered.">    if (group.hitRight != null) {</span>
<span class="fc" id="L1977">      start = Math.min(m.endPosition - group.hitRight.length, m.startPosition);</span>
<span class="fc bfc" id="L1978" title="All 2 branches covered.">      end = end == null ? (m.endPosition - 1) : Math.max(end, (m.endPosition - 1));</span>
    }
<span class="fc bfc" id="L1980" title="All 2 branches covered.">    if (group.left != null) {</span>
<span class="fc bfc" id="L1981" title="All 2 branches covered.">      start = start == null ? m.startPosition - group.left.length</span>
<span class="fc" id="L1982">          : Math.min(m.startPosition - group.left.length, start);</span>
<span class="fc bfc" id="L1983" title="All 2 branches covered.">      end = end == null ? m.startPosition - 1 : Math.max(m.startPosition - 1, end);</span>
    }
<span class="fc bfc" id="L1985" title="All 2 branches covered.">    if (group.right != null) {</span>
<span class="fc bfc" id="L1986" title="All 2 branches covered.">      start = start == null ? m.endPosition : Math.min(m.endPosition, start);</span>
<span class="fc bfc" id="L1987" title="All 2 branches covered.">      end = end == null ? m.endPosition + group.right.length - 1</span>
<span class="fc" id="L1988">          : Math.max(m.endPosition + group.right.length - 1, end);</span>
    }
<span class="fc" id="L1990">    return new IntervalTreeNodeData&lt;&gt;(start, end, m.startPosition, m.endPosition - 1);</span>
  }

  /**
   * Collect group using spans.
   *
   * @param list
   *          the list
   * @param docSet
   *          the doc set
   * @param docBase
   *          the doc base
   * @param docCounter
   *          the doc counter
   * @param matchData
   *          the match data
   * @param occurencesSum
   *          the occurences sum
   * @param occurencesN
   *          the occurences N
   * @return the int
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static int collectGroupUsingSpans(Map&lt;GroupHit, Spans&gt; list, List&lt;Integer&gt; docSet, int docBase,
      int docCounter, Map&lt;Integer, List&lt;Match&gt;&gt; matchData, Map&lt;GroupHit, Long&gt; occurencesSum,
      Map&lt;GroupHit, Integer&gt; occurencesN) throws IOException {
<span class="nc" id="L2017">    int total = 0;</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">    if (docCounter + 1 &lt; docSet.size()) {</span>
      // initialize
<span class="nc" id="L2020">      int nextDocCounter = docCounter + 1;</span>
<span class="nc" id="L2021">      long[] subSum = new long[list.size()];</span>
<span class="nc" id="L2022">      int[] subN = new int[list.size()];</span>
<span class="nc" id="L2023">      boolean[] newNextDocs = new boolean[list.size()];</span>
      boolean newNextDoc;
<span class="nc" id="L2025">      int[] spansNextDoc = new int[list.size()];</span>
<span class="nc" id="L2026">      int nextDoc = 0;</span>
      List&lt;Match&gt; matchList;
<span class="nc" id="L2028">      GroupHit[] hitList = list.keySet().toArray(new GroupHit[list.size()]);</span>
<span class="nc" id="L2029">      Spans[] spansList = new Spans[list.size()];</span>
<span class="nc" id="L2030">      boolean[] finishedSpansList = new boolean[list.size()];</span>
<span class="nc" id="L2031">      newNextDoc = true;</span>
      // advance spans, find nextDoc
<span class="nc bnc" id="L2033" title="All 2 branches missed.">      for (int i = 0; i &lt; hitList.length; i++) {</span>
<span class="nc" id="L2034">        newNextDocs[i] = true;</span>
<span class="nc" id="L2035">        spansList[i] = list.get(hitList[i]);</span>
<span class="nc" id="L2036">        spansNextDoc[i] = spansList[i].advance(docSet.get(nextDocCounter) - docBase);</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">        nextDoc = (i == 0) ? spansNextDoc[i] : Math.min(nextDoc, spansNextDoc[i]);</span>
      }
      // loop over future documents
<span class="nc bnc" id="L2040" title="All 2 branches missed.">      while (nextDoc &lt; DocIdSetIterator.NO_MORE_DOCS) {</span>
        // find matches for next document
<span class="nc bnc" id="L2042" title="All 4 branches missed.">        while (nextDocCounter &lt; docSet.size() &amp;&amp; docSet.get(nextDocCounter) &lt; (nextDoc + docBase)) {</span>
<span class="nc" id="L2043">          nextDocCounter++;</span>
        }
        // finish, if no more docs in set
<span class="nc bnc" id="L2046" title="All 2 branches missed.">        if (nextDocCounter &gt;= docSet.size()) {</span>
<span class="nc" id="L2047">          break;</span>
        }
        // go to the matches
<span class="nc bnc" id="L2050" title="All 2 branches missed.">        if (docSet.get(nextDocCounter) == nextDoc + docBase) {</span>
<span class="nc" id="L2051">          matchList = matchData.get(nextDoc + docBase);</span>
<span class="nc bnc" id="L2052" title="All 4 branches missed.">          if (matchList != null &amp;&amp; !matchList.isEmpty()) {</span>
            // initialize
<span class="nc" id="L2054">            int currentMatchPosition = 0;</span>
<span class="nc" id="L2055">            int lastMatchStartPosition = matchList.get(matchList.size() - 1).startPosition;</span>
<span class="nc" id="L2056">            ArrayList&lt;Match&gt; newMatchList = new ArrayList&lt;&gt;(matchList.size());</span>
<span class="nc" id="L2057">            int currentSpanPosition = Spans.NO_MORE_POSITIONS;</span>
            // check and initialize for each span
<span class="nc bnc" id="L2059" title="All 2 branches missed.">            for (int i = 0; i &lt; spansList.length; i++) {</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">              if (spansList[i].docID() == nextDoc) {</span>
<span class="nc" id="L2061">                int tmpStartPosition = spansList[i].nextStartPosition();</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">                if (tmpStartPosition &lt; Spans.NO_MORE_POSITIONS) {</span>
<span class="nc" id="L2063">                  finishedSpansList[i] = false;</span>
                } else {
<span class="nc" id="L2065">                  finishedSpansList[i] = true;</span>
                }
                // compute position
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                currentSpanPosition = (currentSpanPosition == Spans.NO_MORE_POSITIONS) ? tmpStartPosition</span>
<span class="nc" id="L2069">                    : Math.min(currentSpanPosition, tmpStartPosition);</span>
<span class="nc" id="L2070">              } else {</span>
<span class="nc" id="L2071">                finishedSpansList[i] = true;</span>
              }
            }
            // loop over matches
<span class="nc bnc" id="L2075" title="All 4 branches missed.">            while (currentMatchPosition &lt; matchList.size() &amp;&amp; currentSpanPosition &lt; Spans.NO_MORE_POSITIONS) {</span>

<span class="nc bnc" id="L2077" title="All 2 branches missed.">              if (currentSpanPosition &lt; matchList.get(currentMatchPosition).startPosition) {</span>
                // do nothing, match not reached
<span class="nc bnc" id="L2079" title="All 2 branches missed.">              } else if (currentSpanPosition &gt; lastMatchStartPosition) {</span>
                // finish, past last match
<span class="nc" id="L2081">                break;</span>
              } else {
                // advance matches
<span class="nc bnc" id="L2084" title="All 2 branches missed.">                while (currentMatchPosition &lt; matchList.size()</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">                    &amp;&amp; currentSpanPosition &gt; matchList.get(currentMatchPosition).startPosition) {</span>
                  // store current match, not relevant
<span class="nc" id="L2087">                  newMatchList.add(matchList.get(currentMatchPosition));</span>
<span class="nc" id="L2088">                  currentMatchPosition++;</span>
                }
                // equal startPosition
<span class="nc bnc" id="L2091" title="All 2 branches missed.">                while (currentMatchPosition &lt; matchList.size()</span>
<span class="nc bnc" id="L2092" title="All 2 branches missed.">                    &amp;&amp; currentSpanPosition == matchList.get(currentMatchPosition).startPosition) {</span>
                  // check for each span
<span class="nc bnc" id="L2094" title="All 2 branches missed.">                  for (int i = 0; i &lt; spansList.length; i++) {</span>
                    // equal start and end, therefore match
<span class="nc bnc" id="L2096" title="All 4 branches missed.">                    if (!finishedSpansList[i] &amp;&amp; spansList[i].docID() == nextDoc</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">                        &amp;&amp; spansList[i].startPosition() == matchList.get(currentMatchPosition).startPosition</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">                        &amp;&amp; spansList[i].endPosition() == matchList.get(currentMatchPosition).endPosition) {</span>
                      // administration
<span class="nc" id="L2100">                      total++;</span>
<span class="nc" id="L2101">                      subSum[i]++;</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">                      if (newNextDocs[i]) {</span>
<span class="nc" id="L2103">                        subN[i]++;</span>
<span class="nc" id="L2104">                        newNextDocs[i] = false;</span>
<span class="nc" id="L2105">                        newNextDoc = false;</span>
                      }
<span class="nc bnc" id="L2107" title="All 4 branches missed.">                    } else if (!finishedSpansList[i] &amp;&amp; spansList[i].docID() == nextDoc</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">                        &amp;&amp; spansList[i].startPosition() == matchList.get(currentMatchPosition).startPosition) {</span>
                      // no match, store
<span class="nc" id="L2110">                      newMatchList.add(matchList.get(currentMatchPosition));</span>
                    }
                  }
<span class="nc" id="L2113">                  currentMatchPosition++;</span>
                }
              }

              // advance spans
<span class="nc bnc" id="L2118" title="All 2 branches missed.">              if (currentMatchPosition &lt; matchList.size()) {</span>
<span class="nc" id="L2119">                currentSpanPosition = Spans.NO_MORE_POSITIONS;</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">                for (int i = 0; i &lt; spansList.length; i++) {</span>
<span class="nc bnc" id="L2121" title="All 4 branches missed.">                  if (!finishedSpansList[i] &amp;&amp; (spansList[i].docID() == nextDoc)) {</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">                    while (!finishedSpansList[i]</span>
<span class="nc bnc" id="L2123" title="All 2 branches missed.">                        &amp;&amp; spansList[i].startPosition() &lt; matchList.get(currentMatchPosition).startPosition) {</span>
<span class="nc" id="L2124">                      int tmpStartPosition = spansList[i].nextStartPosition();</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">                      if (tmpStartPosition == Spans.NO_MORE_POSITIONS) {</span>
<span class="nc" id="L2126">                        finishedSpansList[i] = true;</span>
                      }
<span class="nc" id="L2128">                    }</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">                    if (!finishedSpansList[i]) {</span>
<span class="nc bnc" id="L2130" title="All 2 branches missed.">                      currentSpanPosition = (currentSpanPosition == Spans.NO_MORE_POSITIONS)</span>
<span class="nc" id="L2131">                          ? spansList[i].startPosition()</span>
<span class="nc" id="L2132">                          : Math.min(currentSpanPosition, spansList[i].startPosition());</span>
                    }
                  } else {
<span class="nc" id="L2135">                    finishedSpansList[i] = true;</span>
                  }
                }
              }
            }
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            if (!newNextDoc) {</span>
              // add other matches
<span class="nc bnc" id="L2142" title="All 2 branches missed.">              while (currentMatchPosition &lt; matchList.size()) {</span>
<span class="nc" id="L2143">                newMatchList.add(matchList.get(currentMatchPosition));</span>
<span class="nc" id="L2144">                currentMatchPosition++;</span>
              }
              // update administration
<span class="nc bnc" id="L2147" title="All 2 branches missed.">              if (!newMatchList.isEmpty()) {</span>
<span class="nc" id="L2148">                matchData.put(nextDoc + docBase, newMatchList);</span>
              } else {
<span class="nc" id="L2150">                matchData.put(nextDoc + docBase, null);</span>
              }
            }
          }
        }
        // advance to next document
<span class="nc" id="L2156">        nextDocCounter++;</span>
<span class="nc" id="L2157">        newNextDoc = true;</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">        for (int i = 0; i &lt; hitList.length; i++) {</span>
<span class="nc" id="L2159">          newNextDocs[i] = true;</span>
        }
        // advance spans
<span class="nc bnc" id="L2162" title="All 2 branches missed.">        if (nextDocCounter &lt; docSet.size()) {</span>
<span class="nc" id="L2163">          nextDoc = Spans.NO_MORE_DOCS;</span>
          // advance spans
<span class="nc bnc" id="L2165" title="All 2 branches missed.">          for (int i = 0; i &lt; hitList.length; i++) {</span>
<span class="nc bnc" id="L2166" title="All 2 branches missed.">            if (spansNextDoc[i] &lt; (docSet.get(nextDocCounter) - docBase)) {</span>
<span class="nc" id="L2167">              spansNextDoc[i] = spansList[i].advance(docSet.get(nextDocCounter) - docBase);</span>
            }
<span class="nc bnc" id="L2169" title="All 2 branches missed.">            if (spansNextDoc[i] &lt; Spans.NO_MORE_DOCS) {</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">              nextDoc = (nextDoc == Spans.NO_MORE_DOCS) ? spansNextDoc[i] : Math.min(nextDoc, spansNextDoc[i]);</span>
            }
          }
        }
      }
      // update administration
<span class="nc bnc" id="L2176" title="All 2 branches missed.">      for (int i = 0; i &lt; hitList.length; i++) {</span>
<span class="nc bnc" id="L2177" title="All 4 branches missed.">        if (subSum[i] &gt; 0 &amp;&amp; (occurencesSum.containsKey(hitList[i]))) {</span>
<span class="nc" id="L2178">          occurencesSum.put(hitList[i], occurencesSum.get(hitList[i]) + subSum[i]);</span>
<span class="nc" id="L2179">          occurencesN.put(hitList[i], occurencesN.get(hitList[i]) + subN[i]);</span>
        }
      }

    }
<span class="nc" id="L2184">    return total;</span>
  }

  /**
   * Sort match list.
   *
   * @param list
   *          the list
   */
  private static void sortMatchList(List&lt;Match&gt; list) {
<span class="pc bpc" id="L2194" title="1 of 2 branches missed.">    if (list != null) {</span>
      // light sorting on start position
<span class="fc" id="L2196">      Collections.sort(list, (Match m1, Match m2) -&gt; (Integer.compare(m1.startPosition, m2.startPosition)));</span>
    }
<span class="fc" id="L2198">  }</span>

  /**
   * Creates the pages.
   *
   * @param pageList
   *          the page list
   * @param docList
   *          the doc list
   * @param fieldInfo
   *          the field info
   * @param field
   *          the field
   * @param docBase
   *          the doc base
   * @param uniqueKeyField
   *          the unique key field
   * @param mtasCodecInfo
   *          the mtas codec info
   * @param searcher
   *          the searcher
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createPages(List&lt;ComponentPage&gt; pageList, List&lt;Integer&gt; docList, FieldInfo fieldInfo,
      String field, int docBase, String uniqueKeyField, CodecInfo mtasCodecInfo, IndexSearcher searcher)
      throws IOException {
<span class="nc bnc" id="L2225" title="All 2 branches missed.">    if (pageList != null) {</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">      for (ComponentPage page : pageList) {</span>
        // initialize
<span class="nc bnc" id="L2228" title="All 2 branches missed.">        for (int docId : docList) {</span>
          // get unique id
<span class="nc" id="L2230">          Document doc = searcher.doc(docId, new HashSet&lt;String&gt;(Arrays.asList(uniqueKeyField)));</span>
<span class="nc" id="L2231">          IndexableField indxfld = doc.getField(uniqueKeyField);</span>
          // get other doc info
<span class="nc bnc" id="L2233" title="All 2 branches missed.">          if (indxfld != null) {</span>
<span class="nc" id="L2234">            page.uniqueKey.put(docId, indxfld.stringValue());</span>
          }
<span class="nc" id="L2236">          IndexDoc mDoc = mtasCodecInfo.getDoc(field, (docId - docBase));</span>
<span class="nc bnc" id="L2237" title="All 2 branches missed.">          if (mDoc != null) {</span>
<span class="nc" id="L2238">            page.minPosition.put(docId, mDoc.minPosition);</span>
<span class="nc" id="L2239">            page.maxPosition.put(docId, mDoc.maxPosition);</span>
            // get prefixes
<span class="nc" id="L2241">            String singlePositionPrefixes = fieldInfo</span>
<span class="nc" id="L2242">                .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SINGLE_POSITION);</span>
<span class="nc" id="L2243">            String multiplePositionPrefixes = fieldInfo</span>
<span class="nc" id="L2244">                .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_MULTIPLE_POSITION);</span>
<span class="nc" id="L2245">            String setPositionPrefixes = fieldInfo</span>
<span class="nc" id="L2246">                .getAttribute(MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SET_POSITION);</span>
            // collect tokens
            List&lt;MtasTokenString&gt; tokens;
            List&lt;String&gt; allPrefixes;
            // words
<span class="nc bnc" id="L2251" title="All 2 branches missed.">            if (singlePositionPrefixes != null) {</span>
<span class="nc" id="L2252">              allPrefixes = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L2253">                  Arrays.asList(singlePositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER))));</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">              if (!page.prefixes.isEmpty()) {</span>
<span class="nc" id="L2255">                allPrefixes.retainAll(page.prefixes);</span>
              }
<span class="nc bnc" id="L2257" title="All 2 branches missed.">              if (allPrefixes.size() &gt; 0) {</span>
<span class="nc" id="L2258">                Map&lt;Integer, PageWordData&gt; wordList = new HashMap&lt;&gt;();</span>
                PageWordData wordData;
<span class="nc" id="L2260">                tokens = mtasCodecInfo.getPrefixFilteredObjectsByPositions(field, (docId - docBase), allPrefixes,</span>
<span class="nc" id="L2261">                    Math.max(mDoc.minPosition, page.start), Math.min(mDoc.maxPosition, page.end));</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">                for (MtasTokenString token : tokens) {</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">                  if (wordList.containsKey(token.getPositionStart())) {</span>
<span class="nc" id="L2264">                    wordData = wordList.get(token.getPositionStart());</span>
                  } else {
<span class="nc" id="L2266">                    wordData = new PageWordData();</span>
<span class="nc" id="L2267">                    wordList.put(token.getPositionStart(), wordData);</span>
                  }
<span class="nc" id="L2269">                  wordData.add(token);</span>
<span class="nc" id="L2270">                }</span>
<span class="nc" id="L2271">                page.wordList.put(docId, wordList);</span>
              }
            }
            // ranges
<span class="nc bnc" id="L2275" title="All 2 branches missed.">            if (multiplePositionPrefixes != null) {</span>
<span class="nc" id="L2276">              allPrefixes = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L2277">                  Arrays.asList(multiplePositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER))));</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">              if (setPositionPrefixes != null) {</span>
<span class="nc" id="L2279">                allPrefixes.removeAll(Arrays.asList(setPositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER))));</span>
              }
<span class="nc bnc" id="L2281" title="All 2 branches missed.">              if (!page.prefixes.isEmpty()) {</span>
<span class="nc" id="L2282">                allPrefixes.retainAll(page.prefixes);</span>
              }
<span class="nc bnc" id="L2284" title="All 2 branches missed.">              if (allPrefixes.size() &gt; 0) {</span>
<span class="nc" id="L2285">                Map&lt;Integer, PageRangeData&gt; rangeList = new HashMap&lt;&gt;();</span>
                PageRangeData rangeData;
<span class="nc" id="L2287">                tokens = mtasCodecInfo.getPrefixFilteredObjectsByPositions(field, (docId - docBase), allPrefixes,</span>
<span class="nc" id="L2288">                    Math.max(mDoc.minPosition, page.start), Math.min(mDoc.maxPosition, page.end));</span>
<span class="nc bnc" id="L2289" title="All 2 branches missed.">                for (MtasTokenString token : tokens) {</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">                  if (rangeList.containsKey(token.getPositionStart())) {</span>
<span class="nc" id="L2291">                    rangeData = rangeList.get(token.getPositionStart());</span>
                  } else {
<span class="nc" id="L2293">                    rangeData = new PageRangeData();</span>
<span class="nc" id="L2294">                    rangeList.put(token.getPositionStart(), rangeData);</span>
                  }
<span class="nc" id="L2296">                  rangeData.add(token);</span>
<span class="nc" id="L2297">                }</span>
<span class="nc" id="L2298">                page.rangeList.put(docId, rangeList);</span>
              }
            }
            // sets
<span class="nc bnc" id="L2302" title="All 2 branches missed.">            if (setPositionPrefixes != null) {</span>
<span class="nc" id="L2303">              allPrefixes = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L2304">                  Arrays.asList(setPositionPrefixes.split(Pattern.quote(MtasToken.DELIMITER))));</span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">              if (!page.prefixes.isEmpty()) {</span>
<span class="nc" id="L2306">                allPrefixes.retainAll(page.prefixes);</span>
              }
<span class="nc bnc" id="L2308" title="All 2 branches missed.">              if (allPrefixes.size() &gt; 0) {</span>
<span class="nc" id="L2309">                Map&lt;Integer, PageSetData&gt; setList = new HashMap&lt;&gt;();</span>
                PageSetData setData;
<span class="nc" id="L2311">                tokens = mtasCodecInfo.getPrefixFilteredObjectsByPositions(field, (docId - docBase), allPrefixes,</span>
<span class="nc" id="L2312">                    Math.max(mDoc.minPosition, page.start), Math.min(mDoc.maxPosition, page.end));</span>
<span class="nc bnc" id="L2313" title="All 2 branches missed.">                for (MtasTokenString token : tokens) {</span>
<span class="nc bnc" id="L2314" title="All 2 branches missed.">                  if (setList.containsKey(token.getPositionStart())) {</span>
<span class="nc" id="L2315">                    setData = setList.get(token.getPositionStart());</span>
                  } else {
<span class="nc" id="L2317">                    setData = new PageSetData();</span>
<span class="nc" id="L2318">                    setList.put(token.getPositionStart(), setData);</span>
                  }
<span class="nc" id="L2320">                  setData.add(token);</span>
<span class="nc" id="L2321">                }</span>
<span class="nc" id="L2322">                page.setList.put(docId, setList);</span>
              }
            }
          }
<span class="nc" id="L2326">        }</span>
<span class="nc" id="L2327">      }</span>
    }
<span class="nc" id="L2329">  }</span>

  private static void createHeatmaps(List&lt;ComponentHeatmap&gt; heatmapList, Map&lt;Integer, Integer&gt; positionsData,
      Map&lt;MtasSpanQuery, Map&lt;Integer, Integer&gt;&gt; spansNumberData, List&lt;Integer&gt; docSetOld, LeafReader r, LeafReaderContext lrc)
      throws IOException {
<span class="fc" id="L2334">    Integer[] docSet = docSetOld.toArray(new Integer[docSetOld.size()]);</span>
<span class="pc bpc" id="L2335" title="1 of 2 branches missed.">    if (heatmapList != null) {</span>
<span class="fc bfc" id="L2336" title="All 2 branches covered.">      for (ComponentHeatmap heatmap : heatmapList) {</span>
<span class="pc bpc" id="L2337" title="1 of 2 branches missed.">        if (heatmap.parser.needArgumentsNumber() &gt; heatmap.queries.length) {</span>
<span class="nc" id="L2338">          throw new IOException(&quot;function &quot; + heatmap.parser + &quot; expects (at least) &quot;</span>
<span class="nc" id="L2339">              + heatmap.parser.needArgumentsNumber() + &quot; queries&quot;);</span>
        }
        // collect
<span class="fc" id="L2342">        Map&lt;Integer, long[]&gt; args = computeArguments(spansNumberData, heatmap.queries, docSet);</span>
<span class="pc bpc" id="L2343" title="1 of 2 branches missed.">        if (heatmap.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
          // collect
<span class="pc bpc" id="L2345" title="1 of 2 branches missed.">          if (docSet.length &gt; 0) {</span>
<span class="fc" id="L2346">            int number = 0;</span>
            int docPositions;
            long docValueLong;
            //double valueDouble;
<span class="fc" id="L2350">            long[] values = new long[docSet.length];</span>
<span class="fc" id="L2351">            int[] docs = new int[docSet.length];</span>
<span class="fc" id="L2352">            int[] positions = new int[docSet.length];</span>
<span class="fc" id="L2353">            long[][] arguments = new long[docSet.length][];</span>
            //long[][] functionValuesLong = null;
            //double[][] functionValuesDouble = null;
//            if (heatmap.hm.functions != null) {
//              functionValuesLong = new long[heatmap.hm.functions.size()][];
//              functionValuesDouble = new double[heatmap.hm.functions.size()][];
//              for (int i = 0; i &lt; heatmap.hm.functions.size(); i++) {
//                SubComponentFunction function = heatmap.hm.functions.get(i);
//                if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {
//                  functionValuesLong[i] = new long[docSet.length];
//                  functionValuesDouble[i] = null;
//                } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {
//                  functionValuesLong[i] = null;
//                  functionValuesDouble[i] = new double[docSet.length];
//                }
//              }            
//            }
<span class="fc bfc" id="L2370" title="All 2 branches covered.">            for (int docId : docSet) {</span>
<span class="pc bpc" id="L2371" title="1 of 2 branches missed.">              if (positionsData == null) {</span>
<span class="fc" id="L2372">                docPositions = 0;</span>
              } else {
<span class="nc bnc" id="L2374" title="All 2 branches missed.">                docPositions = (positionsData.get(docId) == null ? 0 : positionsData.get(docId));</span>
              }
<span class="fc" id="L2376">              docValueLong = heatmap.parser.getValueLong(args.get(docId), docPositions);</span>
<span class="pc bpc" id="L2377" title="3 of 6 branches missed.">              if (((heatmap.minimumLong == null) || (docValueLong &gt;= heatmap.minimumLong))</span>
<span class="nc bnc" id="L2378" title="All 2 branches missed.">                  &amp;&amp; ((heatmap.maximumLong == null) || (docValueLong &lt;= heatmap.maximumLong))) {</span>
<span class="fc" id="L2379">                values[number] = docValueLong;</span>
<span class="fc" id="L2380">                docs[number] = docId-lrc.docBase;</span>
<span class="fc" id="L2381">                positions[number] = docPositions;</span>
<span class="fc" id="L2382">                arguments[number] = args.get(docId);</span>
                
//                if (heatmap.hm.functions != null) {
//                  
//                  for (int i = 0; i &lt; heatmap.hm.functions.size(); i++) {
//                    SubComponentFunction function = heatmap.hm.functions.get(i);
//                    try {
//                      if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {
//                        valueLong = function.parserFunction.getValueLong(args.get(docId), positions);
//                        functionValuesLong[i][number] = valueLong;
//                      } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {
//                        valueDouble = function.parserFunction.getValueDouble(args.get(docId), positions);
//                        functionValuesDouble[i][number] = valueDouble;
//                      }
//                    } catch (IOException e) {
//                      log.debug(e);
//                      //TODO implement for list
//                      //function.dataCollector.error(e.getMessage());
//                    }
//                  }
//                }
<span class="fc" id="L2403">                number++;</span>
              }
            }
<span class="pc bpc" id="L2406" title="1 of 2 branches missed.">            if (number &gt; 0) {</span>
<span class="fc" id="L2407">              HeatmapMtasCounter.calcValues(heatmap.strategy, lrc, heatmap, number, docs, values, arguments, positions);</span>
            }  
<span class="fc" id="L2409">          }</span>
        } else {
<span class="nc" id="L2411">          throw new IOException(&quot;unexpected dataType &quot; + heatmap.dataType);</span>
        }
<span class="fc" id="L2413">      }</span>
    }
<span class="fc" id="L2415">  }</span>

  /**
   * Creates the document.
   *
   * @param documentList
   *          the document list
   * @param docList
   *          the doc list
   * @param uniqueKeyField
   *          the unique key field
   * @param searcher
   *          the searcher
   * @param t
   *          the t
   * @param lrc
   *          the lrc
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createDocument(List&lt;ComponentDocument&gt; documentList, List&lt;Integer&gt; docList, String uniqueKeyField,
      IndexSearcher searcher, Terms t, LeafReaderContext lrc) throws IOException {
<span class="nc bnc" id="L2437" title="All 2 branches missed.">    if (documentList != null) {</span>
<span class="nc" id="L2438">      SortedSet&lt;String&gt; listStatsItems = CodecUtil.createStatsItems(&quot;sum&quot;);</span>
<span class="nc" id="L2439">      String listStatsType = CodecUtil.createStatsType(listStatsItems, CodecUtil.STATS_TYPE_SUM, null);</span>
<span class="nc bnc" id="L2440" title="All 2 branches missed.">      for (ComponentDocument document : documentList) {</span>
        // initialize
<span class="nc bnc" id="L2442" title="All 2 branches missed.">        for (int docId : docList) {</span>
          // get unique id
<span class="nc" id="L2444">          Document doc = searcher.doc(docId, new HashSet&lt;String&gt;(Arrays.asList(uniqueKeyField)));</span>
<span class="nc" id="L2445">          IndexableField indxfld = doc.getField(uniqueKeyField);</span>
          // get other doc info
<span class="nc bnc" id="L2447" title="All 2 branches missed.">          if (indxfld != null) {</span>
<span class="nc" id="L2448">            document.uniqueKey.put(docId, indxfld.stringValue());</span>
<span class="nc" id="L2449">            MtasDataCollector&lt;?, ?&gt; stats = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_DATA,</span>
                document.dataType, document.statsType, document.statsItems, null, null, null, null, null, null);
<span class="nc" id="L2451">            document.statsData.put(docId, stats);</span>
<span class="nc bnc" id="L2452" title="All 2 branches missed.">            if (document.statsList != null) {</span>
              MtasDataCollector&lt;?, ?&gt; list;
<span class="nc bnc" id="L2454" title="All 2 branches missed.">              if (document.listExpand) {</span>
<span class="nc" id="L2455">                SortedSet&lt;String&gt;[] baseStatsItems = new SortedSet[] { listStatsItems };</span>
<span class="nc" id="L2456">                list = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_LIST, CodecUtil.DATA_TYPE_LONG,</span>
<span class="nc" id="L2457">                    listStatsType, listStatsItems, CodecUtil.STATS_TYPE_SUM, CodecUtil.SORT_DESC, 0,</span>
<span class="nc" id="L2458">                    document.listNumber, new String[] { DataCollector.COLLECTOR_TYPE_LIST },</span>
                    new String[] { CodecUtil.DATA_TYPE_LONG }, new String[] { listStatsType },
<span class="nc" id="L2460">                    Arrays.copyOfRange(baseStatsItems, 0, baseStatsItems.length),</span>
                    new String[] { CodecUtil.STATS_TYPE_SUM }, new String[] { CodecUtil.SORT_DESC },
<span class="nc" id="L2462">                    new Integer[] { 0 }, new Integer[] { document.listExpandNumber }, null, null);</span>
<span class="nc" id="L2463">              } else {</span>
<span class="nc" id="L2464">                list = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_LIST, CodecUtil.DATA_TYPE_LONG,</span>
<span class="nc" id="L2465">                    listStatsType, listStatsItems, CodecUtil.STATS_TYPE_SUM, CodecUtil.SORT_DESC, 0,</span>
<span class="nc" id="L2466">                    document.listNumber, null, null);</span>
              }
<span class="nc" id="L2468">              document.statsList.put(docId, list);</span>
            }
          }
<span class="nc" id="L2471">        }</span>
<span class="nc" id="L2472">      }</span>
      // collect
<span class="nc bnc" id="L2474" title="All 2 branches missed.">      if (t != null) {</span>
        BytesRef term;
        TermsEnum termsEnum;
<span class="nc" id="L2477">        PostingsEnum postingsEnum = null;</span>
        // loop over termvectors
<span class="nc bnc" id="L2479" title="All 2 branches missed.">        for (ComponentDocument document : documentList) {</span>

          List&lt;CompiledAutomaton&gt; listAutomata;
          Map&lt;String, Automaton&gt; automatonMap;
          Map&lt;String, ByteRunAutomaton&gt; byteRunAutomatonMap;
<span class="nc bnc" id="L2484" title="All 2 branches missed.">          if (document.list == null) {</span>
<span class="nc" id="L2485">            automatonMap = null;</span>
<span class="nc" id="L2486">            byteRunAutomatonMap = null;</span>
<span class="nc" id="L2487">            listAutomata = new ArrayList&lt;&gt;();</span>
            CompiledAutomaton compiledAutomaton;
            Automaton automaton;
<span class="nc bnc" id="L2490" title="All 4 branches missed.">            if ((document.regexp == null) || (document.regexp.isEmpty())) {</span>
<span class="nc" id="L2491">              RegExp re = new RegExp(document.prefix + MtasToken.DELIMITER + &quot;.*&quot;);</span>
<span class="nc" id="L2492">              automaton = re.toAutomaton();</span>
<span class="nc" id="L2493">            } else {</span>
<span class="nc" id="L2494">              RegExp re = new RegExp(document.prefix + MtasToken.DELIMITER + document.regexp + &quot;\u0000*&quot;);</span>
<span class="nc" id="L2495">              automaton = re.toAutomaton();</span>
            }
<span class="nc" id="L2497">            compiledAutomaton = new CompiledAutomaton(automaton);</span>
<span class="nc" id="L2498">            listAutomata.add(compiledAutomaton);</span>
<span class="nc" id="L2499">          } else {</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">            automatonMap = MtasToken.createAutomatonMap(document.prefix, new ArrayList&lt;String&gt;(document.list),</span>
<span class="nc" id="L2501">                document.listRegexp ? false : true);</span>
<span class="nc" id="L2502">            byteRunAutomatonMap = MtasToken.byteRunAutomatonMap(automatonMap);</span>
<span class="nc" id="L2503">            listAutomata = MtasToken.createAutomata(document.prefix, document.regexp, automatonMap);</span>
          }
<span class="nc" id="L2505">          List&lt;ByteRunAutomaton&gt; ignoreByteRunAutomatonList = null;</span>
<span class="nc bnc" id="L2506" title="All 4 branches missed.">          if ((document.ignoreRegexp != null) &amp;&amp; (!document.ignoreRegexp.isEmpty())) {</span>
<span class="nc" id="L2507">            ignoreByteRunAutomatonList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2508">            RegExp re = new RegExp(document.prefix + MtasToken.DELIMITER + document.ignoreRegexp + &quot;\u0000*&quot;);</span>
<span class="nc" id="L2509">            ignoreByteRunAutomatonList.add(new ByteRunAutomaton(re.toAutomaton()));</span>
          }
<span class="nc bnc" id="L2511" title="All 2 branches missed.">          if (document.ignoreList != null) {</span>
<span class="nc bnc" id="L2512" title="All 2 branches missed.">            if (ignoreByteRunAutomatonList == null) {</span>
<span class="nc" id="L2513">              ignoreByteRunAutomatonList = new ArrayList&lt;&gt;();</span>
            }
<span class="nc bnc" id="L2515" title="All 2 branches missed.">            Map&lt;String, Automaton&gt; list = MtasToken.createAutomatonMap(document.prefix,</span>
<span class="nc" id="L2516">                new ArrayList&lt;String&gt;(document.ignoreList), document.ignoreListRegexp ? false : true);</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">            for (Automaton automaton : list.values()) {</span>
<span class="nc" id="L2518">              ignoreByteRunAutomatonList.add(new ByteRunAutomaton(automaton));</span>
<span class="nc" id="L2519">            }</span>
          }

<span class="nc bnc" id="L2522" title="All 2 branches missed.">          for (CompiledAutomaton compiledAutomaton : listAutomata) {</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">            if (!compiledAutomaton.type.equals(CompiledAutomaton.AUTOMATON_TYPE.NONE)) {</span>
<span class="nc" id="L2524">              termsEnum = t.intersect(compiledAutomaton, null);</span>
              // init
<span class="nc" id="L2526">              int initBaseSize = Math.min((int) t.size(), 1000);</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">              int initListSize = document.statsList != null ? Math.min(document.statsList.size(), initBaseSize)</span>
                  : initBaseSize;
<span class="nc" id="L2529">              HashSet&lt;MtasDataCollector&lt;?, ?&gt;&gt; initialised = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2530" title="All 2 branches missed.">              for (int docId : docList) {</span>
<span class="nc" id="L2531">                document.statsData.get(docId).initNewList(1);</span>
<span class="nc" id="L2532">                initialised.add(document.statsData.get(docId));</span>
<span class="nc bnc" id="L2533" title="All 4 branches missed.">                if (document.statsList != null &amp;&amp; document.statsList.size() &gt; 0) {</span>
<span class="nc" id="L2534">                  document.statsList.get(docId).initNewList(initListSize);</span>
<span class="nc" id="L2535">                  initialised.add(document.statsList.get(docId));</span>
                }
<span class="nc" id="L2537">              }</span>
              // fill
              int termDocId;
              boolean acceptedTerm;
<span class="nc bnc" id="L2541" title="All 2 branches missed.">              while ((term = termsEnum.next()) != null) {</span>
<span class="nc" id="L2542">                Iterator&lt;Integer&gt; docIterator = docList.iterator();</span>
<span class="nc" id="L2543">                postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.FREQS);</span>
<span class="nc" id="L2544">                termDocId = -1;</span>
<span class="nc" id="L2545">                acceptedTerm = true;</span>
<span class="nc bnc" id="L2546" title="All 2 branches missed.">                if (ignoreByteRunAutomatonList != null) {</span>
<span class="nc bnc" id="L2547" title="All 2 branches missed.">                  for (ByteRunAutomaton ignoreByteRunAutomaton : ignoreByteRunAutomatonList) {</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">                    if (ignoreByteRunAutomaton.run(term.bytes, term.offset, term.length)) {</span>
<span class="nc" id="L2549">                      acceptedTerm = false;</span>
<span class="nc" id="L2550">                      break;</span>
                    }
<span class="nc" id="L2552">                  }</span>
                }
<span class="nc bnc" id="L2554" title="All 2 branches missed.">                if (acceptedTerm) {</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">                  while (docIterator.hasNext()) {</span>
<span class="nc" id="L2556">                    int segmentDocId = docIterator.next() - lrc.docBase;</span>
<span class="nc bnc" id="L2557" title="All 4 branches missed.">                    if (segmentDocId &gt;= termDocId &amp;&amp; ((segmentDocId == termDocId)</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">                        || ((termDocId = postingsEnum.advance(segmentDocId)) == segmentDocId))) {</span>
                      // register stats
<span class="nc" id="L2560">                      document.statsData.get(segmentDocId + lrc.docBase).add(new long[] { postingsEnum.freq() }, 1);</span>
                      // register list
<span class="nc bnc" id="L2562" title="All 2 branches missed.">                      if (document.statsList != null) {</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">                        if (automatonMap != null) {</span>
                          MtasDataCollector&lt;?, ?&gt; dataCollector;
                          MtasDataCollector&lt;?, ?&gt; subSataCollector;
<span class="nc bnc" id="L2566" title="All 2 branches missed.">                          for (Entry&lt;String, ByteRunAutomaton&gt; entry : byteRunAutomatonMap.entrySet()) {</span>
<span class="nc" id="L2567">                            ByteRunAutomaton bra = entry.getValue();</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                            if (bra.run(term.bytes, term.offset, term.length)) {</span>
<span class="nc" id="L2569">                              dataCollector = document.statsList.get(segmentDocId + lrc.docBase);</span>
<span class="nc" id="L2570">                              subSataCollector = dataCollector.add(entry.getKey(), new long[] { postingsEnum.freq() },</span>
                                  1);
<span class="nc bnc" id="L2572" title="All 4 branches missed.">                              if (document.listExpand &amp;&amp; subSataCollector != null) {</span>
<span class="nc bnc" id="L2573" title="All 2 branches missed.">                                if (!initialised.contains(subSataCollector)) {</span>
<span class="nc" id="L2574">                                  subSataCollector.initNewList(initBaseSize);</span>
<span class="nc" id="L2575">                                  initialised.add(subSataCollector);</span>
                                }
<span class="nc" id="L2577">                                subSataCollector.add(MtasToken.getPostfixFromValue(term),</span>
<span class="nc" id="L2578">                                    new long[] { postingsEnum.freq() }, 1);</span>
                              }
                            }
<span class="nc" id="L2581">                          }</span>
                        } else {
<span class="nc" id="L2583">                          document.statsList.get(segmentDocId + lrc.docBase).add(MtasToken.getPostfixFromValue(term),</span>
<span class="nc" id="L2584">                              new long[] { postingsEnum.freq() }, 1);</span>
                        }
                      }
                    }
<span class="nc" id="L2588">                  }</span>
                }
<span class="nc" id="L2590">              }</span>
              // close
<span class="nc bnc" id="L2592" title="All 2 branches missed.">              for (MtasDataCollector&lt;?, ?&gt; item : initialised) {</span>
<span class="nc" id="L2593">                item.closeNewList();</span>
<span class="nc" id="L2594">              }</span>
<span class="nc" id="L2595">              initialised.clear();</span>
            }
<span class="nc" id="L2597">          }</span>
<span class="nc" id="L2598">        }</span>
      }
    }
<span class="nc" id="L2601">  }</span>

  /**
   * Creates the kwic.
   *
   * @param kwicList
   *          the kwic list
   * @param spansMatchData
   *          the spans match data
   * @param docList
   *          the doc list
   * @param field
   *          the field
   * @param docBase
   *          the doc base
   * @param uniqueKeyField
   *          the unique key field
   * @param mtasCodecInfo
   *          the mtas codec info
   * @param searcher
   *          the searcher
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createKwic(List&lt;ComponentKwic&gt; kwicList,
      Map&lt;MtasSpanQuery, Map&lt;Integer, List&lt;Match&gt;&gt;&gt; spansMatchData, List&lt;Integer&gt; docList, String field, int docBase,
      String uniqueKeyField, CodecInfo mtasCodecInfo, IndexSearcher searcher) throws IOException {
<span class="nc bnc" id="L2628" title="All 2 branches missed.">    if (kwicList != null) {</span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">      for (ComponentKwic kwic : kwicList) {</span>
<span class="nc" id="L2630">        Map&lt;Integer, List&lt;Match&gt;&gt; matchData = spansMatchData.get(kwic.query);</span>
        List&lt;Match&gt; matchList;
<span class="nc bnc" id="L2632" title="All 2 branches missed.">        if (kwic.output.equals(ComponentKwic.KWIC_OUTPUT_HIT)) {</span>
<span class="nc bnc" id="L2633" title="All 2 branches missed.">          for (int docId : docList) {</span>
<span class="nc bnc" id="L2634" title="All 4 branches missed.">            if (matchData != null &amp;&amp; (matchList = matchData.get(docId)) != null) {</span>
              // get unique id
<span class="nc" id="L2636">              Document doc = searcher.doc(docId, new HashSet&lt;String&gt;(Arrays.asList(uniqueKeyField)));</span>
<span class="nc" id="L2637">              IndexableField indxfld = doc.getField(uniqueKeyField);</span>
              // get other doc info
<span class="nc bnc" id="L2639" title="All 2 branches missed.">              if (indxfld != null) {</span>
<span class="nc" id="L2640">                kwic.uniqueKey.put(docId, indxfld.stringValue());</span>
              }
<span class="nc" id="L2642">              kwic.subTotal.put(docId, matchList.size());</span>
<span class="nc" id="L2643">              IndexDoc mDoc = mtasCodecInfo.getDoc(field, (docId - docBase));</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">              if (mDoc != null) {</span>
<span class="nc" id="L2645">                kwic.minPosition.put(docId, mDoc.minPosition);</span>
<span class="nc" id="L2646">                kwic.maxPosition.put(docId, mDoc.maxPosition);</span>
              }
              // kwiclist
<span class="nc" id="L2649">              List&lt;KwicHit&gt; kwicItemList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2650">              int number = 0;</span>
<span class="nc bnc" id="L2651" title="All 2 branches missed.">              for (Match m : matchList) {</span>
<span class="nc bnc" id="L2652" title="All 4 branches missed.">                if (kwic.number != null &amp;&amp; number &gt;= (kwic.start + kwic.number)) {</span>
<span class="nc" id="L2653">                  break;</span>
<span class="nc bnc" id="L2654" title="All 4 branches missed.">                } else if (kwic.pageStart != null &amp;&amp; kwic.pageEnd != null) {</span>
<span class="nc bnc" id="L2655" title="All 4 branches missed.">                  if ((m.endPosition - 1) &lt; kwic.pageStart || m.startPosition &gt; kwic.pageEnd) {</span>
<span class="nc" id="L2656">                    continue;</span>
                  }
                }
<span class="nc bnc" id="L2659" title="All 2 branches missed.">                if (number &gt;= kwic.start) {</span>
<span class="nc" id="L2660">                  int startPosition = m.startPosition;</span>
<span class="nc" id="L2661">                  int endPosition = m.endPosition - 1;</span>
<span class="nc" id="L2662">                  List&lt;MtasTreeHit&lt;String&gt;&gt; terms = mtasCodecInfo.getPositionedTermsByPrefixesAndPositionRange(field,</span>
<span class="nc" id="L2663">                      (docId - docBase), kwic.prefixes, Math.max(mDoc.minPosition, startPosition - kwic.left),</span>
<span class="nc" id="L2664">                      Math.min(mDoc.maxPosition, endPosition + kwic.right));</span>
                  // construct hit
<span class="nc" id="L2666">                  Map&lt;Integer, List&lt;String&gt;&gt; kwicListHits = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2667">                  for (int position = Math.max(mDoc.minPosition, startPosition - kwic.left); position &lt;= Math</span>
<span class="nc bnc" id="L2668" title="All 2 branches missed.">                      .min(mDoc.maxPosition, endPosition + kwic.right); position++) {</span>
<span class="nc" id="L2669">                    kwicListHits.put(position, new ArrayList&lt;String&gt;());</span>
                  }
                  List&lt;String&gt; termList;
<span class="nc bnc" id="L2672" title="All 2 branches missed.">                  for (MtasTreeHit&lt;String&gt; term : terms) {</span>
<span class="nc" id="L2673">                    for (int position = Math.max((startPosition - kwic.left), term.startPosition); position &lt;= Math</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">                        .min((endPosition + kwic.right), term.endPosition); position++) {</span>
<span class="nc" id="L2675">                      termList = kwicListHits.get(position);</span>
<span class="nc" id="L2676">                      termList.add(term.data);</span>
                    }
<span class="nc" id="L2678">                  }</span>
<span class="nc" id="L2679">                  kwicItemList.add(new KwicHit(m, kwicListHits));</span>
                }
<span class="nc" id="L2681">                number++;</span>
<span class="nc" id="L2682">              }</span>
<span class="nc" id="L2683">              kwic.hits.put(docId, kwicItemList);</span>
            }
<span class="nc" id="L2685">          }</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">        } else if (kwic.output.equals(ComponentKwic.KWIC_OUTPUT_TOKEN)) {</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">          for (int docId : docList) {</span>
<span class="nc bnc" id="L2688" title="All 4 branches missed.">            if (matchData != null &amp;&amp; (matchList = matchData.get(docId)) != null) {</span>
              // get unique id
<span class="nc" id="L2690">              Document doc = searcher.doc(docId, new HashSet&lt;String&gt;(Arrays.asList(uniqueKeyField)));</span>
              // get other doc info
<span class="nc" id="L2692">              IndexableField indxfld = doc.getField(uniqueKeyField);</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">              if (indxfld != null) {</span>
<span class="nc" id="L2694">                kwic.uniqueKey.put(docId, indxfld.stringValue());</span>
              }
<span class="nc" id="L2696">              kwic.subTotal.put(docId, matchList.size());</span>
<span class="nc" id="L2697">              IndexDoc mDoc = mtasCodecInfo.getDoc(field, (docId - docBase));</span>
<span class="nc bnc" id="L2698" title="All 2 branches missed.">              if (mDoc != null) {</span>
<span class="nc" id="L2699">                kwic.minPosition.put(docId, mDoc.minPosition);</span>
<span class="nc" id="L2700">                kwic.maxPosition.put(docId, mDoc.maxPosition);</span>
<span class="nc" id="L2701">                List&lt;KwicToken&gt; kwicItemList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2702">                int number = 0;</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">                for (Match m : matchList) {</span>
<span class="nc bnc" id="L2704" title="All 4 branches missed.">                  if (kwic.number != null &amp;&amp; number &gt;= (kwic.start + kwic.number)) {</span>
<span class="nc" id="L2705">                    break;</span>
<span class="nc bnc" id="L2706" title="All 4 branches missed.">                  } else if (kwic.pageStart != null &amp;&amp; kwic.pageEnd != null) {</span>
<span class="nc bnc" id="L2707" title="All 4 branches missed.">                    if ((m.endPosition - 1) &lt; kwic.pageStart || m.startPosition &gt; kwic.pageEnd) {</span>
<span class="nc" id="L2708">                      continue;</span>
                    }
                  }
<span class="nc bnc" id="L2711" title="All 2 branches missed.">                  if (number &gt;= kwic.start) {</span>
<span class="nc" id="L2712">                    int startPosition = m.startPosition;</span>
<span class="nc" id="L2713">                    int endPosition = m.endPosition - 1;</span>
                    List&lt;MtasTokenString&gt; tokens;
<span class="nc" id="L2715">                    tokens = mtasCodecInfo.getPrefixFilteredObjectsByPositions(field, (docId - docBase), kwic.prefixes,</span>
<span class="nc" id="L2716">                        Math.max(mDoc.minPosition, startPosition - kwic.left),</span>
<span class="nc" id="L2717">                        Math.min(mDoc.maxPosition, endPosition + kwic.right));</span>
<span class="nc" id="L2718">                    kwicItemList.add(new KwicToken(m, tokens));</span>
                  }
<span class="nc" id="L2720">                  number++;</span>
<span class="nc" id="L2721">                }</span>
<span class="nc" id="L2722">                kwic.tokens.put(docId, kwicItemList);</span>
              }
            }
<span class="nc" id="L2725">          }</span>
        }
<span class="nc" id="L2727">      }</span>
    }
<span class="nc" id="L2729">  }</span>

  /**
   * Creates the facet base.
   *
   * @param cf
   *          the cf
   * @param level
   *          the level
   * @param dataCollector
   *          the data collector
   * @param positionsData
   *          the positions data
   * @param spansNumberData
   *          the spans number data
   * @param facetData
   *          the facet data
   * @param docSet
   *          the doc set
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createFacetBase(ComponentFacet cf, int level, MtasDataCollector&lt;?, ?&gt; dataCollector,
      Map&lt;Integer, Integer&gt; positionsData, Map&lt;MtasSpanQuery, Map&lt;Integer, Integer&gt;&gt; spansNumberData,
      Map&lt;String, SortedMap&lt;String, int[]&gt;&gt; facetData, Integer[] docSet) throws IOException {
<span class="nc bnc" id="L2754" title="All 2 branches missed.">    for (MtasFunctionParserFunction function : cf.baseFunctionParserFunctions[level]) {</span>
<span class="nc bnc" id="L2755" title="All 2 branches missed.">      if (function.needArgumentsNumber() &gt; cf.spanQueries.length) {</span>
<span class="nc" id="L2756">        throw new IOException(</span>
<span class="nc" id="L2757">            &quot;function &quot; + function + &quot; expects (at least) &quot; + function.needArgumentsNumber() + &quot; queries&quot;);</span>
      }
    }
<span class="nc" id="L2760">    Map&lt;String, int[]&gt; list = facetData.get(cf.baseFields[level]);</span>
<span class="nc bnc" id="L2761" title="All 2 branches missed.">    if (dataCollector != null) {</span>
<span class="nc" id="L2762">      MtasDataCollector&lt;?, ?&gt; subDataCollector = null;</span>
<span class="nc" id="L2763">      dataCollector.initNewList(1);</span>
<span class="nc bnc" id="L2764" title="All 2 branches missed.">      if (cf.baseFunctionList[level] != null) {</span>
        SubComponentFunction[] tmpList;
<span class="nc bnc" id="L2766" title="All 2 branches missed.">        if (!cf.baseFunctionList[level].containsKey(dataCollector)) {</span>
<span class="nc" id="L2767">          tmpList = new SubComponentFunction[cf.baseFunctionParserFunctions[level].length];</span>
<span class="nc" id="L2768">          cf.baseFunctionList[level].put(dataCollector, tmpList);</span>
<span class="nc bnc" id="L2769" title="All 2 branches missed.">          for (int i = 0; i &lt; cf.baseFunctionParserFunctions[level].length; i++) {</span>
            try {
<span class="nc" id="L2771">              tmpList[i] = new SubComponentFunction(DataCollector.COLLECTOR_TYPE_LIST, cf.baseFunctionKeys[level][i],</span>
<span class="nc" id="L2772">                  cf.baseFunctionTypes[level][i], cf.baseFunctionParserFunctions[level][i], null, null, 0,</span>
<span class="nc" id="L2773">                  Integer.MAX_VALUE, null, null);</span>

<span class="nc" id="L2775">            } catch (ParseException e) {</span>
<span class="nc" id="L2776">              throw new IOException(e.getMessage());</span>
<span class="nc" id="L2777">            }</span>
          }
        } else {
<span class="nc" id="L2780">          tmpList = cf.baseFunctionList[level].get(dataCollector);</span>
        }
<span class="nc bnc" id="L2782" title="All 2 branches missed.">        for (SubComponentFunction function : tmpList) {</span>
<span class="nc" id="L2783">          function.dataCollector.initNewList(1);</span>
        }
      }
      // check type
<span class="nc bnc" id="L2787" title="All 2 branches missed.">      if (dataCollector.getCollectorType().equals(DataCollector.COLLECTOR_TYPE_LIST)) {</span>
<span class="nc" id="L2788">        dataCollector.setWithTotal();</span>
        // only if documents and facets
<span class="nc bnc" id="L2790" title="All 4 branches missed.">        if (docSet.length &gt; 0 &amp;&amp; list.size() &gt; 0) {</span>
<span class="nc" id="L2791">          HashMap&lt;String, Integer[]&gt; docLists = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2792">          HashMap&lt;String, String&gt; groupedKeys = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2793">          boolean documentsInFacets = false;</span>
          // compute intersections
<span class="nc bnc" id="L2795" title="All 2 branches missed.">          for (Entry&lt;String, int[]&gt; entry : list.entrySet()) {</span>
            // fill grouped keys
<span class="nc bnc" id="L2797" title="All 2 branches missed.">            if (!groupedKeys.containsKey(entry.getKey())) {</span>
<span class="nc" id="L2798">              groupedKeys.put(entry.getKey(),</span>
<span class="nc" id="L2799">                  groupedKeyName(entry.getKey(), cf.baseRangeSizes[level], cf.baseRangeBases[level]));</span>
            }
            // intersect docSet with docList
<span class="nc" id="L2802">            Integer[] docList = intersectedDocList(entry.getValue(), docSet);</span>
<span class="nc bnc" id="L2803" title="All 4 branches missed.">            if (docList != null &amp;&amp; docList.length &gt; 0) {</span>
<span class="nc" id="L2804">              documentsInFacets = true;</span>
            }
            // update docLists
<span class="nc bnc" id="L2807" title="All 2 branches missed.">            if (docLists.containsKey(groupedKeys.get(entry.getKey()))) {</span>
<span class="nc" id="L2808">              docLists.put(groupedKeys.get(entry.getKey()),</span>
<span class="nc" id="L2809">                  mergeDocLists(docLists.get(groupedKeys.get(entry.getKey())), docList));</span>
            } else {
<span class="nc" id="L2811">              docLists.put(groupedKeys.get(entry.getKey()), docList);</span>
            }
<span class="nc" id="L2813">          }</span>
          // compute stats for each key
<span class="nc bnc" id="L2815" title="All 2 branches missed.">          if (documentsInFacets) {</span>
<span class="nc" id="L2816">            Map&lt;Integer, long[]&gt; args = computeArguments(spansNumberData, cf.spanQueries, docSet);</span>
<span class="nc bnc" id="L2817" title="All 2 branches missed.">            if (cf.baseDataTypes[level].equals(CodecUtil.DATA_TYPE_LONG)) {</span>
              // check functions
<span class="nc" id="L2819">              boolean applySumRule = false;</span>
<span class="nc bnc" id="L2820" title="All 8 branches missed.">              if (cf.baseStatsTypes[level].equals(CodecUtil.STATS_BASIC) &amp;&amp; cf.baseParsers[level].sumRule()</span>
                  &amp;&amp; (cf.baseMinimumLongs[level] == null) &amp;&amp; (cf.baseMaximumLongs[level] == null)) {
<span class="nc" id="L2822">                applySumRule = true;</span>
<span class="nc bnc" id="L2823" title="All 2 branches missed.">                if (cf.baseFunctionList[level].get(dataCollector) != null) {</span>
<span class="nc bnc" id="L2824" title="All 2 branches missed.">                  for (SubComponentFunction function : cf.baseFunctionList[level].get(dataCollector)) {</span>
<span class="nc bnc" id="L2825" title="All 4 branches missed.">                    if (!function.statsType.equals(CodecUtil.STATS_BASIC) || !function.parserFunction.sumRule()</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">                        || function.parserFunction.needPositions()) {</span>
<span class="nc" id="L2827">                      applySumRule = false;</span>
<span class="nc" id="L2828">                      break;</span>
                    }
                  }
                }
              }
<span class="nc bnc" id="L2833" title="All 2 branches missed.">              if (applySumRule) {</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">                for (String key : new LinkedHashSet&lt;String&gt;(groupedKeys.values())) {</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">                  if (docLists.get(key).length &gt; 0) {</span>
                    // initialise
<span class="nc" id="L2837">                    Integer[] subDocSet = docLists.get(key);</span>
<span class="nc" id="L2838">                    int length = cf.baseParsers[level].needArgumentsNumber();</span>
<span class="nc" id="L2839">                    long[] valueSum = new long[length];</span>
<span class="nc" id="L2840">                    long valuePositions = 0;</span>
                    // collect
<span class="nc bnc" id="L2842" title="All 2 branches missed.">                    if (subDocSet.length &gt; 0) {</span>
                      long[] tmpArgs;
<span class="nc bnc" id="L2844" title="All 2 branches missed.">                      for (int docId : subDocSet) {</span>
<span class="nc" id="L2845">                        tmpArgs = args.get(docId);</span>
<span class="nc bnc" id="L2846" title="All 4 branches missed.">                        if (positionsData != null &amp;&amp; positionsData.containsKey(docId)</span>
<span class="nc bnc" id="L2847" title="All 2 branches missed.">                            &amp;&amp; positionsData.get(docId) != null) {</span>
<span class="nc" id="L2848">                          valuePositions += positionsData.get(docId).longValue();</span>
                        }
<span class="nc bnc" id="L2850" title="All 2 branches missed.">                        if (tmpArgs != null) {</span>
<span class="nc bnc" id="L2851" title="All 2 branches missed.">                          for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L2852">                            valueSum[i] += tmpArgs[i];</span>
                          }
                        }
                      }
                      long value;
                      try {
<span class="nc" id="L2858">                        value = cf.baseParsers[level].getValueLong(valueSum, valuePositions);</span>
<span class="nc" id="L2859">                        subDataCollector = dataCollector.add(key, value, subDocSet.length);</span>
<span class="nc" id="L2860">                      } catch (IOException e) {</span>
<span class="nc" id="L2861">                        log.debug(e);</span>
<span class="nc" id="L2862">                        dataCollector.error(key, e.getMessage(), 1);</span>
<span class="nc" id="L2863">                        subDataCollector = null;</span>
<span class="nc" id="L2864">                      }</span>
<span class="nc bnc" id="L2865" title="All 4 branches missed.">                      if (cf.baseFunctionList[level] != null &amp;&amp; cf.baseFunctionList[level].containsKey(dataCollector)) {</span>
<span class="nc" id="L2866">                        SubComponentFunction[] functionList = cf.baseFunctionList[level].get(dataCollector);</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">                        for (SubComponentFunction function : functionList) {</span>
<span class="nc bnc" id="L2868" title="All 2 branches missed.">                          if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
                            try {
<span class="nc" id="L2870">                              long valueLong = function.parserFunction.getValueLong(valueSum, valuePositions);</span>
<span class="nc" id="L2871">                              function.dataCollector.add(key, valueLong, subDocSet.length);</span>
<span class="nc" id="L2872">                            } catch (IOException e) {</span>
<span class="nc" id="L2873">                              log.debug(e);</span>
<span class="nc" id="L2874">                              function.dataCollector.error(key, e.getMessage(), 1);</span>
<span class="nc" id="L2875">                            }</span>
<span class="nc bnc" id="L2876" title="All 2 branches missed.">                          } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
                            try {
<span class="nc" id="L2878">                              double valueDouble = function.parserFunction.getValueDouble(valueSum, valuePositions);</span>
<span class="nc" id="L2879">                              function.dataCollector.add(key, valueDouble, subDocSet.length);</span>
<span class="nc" id="L2880">                            } catch (IOException e) {</span>
<span class="nc" id="L2881">                              log.debug(e);</span>
<span class="nc" id="L2882">                              function.dataCollector.error(key, e.getMessage(), 1);</span>
<span class="nc" id="L2883">                            }</span>
                          }
                        }
                      }
<span class="nc bnc" id="L2887" title="All 2 branches missed.">                      if (subDataCollector != null) {</span>
<span class="nc" id="L2888">                        createFacetBase(cf, (level + 1), subDataCollector, positionsData, spansNumberData, facetData,</span>
                            subDocSet);
                      }
                    }
                  }
<span class="nc" id="L2893">                }</span>
              } else {
<span class="nc bnc" id="L2895" title="All 2 branches missed.">                for (String key : new LinkedHashSet&lt;String&gt;(groupedKeys.values())) {</span>
<span class="nc bnc" id="L2896" title="All 2 branches missed.">                  if (docLists.get(key).length &gt; 0) {</span>
                    // initialise
<span class="nc" id="L2898">                    Integer[] subDocSet = docLists.get(key);</span>
                    // collect
<span class="nc bnc" id="L2900" title="All 4 branches missed.">                    if (subDocSet.length &gt; 0 &amp;&amp; cf.baseDataTypes[level].equals(CodecUtil.DATA_TYPE_LONG)) {</span>
                      // check for functions
<span class="nc" id="L2902">                      long[][] functionValuesLong = null;</span>
<span class="nc" id="L2903">                      double[][] functionValuesDouble = null;</span>
<span class="nc" id="L2904">                      int[] functionNumber = null;</span>
<span class="nc" id="L2905">                      SubComponentFunction[] functionList = null;</span>
<span class="nc bnc" id="L2906" title="All 4 branches missed.">                      if (cf.baseFunctionList[level] != null &amp;&amp; cf.baseFunctionList[level].containsKey(dataCollector)) {</span>
<span class="nc" id="L2907">                        functionList = cf.baseFunctionList[level].get(dataCollector);</span>
<span class="nc" id="L2908">                        functionValuesLong = new long[functionList.length][];</span>
<span class="nc" id="L2909">                        functionValuesDouble = new double[functionList.length][];</span>
<span class="nc" id="L2910">                        functionNumber = new int[functionList.length];</span>
<span class="nc bnc" id="L2911" title="All 2 branches missed.">                        for (int i = 0; i &lt; functionList.length; i++) {</span>
<span class="nc" id="L2912">                          functionValuesLong[i] = new long[subDocSet.length];</span>
<span class="nc" id="L2913">                          functionValuesDouble[i] = new double[subDocSet.length];</span>
                        }
                      }
                      // check main
<span class="nc" id="L2917">                      int number = 0;</span>
<span class="nc" id="L2918">                      Integer[] restrictedSubDocSet = new Integer[subDocSet.length];</span>
<span class="nc" id="L2919">                      long[] values = new long[subDocSet.length];</span>
<span class="nc bnc" id="L2920" title="All 2 branches missed.">                      for (int docId : subDocSet) {</span>
<span class="nc" id="L2921">                        long[] tmpArgs = args.get(docId);</span>
<span class="nc bnc" id="L2922" title="All 2 branches missed.">                        int tmpPositions = (positionsData == null) ? 0</span>
<span class="nc bnc" id="L2923" title="All 2 branches missed.">                            : (positionsData.get(docId) == null ? 0 : positionsData.get(docId));</span>
<span class="nc" id="L2924">                        long value = cf.baseParsers[level].getValueLong(tmpArgs, tmpPositions);</span>
<span class="nc bnc" id="L2925" title="All 6 branches missed.">                        if ((cf.baseMinimumLongs[level] == null || value &gt;= cf.baseMinimumLongs[level])</span>
<span class="nc bnc" id="L2926" title="All 2 branches missed.">                            &amp;&amp; (cf.baseMaximumLongs[level] == null || value &lt;= cf.baseMaximumLongs[level])) {</span>
<span class="nc" id="L2927">                          values[number] = value;</span>
<span class="nc" id="L2928">                          restrictedSubDocSet[number] = docId;</span>
<span class="nc" id="L2929">                          number++;</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">                          if (functionList != null) {</span>
<span class="nc bnc" id="L2931" title="All 2 branches missed.">                            for (int i = 0; i &lt; functionList.length; i++) {</span>
<span class="nc" id="L2932">                              SubComponentFunction function = functionList[i];</span>
<span class="nc bnc" id="L2933" title="All 2 branches missed.">                              if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
                                try {
<span class="nc" id="L2935">                                  functionValuesLong[i][functionNumber[i]] = function.parserFunction</span>
<span class="nc" id="L2936">                                      .getValueLong(tmpArgs, tmpPositions);</span>
<span class="nc" id="L2937">                                  functionNumber[i]++;</span>
<span class="nc" id="L2938">                                } catch (IOException e) {</span>
<span class="nc" id="L2939">                                  log.debug(e);</span>
<span class="nc" id="L2940">                                  function.dataCollector.error(key, e.getMessage(), 1);</span>
<span class="nc" id="L2941">                                }</span>
<span class="nc bnc" id="L2942" title="All 2 branches missed.">                              } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
                                try {
<span class="nc" id="L2944">                                  functionValuesDouble[i][functionNumber[i]] = function.parserFunction</span>
<span class="nc" id="L2945">                                      .getValueDouble(tmpArgs, tmpPositions);</span>
<span class="nc" id="L2946">                                  functionNumber[i]++;</span>
<span class="nc" id="L2947">                                } catch (IOException e) {</span>
<span class="nc" id="L2948">                                  log.debug(e);</span>
<span class="nc" id="L2949">                                  function.dataCollector.error(key, e.getMessage(), 1);</span>
<span class="nc" id="L2950">                                }</span>
                              }
                            }
                          }
                        }
                      }
<span class="nc bnc" id="L2956" title="All 2 branches missed.">                      if (number &gt; 0) {</span>
<span class="nc" id="L2957">                        subDataCollector = dataCollector.add(key, values, number);</span>
<span class="nc bnc" id="L2958" title="All 2 branches missed.">                        if (cf.baseFunctionList[level] != null</span>
<span class="nc bnc" id="L2959" title="All 2 branches missed.">                            &amp;&amp; cf.baseFunctionList[level].containsKey(dataCollector)) {</span>
<span class="nc bnc" id="L2960" title="All 2 branches missed.">                          for (int i = 0; i &lt; functionList.length; i++) {</span>
<span class="nc" id="L2961">                            SubComponentFunction function = functionList[i];</span>
<span class="nc bnc" id="L2962" title="All 2 branches missed.">                            if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="nc" id="L2963">                              function.dataCollector.add(key, functionValuesLong[i], functionNumber[i]);</span>
<span class="nc bnc" id="L2964" title="All 2 branches missed.">                            } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L2965">                              function.dataCollector.add(key, functionValuesDouble[i], functionNumber[i]);</span>
                            }
                          }
                        }
<span class="nc bnc" id="L2969" title="All 2 branches missed.">                        if (subDataCollector != null) {</span>
<span class="nc" id="L2970">                          createFacetBase(cf, (level + 1), subDataCollector, positionsData, spansNumberData, facetData,</span>
<span class="nc" id="L2971">                              Arrays.copyOfRange(restrictedSubDocSet, 0, number));</span>
                        }
                      }
                    }
                  }
<span class="nc" id="L2976">                }</span>
              }
<span class="nc" id="L2978">            } else {</span>
<span class="nc" id="L2979">              throw new IOException(&quot;unexpected dataType &quot; + cf.baseDataTypes[level]);</span>
            }
          }
<span class="nc" id="L2982">        }</span>
      } else {
<span class="nc" id="L2984">        throw new IOException(&quot;unexpected type &quot; + dataCollector.getCollectorType());</span>
      }
<span class="nc" id="L2986">      dataCollector.closeNewList();</span>
<span class="nc bnc" id="L2987" title="All 4 branches missed.">      if (cf.baseFunctionList[level] != null &amp;&amp; cf.baseFunctionList[level].containsKey(dataCollector)) {</span>
<span class="nc" id="L2988">        SubComponentFunction[] tmpList = cf.baseFunctionList[level].get(dataCollector);</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">        for (SubComponentFunction function : tmpList) {</span>
<span class="nc" id="L2990">          function.dataCollector.closeNewList();</span>
        }
      }
    }

<span class="nc" id="L2995">  }</span>

  /**
   * Grouped key name.
   *
   * @param key
   *          the key
   * @param baseRangeSize
   *          the base range size
   * @param baseRangeBase
   *          the base range base
   * @return the string
   */
  private static String groupedKeyName(String key, Double baseRangeSize, Double baseRangeBase) {
<span class="nc" id="L3009">    final double precision = 0.000001;</span>
<span class="nc bnc" id="L3010" title="All 4 branches missed.">    if (baseRangeSize == null || baseRangeSize &lt;= 0) {</span>
<span class="nc" id="L3011">      return key;</span>
    } else {
      Double doubleKey;
      Double doubleBase;
      Double doubleNumber;
      Double doubleStart;
      Double doubleEnd;
      try {
<span class="nc" id="L3019">        doubleKey = Double.parseDouble(key);</span>
<span class="nc bnc" id="L3020" title="All 2 branches missed.">        doubleBase = baseRangeBase != null ? baseRangeBase : 0;</span>
<span class="nc" id="L3021">        doubleNumber = Math.floor((doubleKey - doubleBase) / baseRangeSize);</span>
<span class="nc" id="L3022">        doubleStart = doubleBase + doubleNumber * baseRangeSize;</span>
<span class="nc" id="L3023">        doubleEnd = doubleStart + baseRangeSize;</span>
<span class="nc" id="L3024">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L3025">        return key;</span>
<span class="nc" id="L3026">      }</span>
      // integer
<span class="nc bnc" id="L3028" title="All 2 branches missed.">      if (Math.abs(baseRangeSize - Math.floor(baseRangeSize)) &lt; precision</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">          &amp;&amp; Math.abs(doubleBase - Math.floor(doubleBase)) &lt; precision) {</span>
        try {
<span class="nc bnc" id="L3031" title="All 2 branches missed.">          if (baseRangeSize &gt; 1) {</span>
<span class="nc" id="L3032">            return String.format(&quot;%.0f&quot;, doubleStart) + &quot;-&quot; + String.format(&quot;%.0f&quot;, doubleEnd - 1);</span>
          } else {
<span class="nc" id="L3034">            return String.format(&quot;%.0f&quot;, doubleStart);</span>
          }
<span class="nc" id="L3036">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L3037">          return key;</span>
        }
      } else {
<span class="nc" id="L3040">        return &quot;[&quot; + doubleStart + &quot;,&quot; + doubleEnd + &quot;)&quot;;</span>
      }
    }
  }

  /**
   * Merge doc lists.
   *
   * @param a
   *          the a
   * @param b
   *          the b
   * @return the integer[]
   */
  private static Integer[] mergeDocLists(Integer[] a, Integer[] b) {
<span class="nc" id="L3055">    Integer[] answer = new Integer[a.length + b.length];</span>
<span class="nc" id="L3056">    int i = 0;</span>
<span class="nc" id="L3057">    int j = 0;</span>
<span class="nc" id="L3058">    int k = 0;</span>
    Integer tmp;
<span class="nc bnc" id="L3060" title="All 4 branches missed.">    while (i &lt; a.length &amp;&amp; j &lt; b.length) {</span>
<span class="nc bnc" id="L3061" title="All 2 branches missed.">      tmp = a[i] &lt; b[j] ? a[i++] : b[j++];</span>
<span class="nc bnc" id="L3062" title="All 4 branches missed.">      for (; i &lt; a.length &amp;&amp; a[i].equals(tmp); i++)</span>
        ;
<span class="nc bnc" id="L3064" title="All 4 branches missed.">      for (; j &lt; b.length &amp;&amp; b[j].equals(tmp); j++)</span>
        ;
<span class="nc" id="L3066">      answer[k++] = tmp;</span>
    }
<span class="nc bnc" id="L3068" title="All 2 branches missed.">    while (i &lt; a.length) {</span>
<span class="nc" id="L3069">      tmp = a[i++];</span>
<span class="nc bnc" id="L3070" title="All 4 branches missed.">      for (; i &lt; a.length &amp;&amp; a[i].equals(tmp); i++)</span>
        ;
<span class="nc" id="L3072">      answer[k++] = tmp;</span>
    }
<span class="nc bnc" id="L3074" title="All 2 branches missed.">    while (j &lt; b.length) {</span>
<span class="nc" id="L3075">      tmp = b[j++];</span>
<span class="nc bnc" id="L3076" title="All 4 branches missed.">      for (; j &lt; b.length &amp;&amp; b[j].equals(tmp); j++)</span>
        ;
<span class="nc" id="L3078">      answer[k++] = tmp;</span>
    }
<span class="nc" id="L3080">    return Arrays.copyOf(answer, k);</span>
  }

  /**
   * Creates the facet.
   *
   * @param facetList
   *          the facet list
   * @param positionsData
   *          the positions data
   * @param spansNumberData
   *          the spans number data
   * @param facetData
   *          the facet data
   * @param docSet
   *          the doc set
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createFacet(List&lt;ComponentFacet&gt; facetList, Map&lt;Integer, Integer&gt; positionsData,
      Map&lt;MtasSpanQuery, Map&lt;Integer, Integer&gt;&gt; spansNumberData, Map&lt;String, SortedMap&lt;String, int[]&gt;&gt; facetData,
      List&lt;Integer&gt; docSet) throws IOException {

<span class="nc bnc" id="L3103" title="All 2 branches missed.">    if (facetList != null) {</span>
<span class="nc bnc" id="L3104" title="All 2 branches missed.">      for (ComponentFacet cf : facetList) {</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">        if (cf.baseFields.length &gt; 0) {</span>
<span class="nc" id="L3106">          createFacetBase(cf, 0, cf.dataCollector, positionsData, spansNumberData, facetData,</span>
<span class="nc" id="L3107">              docSet.toArray(new Integer[docSet.size()]));</span>
        }
<span class="nc" id="L3109">      }</span>
    }
<span class="nc" id="L3111">  }</span>

  /**
   * Creates the termvector full.
   *
   * @param termVectorList
   *          the term vector list
   * @param positionsData
   *          the positions data
   * @param docSet
   *          the doc set
   * @param t
   *          the t
   * @param r
   *          the r
   * @param lrc
   *          the lrc
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createTermvectorFull(List&lt;ComponentTermVector&gt; termVectorList,
      Map&lt;Integer, Integer&gt; positionsData, List&lt;Integer&gt; docSet, Terms t, LeafReader r, LeafReaderContext lrc)
      throws IOException {
<span class="pc bpc" id="L3134" title="1 of 2 branches missed.">    if (t != null) {</span>
      BytesRef term;
      TermsEnum termsEnum;
<span class="fc" id="L3137">      PostingsEnum postingsEnum = null;</span>
<span class="fc" id="L3138">      String segmentName = &quot;segment&quot; + lrc.ord;</span>
<span class="fc" id="L3139">      int segmentNumber = lrc.parent.leaves().size();</span>
      // loop over termvectors
<span class="fc bfc" id="L3141" title="All 2 branches covered.">      for (ComponentTermVector termVector : termVectorList) {</span>
<span class="fc bfc" id="L3142" title="All 4 branches covered.">        if (termVector.full || termVector.list != null) {</span>
<span class="fc bfc" id="L3143" title="All 2 branches covered.">          if (termVector.full) {</span>
<span class="fc" id="L3144">            termVector.subComponentFunction.dataCollector.setWithTotal();</span>
          }
          List&lt;CompiledAutomaton&gt; listAutomata;
          Map&lt;String, Automaton&gt; automatonMap;
<span class="fc bfc" id="L3148" title="All 2 branches covered.">          if (termVector.list == null) {</span>
<span class="fc" id="L3149">            listAutomata = new ArrayList&lt;&gt;();</span>
            CompiledAutomaton compiledAutomaton;
            Automaton automaton;
<span class="pc bpc" id="L3152" title="1 of 4 branches missed.">            if ((termVector.regexp == null) || (termVector.regexp.isEmpty())) {</span>
<span class="fc" id="L3153">              RegExp re = new RegExp(termVector.prefix + MtasToken.DELIMITER + &quot;.*&quot;);</span>
<span class="fc" id="L3154">              automaton = re.toAutomaton();</span>
<span class="fc" id="L3155">            } else {</span>
<span class="fc" id="L3156">              RegExp re = new RegExp(termVector.prefix + MtasToken.DELIMITER + termVector.regexp + &quot;\u0000*&quot;);</span>
<span class="fc" id="L3157">              automaton = re.toAutomaton();</span>
            }
<span class="fc" id="L3159">            compiledAutomaton = new CompiledAutomaton(automaton);</span>
<span class="fc" id="L3160">            listAutomata.add(compiledAutomaton);</span>
<span class="fc" id="L3161">          } else {</span>
<span class="fc bfc" id="L3162" title="All 2 branches covered.">            automatonMap = MtasToken.createAutomatonMap(termVector.prefix, new ArrayList&lt;String&gt;(termVector.list),</span>
<span class="fc" id="L3163">                termVector.listRegexp ? false : true);</span>
<span class="fc" id="L3164">            listAutomata = MtasToken.createAutomata(termVector.prefix, termVector.regexp, automatonMap);</span>
          }
<span class="fc" id="L3166">          List&lt;ByteRunAutomaton&gt; ignoreByteRunAutomatonList = null;</span>
<span class="pc bpc" id="L3167" title="1 of 4 branches missed.">          if ((termVector.ignoreRegexp != null) &amp;&amp; (!termVector.ignoreRegexp.isEmpty())) {</span>
<span class="fc" id="L3168">            ignoreByteRunAutomatonList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3169">            RegExp re = new RegExp(termVector.prefix + MtasToken.DELIMITER + termVector.ignoreRegexp + &quot;\u0000*&quot;);</span>
<span class="fc" id="L3170">            ignoreByteRunAutomatonList.add(new ByteRunAutomaton(re.toAutomaton()));</span>
          }
<span class="fc bfc" id="L3172" title="All 2 branches covered.">          if (termVector.ignoreList != null) {</span>
<span class="pc bpc" id="L3173" title="1 of 2 branches missed.">            if (ignoreByteRunAutomatonList == null) {</span>
<span class="nc" id="L3174">              ignoreByteRunAutomatonList = new ArrayList&lt;&gt;();</span>
            }
<span class="pc bpc" id="L3176" title="1 of 2 branches missed.">            Map&lt;String, Automaton&gt; list = MtasToken.createAutomatonMap(termVector.prefix,</span>
<span class="fc" id="L3177">                new ArrayList&lt;String&gt;(termVector.ignoreList), termVector.ignoreListRegexp ? false : true);</span>
<span class="fc bfc" id="L3178" title="All 2 branches covered.">            for (Automaton automaton : list.values()) {</span>
<span class="fc" id="L3179">              ignoreByteRunAutomatonList.add(new ByteRunAutomaton(automaton));</span>
<span class="fc" id="L3180">            }</span>
          }
<span class="fc bfc" id="L3182" title="All 2 branches covered.">          for (CompiledAutomaton compiledAutomaton : listAutomata) {</span>
<span class="fc bfc" id="L3183" title="All 2 branches covered.">            if (!compiledAutomaton.type.equals(CompiledAutomaton.AUTOMATON_TYPE.NORMAL)) {</span>
<span class="pc bpc" id="L3184" title="1 of 2 branches missed.">              if (compiledAutomaton.type.equals(CompiledAutomaton.AUTOMATON_TYPE.NONE)) {</span>
                // do nothing
              } else {
<span class="nc" id="L3187">                throw new IOException(&quot;compiledAutomaton is &quot; + compiledAutomaton.type);</span>
              }
            } else {
<span class="fc" id="L3190">              termsEnum = t.intersect(compiledAutomaton, null);</span>
<span class="fc" id="L3191">              int initSize = Math.min((int) t.size(), 1000);</span>
<span class="fc" id="L3192">              termVector.subComponentFunction.dataCollector.initNewList(initSize, segmentName, segmentNumber,</span>
                  termVector.boundary);
<span class="fc" id="L3194">              boolean doBasic = termVector.subComponentFunction.dataCollector.getStatsType()</span>
<span class="fc" id="L3195">                  .equals(CodecUtil.STATS_BASIC);</span>
<span class="pc bpc" id="L3196" title="1 of 2 branches missed.">              if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3197" title="1 of 2 branches missed.">                for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc" id="L3198">                  function.dataCollector.initNewList(initSize);</span>
<span class="nc bnc" id="L3199" title="All 2 branches missed.">                  doBasic = doBasic</span>
<span class="nc bnc" id="L3200" title="All 4 branches missed.">                      ? (function.parserFunction.sumRule() &amp;&amp; !function.parserFunction.needPositions()</span>
<span class="nc bnc" id="L3201" title="All 2 branches missed.">                          &amp;&amp; function.dataCollector.getStatsType().equals(CodecUtil.STATS_BASIC))</span>
                      : doBasic;
<span class="nc" id="L3203">                }</span>
              }
              // only if documents
<span class="pc bpc" id="L3206" title="1 of 2 branches missed.">              if (!docSet.isEmpty()) {</span>
                int termDocId;
                boolean acceptedTerm;
                String key;
                // loop over terms
<span class="fc bfc" id="L3211" title="All 2 branches covered.">                while ((term = termsEnum.next()) != null) {</span>
<span class="pc bpc" id="L3212" title="2 of 4 branches missed.">                  if (validateTermWithStartValue(term, termVector) &amp;&amp; validateTermWithDistance(term, termVector)) {</span>
<span class="fc" id="L3213">                    termDocId = -1;</span>
<span class="fc" id="L3214">                    acceptedTerm = true;</span>
<span class="fc bfc" id="L3215" title="All 2 branches covered.">                    if (ignoreByteRunAutomatonList != null) {</span>
<span class="fc bfc" id="L3216" title="All 2 branches covered.">                      for (ByteRunAutomaton ignoreByteRunAutomaton : ignoreByteRunAutomatonList) {</span>
<span class="fc bfc" id="L3217" title="All 2 branches covered.">                        if (ignoreByteRunAutomaton.run(term.bytes, term.offset, term.length)) {</span>
<span class="fc" id="L3218">                          acceptedTerm = false;</span>
<span class="fc" id="L3219">                          break;</span>
                        }
<span class="fc" id="L3221">                      }</span>
                    }
<span class="fc bfc" id="L3223" title="All 2 branches covered.">                    if (acceptedTerm) {</span>
<span class="fc bfc" id="L3224" title="All 2 branches covered.">                      if (doBasic) {</span>
                        // compute numbers;
<span class="fc" id="L3226">                        TermvectorNumberBasic numberBasic = computeTermvectorNumberBasic(docSet, termDocId, termsEnum,</span>
                            r, lrc, postingsEnum);
                        // register
<span class="pc bpc" id="L3229" title="1 of 2 branches missed.">                        if (numberBasic.docNumber &gt; 0) {</span>
<span class="fc" id="L3230">                          long valueLong = 0;</span>
<span class="fc" id="L3231">                          key = MtasToken.getPostfixFromValue(term);</span>
                          try {
<span class="fc" id="L3233">                            valueLong = termVector.subComponentFunction.parserFunction</span>
<span class="fc" id="L3234">                                .getValueLong(numberBasic.valueSum, 1);</span>
<span class="nc" id="L3235">                          } catch (IOException e) {</span>
<span class="nc" id="L3236">                            log.debug(e);</span>
<span class="nc" id="L3237">                            termVector.subComponentFunction.dataCollector.error(MtasToken.getPostfixFromValue(term),</span>
<span class="nc" id="L3238">                                e.getMessage(),1);</span>
<span class="fc" id="L3239">                          }</span>
<span class="fc" id="L3240">                          termVector.subComponentFunction.dataCollector.add(key, valueLong, numberBasic.docNumber);</span>
<span class="pc bpc" id="L3241" title="1 of 2 branches missed.">                          if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3242" title="1 of 2 branches missed.">                            for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc bnc" id="L3243" title="All 2 branches missed.">                              if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="nc" id="L3244">                                long valueFunction = function.parserFunction.getValueLong(numberBasic.valueSum, 0);</span>
<span class="nc" id="L3245">                                function.dataCollector.add(key, valueFunction, numberBasic.docNumber);</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">                              } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L3247">                                double valueFunction = function.parserFunction.getValueDouble(numberBasic.valueSum, 0);</span>
<span class="nc" id="L3248">                                function.dataCollector.add(key, valueFunction, numberBasic.docNumber);</span>
                              }
<span class="nc" id="L3250">                            }</span>
                          }
                        }
<span class="fc" id="L3253">                      } else {</span>
<span class="fc" id="L3254">                        TermvectorNumberFull numberFull = computeTermvectorNumberFull(docSet, termDocId, termsEnum, lrc,</span>
                            postingsEnum, positionsData);
<span class="pc bpc" id="L3256" title="1 of 2 branches missed.">                        if (numberFull.docNumber &gt; 0) {</span>
<span class="fc" id="L3257">                          long[] valuesLong = new long[numberFull.docNumber];</span>
<span class="fc" id="L3258">                          key = MtasToken.getPostfixFromValue(term);</span>
<span class="fc bfc" id="L3259" title="All 2 branches covered.">                          for (int i = 0; i &lt; numberFull.docNumber; i++) {</span>
                            try {
<span class="fc" id="L3261">                              valuesLong[i] = termVector.subComponentFunction.parserFunction</span>
<span class="fc" id="L3262">                                  .getValueLong(new long[] { numberFull.args[i] }, numberFull.positions[i]);</span>
<span class="nc" id="L3263">                            } catch (IOException e) {</span>
<span class="nc" id="L3264">                              log.debug(e);</span>
<span class="nc" id="L3265">                              termVector.subComponentFunction.dataCollector.error(key, e.getMessage(), 1);</span>
<span class="fc" id="L3266">                            }</span>
                          }
<span class="fc" id="L3268">                          termVector.subComponentFunction.dataCollector.add(key, valuesLong, valuesLong.length);</span>
<span class="pc bpc" id="L3269" title="1 of 2 branches missed.">                          if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3270" title="1 of 2 branches missed.">                            for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc bnc" id="L3271" title="All 2 branches missed.">                              if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="nc" id="L3272">                                valuesLong = new long[numberFull.docNumber];</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">                                for (int i = 0; i &lt; numberFull.docNumber; i++) {</span>
                                  try {
<span class="nc" id="L3275">                                    valuesLong[i] = function.parserFunction</span>
<span class="nc" id="L3276">                                        .getValueLong(new long[] { numberFull.args[i] }, numberFull.positions[i]);</span>
<span class="nc" id="L3277">                                  } catch (IOException e) {</span>
<span class="nc" id="L3278">                                    log.debug(e);</span>
<span class="nc" id="L3279">                                    function.dataCollector.error(key, e.getMessage(), 1);</span>
<span class="nc" id="L3280">                                  }</span>
                                }
<span class="nc" id="L3282">                                function.dataCollector.add(key, valuesLong, valuesLong.length);</span>
<span class="nc bnc" id="L3283" title="All 2 branches missed.">                              } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L3284">                                double[] valuesDouble = new double[numberFull.docNumber];</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">                                for (int i = 0; i &lt; numberFull.docNumber; i++) {</span>
                                  try {
<span class="nc" id="L3287">                                    valuesDouble[i] = function.parserFunction</span>
<span class="nc" id="L3288">                                        .getValueDouble(new long[] { numberFull.args[i] }, numberFull.positions[i]);</span>
<span class="nc" id="L3289">                                  } catch (IOException e) {</span>
<span class="nc" id="L3290">                                    log.debug(e);</span>
<span class="nc" id="L3291">                                    function.dataCollector.error(key, e.getMessage(), 1);</span>
<span class="nc" id="L3292">                                  }</span>
                                }
<span class="nc" id="L3294">                                function.dataCollector.add(key, valuesDouble, valuesDouble.length);</span>
                              }
<span class="nc" id="L3296">                            }</span>
                          }
                        }

<span class="fc" id="L3300">                      }</span>
                    }
                  }
                }
              }
<span class="fc" id="L3305">              termVector.subComponentFunction.dataCollector.closeNewList();</span>
<span class="pc bpc" id="L3306" title="1 of 2 branches missed.">              if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3307" title="1 of 2 branches missed.">                for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc" id="L3308">                  function.dataCollector.closeNewList();</span>
<span class="nc" id="L3309">                }</span>
              }
            }
<span class="fc" id="L3312">          }</span>
        }
<span class="fc" id="L3314">      }</span>
    }
<span class="fc" id="L3316">  }</span>

  /**
   * Creates the termvector first round.
   *
   * @param termVectorList
   *          the term vector list
   * @param positionsData
   *          the positions data
   * @param docSet
   *          the doc set
   * @param t
   *          the t
   * @param r
   *          the r
   * @param lrc
   *          the lrc
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createTermvectorFirstRound(List&lt;ComponentTermVector&gt; termVectorList,
      Map&lt;Integer, Integer&gt; positionsData, List&lt;Integer&gt; docSet, Terms t, LeafReader r, LeafReaderContext lrc)
      throws IOException {
<span class="pc bpc" id="L3339" title="1 of 2 branches missed.">    if (t != null) {</span>
      BytesRef term;
      TermsEnum termsEnum;
<span class="fc" id="L3342">      PostingsEnum postingsEnum = null;</span>
<span class="fc" id="L3343">      String segmentName = &quot;segment&quot; + lrc.ord;</span>
<span class="fc" id="L3344">      String[] mutableKey = new String[1];</span>
<span class="fc" id="L3345">      int segmentNumber = lrc.parent.leaves().size();</span>
      // loop over termvectors
<span class="fc bfc" id="L3347" title="All 2 branches covered.">      for (ComponentTermVector termVector : termVectorList) {</span>
        CompiledAutomaton compiledAutomaton;
<span class="pc bpc" id="L3349" title="1 of 4 branches missed.">        if ((termVector.regexp == null) || (termVector.regexp.isEmpty())) {</span>
<span class="fc" id="L3350">          RegExp re = new RegExp(termVector.prefix + MtasToken.DELIMITER + &quot;.*&quot;);</span>
<span class="fc" id="L3351">          compiledAutomaton = new CompiledAutomaton(re.toAutomaton());</span>
<span class="fc" id="L3352">        } else {</span>
<span class="fc" id="L3353">          RegExp re = new RegExp(termVector.prefix + MtasToken.DELIMITER + termVector.regexp + &quot;\u0000*&quot;);</span>
<span class="fc" id="L3354">          compiledAutomaton = new CompiledAutomaton(re.toAutomaton());</span>
        }
<span class="fc" id="L3356">        List&lt;ByteRunAutomaton&gt; ignoreByteRunAutomatonList = null;</span>
<span class="pc bpc" id="L3357" title="1 of 4 branches missed.">        if ((termVector.ignoreRegexp != null) &amp;&amp; (!termVector.ignoreRegexp.isEmpty())) {</span>
<span class="fc" id="L3358">          ignoreByteRunAutomatonList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3359">          RegExp re = new RegExp(termVector.prefix + MtasToken.DELIMITER + termVector.ignoreRegexp + &quot;\u0000*&quot;);</span>
<span class="fc" id="L3360">          ignoreByteRunAutomatonList.add(new ByteRunAutomaton(re.toAutomaton()));</span>
        }
<span class="fc bfc" id="L3362" title="All 2 branches covered.">        if (termVector.ignoreList != null) {</span>
<span class="pc bpc" id="L3363" title="1 of 2 branches missed.">          if (ignoreByteRunAutomatonList == null) {</span>
<span class="nc" id="L3364">            ignoreByteRunAutomatonList = new ArrayList&lt;&gt;();</span>
          }
<span class="pc bpc" id="L3366" title="1 of 2 branches missed.">          Map&lt;String, Automaton&gt; list = MtasToken.createAutomatonMap(termVector.prefix,</span>
<span class="fc" id="L3367">              new ArrayList&lt;String&gt;(termVector.ignoreList), termVector.ignoreListRegexp ? false : true);</span>
<span class="fc bfc" id="L3368" title="All 2 branches covered.">          for (Automaton automaton : list.values()) {</span>
<span class="fc" id="L3369">            ignoreByteRunAutomatonList.add(new ByteRunAutomaton(automaton));</span>
<span class="fc" id="L3370">          }</span>
        }
<span class="fc bfc" id="L3372" title="All 4 branches covered.">        if (!termVector.full &amp;&amp; termVector.list == null) {</span>
<span class="fc" id="L3373">          termsEnum = t.intersect(compiledAutomaton, null);</span>
<span class="fc" id="L3374">          int initSize = Math.min((int) t.size(), 1000);</span>
<span class="fc" id="L3375">          termVector.subComponentFunction.dataCollector.initNewList(initSize, segmentName, segmentNumber,</span>
              termVector.boundary);
<span class="pc bpc" id="L3377" title="1 of 2 branches missed.">          if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3378" title="1 of 2 branches missed.">            for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc" id="L3379">              function.dataCollector.initNewList(initSize);</span>
<span class="nc" id="L3380">            }</span>
          }
          // only if documents
<span class="pc bpc" id="L3383" title="1 of 2 branches missed.">          if (!docSet.isEmpty()) {</span>
            int termDocId;
<span class="fc" id="L3385">            int termNumberMaximum = termVector.number;</span>
<span class="fc" id="L3386">            HashMap&lt;BytesRef, RegisterStatus&gt; computeFullList = new HashMap&lt;&gt;();</span>
            RegisterStatus registerStatus;
            // basic, don't need full values
<span class="fc bfc" id="L3389" title="All 2 branches covered.">            if (termVector.subComponentFunction.sortType.equals(CodecUtil.SORT_TERM)</span>
<span class="pc bpc" id="L3390" title="1 of 2 branches missed.">                || termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_SUM)</span>
<span class="nc bnc" id="L3391" title="All 2 branches missed.">                || termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_N)) {</span>
<span class="fc" id="L3392">              int termCounter = 0;</span>

              boolean continueAfterPreliminaryCheck;
<span class="fc" id="L3395">              boolean preliminaryCheck = false;</span>
<span class="pc bpc" id="L3396" title="2 of 4 branches missed.">              if (r.getLiveDocs() == null &amp;&amp; (docSet.size() != r.numDocs())) {</span>
<span class="nc" id="L3397">                preliminaryCheck = true;</span>
              }
              // loop over terms
              boolean acceptedTerm;
<span class="fc bfc" id="L3401" title="All 2 branches covered.">              while ((term = termsEnum.next()) != null) {</span>
<span class="pc bpc" id="L3402" title="2 of 4 branches missed.">                if (validateTermWithStartValue(term, termVector) &amp;&amp; validateTermWithDistance(term, termVector)) {</span>
<span class="fc" id="L3403">                  termDocId = -1;</span>
<span class="fc" id="L3404">                  acceptedTerm = true;</span>
<span class="fc bfc" id="L3405" title="All 2 branches covered.">                  if (ignoreByteRunAutomatonList != null) {</span>
<span class="fc bfc" id="L3406" title="All 2 branches covered.">                    for (ByteRunAutomaton ignoreByteRunAutomaton : ignoreByteRunAutomatonList) {</span>
<span class="pc bpc" id="L3407" title="1 of 2 branches missed.">                      if (ignoreByteRunAutomaton.run(term.bytes, term.offset, term.length)) {</span>
<span class="nc" id="L3408">                        acceptedTerm = false;</span>
<span class="nc" id="L3409">                        break;</span>
                      }
<span class="fc" id="L3411">                    }</span>
                  }
<span class="pc bpc" id="L3413" title="1 of 2 branches missed.">                  if (acceptedTerm) {</span>
<span class="fc" id="L3414">                    continueAfterPreliminaryCheck = true;</span>
<span class="fc" id="L3415">                    mutableKey[0] = null;</span>
<span class="pc bpc" id="L3416" title="1 of 2 branches missed.">                    if (preliminaryCheck) {</span>
                      try {
<span class="nc" id="L3418">                        TermvectorNumberBasic preliminaryNumberBasic = computeTermvectorNumberBasic(termsEnum, r);</span>
<span class="nc bnc" id="L3419" title="All 2 branches missed.">                        if (preliminaryNumberBasic.docNumber &gt; 0) {</span>
<span class="nc" id="L3420">                          continueAfterPreliminaryCheck = preliminaryRegisterValue(term, termVector,</span>
<span class="nc" id="L3421">                              preliminaryNumberBasic, termNumberMaximum, segmentNumber, mutableKey);</span>
                        } else {
<span class="nc" id="L3423">                          continueAfterPreliminaryCheck = false;</span>
                        }
<span class="nc" id="L3425">                      } catch (IOException e) {</span>
<span class="nc" id="L3426">                        log.debug(e);</span>
<span class="nc" id="L3427">                        continueAfterPreliminaryCheck = true;</span>
<span class="nc" id="L3428">                      }</span>
                    }
<span class="pc bpc" id="L3430" title="1 of 2 branches missed.">                    if (continueAfterPreliminaryCheck) {</span>
                      // compute numbers;
<span class="fc" id="L3432">                      TermvectorNumberBasic numberBasic = computeTermvectorNumberBasic(docSet, termDocId, termsEnum, r,</span>
                          lrc, postingsEnum);
                      // register
<span class="pc bpc" id="L3435" title="1 of 2 branches missed.">                      if (numberBasic.docNumber &gt; 0) {</span>
<span class="fc" id="L3436">                        termCounter++;</span>
<span class="fc" id="L3437">                        registerStatus = registerValue(term, termVector, numberBasic, termNumberMaximum, segmentNumber,</span>
                            false, mutableKey);
<span class="fc bfc" id="L3439" title="All 2 branches covered.">                        if (registerStatus != null) {</span>
<span class="fc" id="L3440">                          computeFullList.put(BytesRef.deepCopyOf(term), registerStatus);</span>
                        }
                      }
                    }
                    // stop after termCounterMaximum
<span class="fc bfc" id="L3445" title="All 2 branches covered.">                    if (termVector.subComponentFunction.sortType.equals(CodecUtil.SORT_TERM)</span>
<span class="fc bfc" id="L3446" title="All 4 branches covered.">                        &amp;&amp; termVector.subComponentFunction.sortDirection.equals(CodecUtil.SORT_ASC)</span>
                        &amp;&amp; termCounter &gt;= termNumberMaximum) {
<span class="fc" id="L3448">                      break;</span>
                    }
                  }
                }
              }
              // rerun for full
<span class="fc bfc" id="L3454" title="All 2 branches covered.">              if (computeFullList.size() &gt; 0) {</span>
<span class="fc" id="L3455">                termsEnum = t.intersect(compiledAutomaton, null);</span>
<span class="fc bfc" id="L3456" title="All 2 branches covered.">                while ((term = termsEnum.next()) != null) {</span>
<span class="pc bpc" id="L3457" title="2 of 4 branches missed.">                  if (validateTermWithStartValue(term, termVector) &amp;&amp; validateTermWithDistance(term, termVector)) {</span>
<span class="fc" id="L3458">                    termDocId = -1;</span>
<span class="fc" id="L3459">                    mutableKey[0] = null;</span>
                    // only if (probably) needed
<span class="fc bfc" id="L3461" title="All 2 branches covered.">                    if (computeFullList.containsKey(term)) {</span>
<span class="fc" id="L3462">                      registerStatus = computeFullList.get(term);</span>
                      boolean doAdd;
<span class="fc" id="L3464">                      doAdd = termVector.subComponentFunction.sortType.equals(CodecUtil.SORT_TERM);</span>
<span class="fc" id="L3465">                      doAdd |= termVector.subComponentFunction.sortDirection.equals(CodecUtil.SORT_ASC);</span>
<span class="pc bpc" id="L3466" title="1 of 2 branches missed.">                      doAdd |= termVector.list != null;</span>
<span class="fc" id="L3467">                      doAdd |= termVector.boundaryRegistration;</span>
<span class="fc" id="L3468">                      doAdd |= registerStatus.force;</span>
<span class="fc" id="L3469">                      doAdd |= termVector.subComponentFunction.dataCollector</span>
<span class="fc" id="L3470">                          .validateSegmentBoundary(registerStatus.sortValue);</span>
<span class="fc bfc" id="L3471" title="All 2 branches covered.">                      if (doAdd) {</span>
<span class="fc" id="L3472">                        TermvectorNumberFull numberFull = computeTermvectorNumberFull(docSet, termDocId, termsEnum, lrc,</span>
                            postingsEnum, positionsData);
<span class="pc bpc" id="L3474" title="1 of 2 branches missed.">                        if (numberFull.docNumber &gt; 0) {</span>
<span class="fc" id="L3475">                          termCounter++;</span>
<span class="fc" id="L3476">                          registerValue(term, termVector, numberFull, mutableKey);</span>
                        }
                      }
<span class="fc" id="L3479">                    }</span>
                  }
                }
<span class="fc" id="L3482">                computeFullList.clear();</span>
              }
<span class="fc" id="L3484">            } else {</span>
<span class="nc" id="L3485">              throw new IOException(&quot;sort '&quot; + termVector.subComponentFunction.sortType + &quot; &quot;</span>
                  + termVector.subComponentFunction.sortDirection + &quot;' not supported&quot;);
            }
            // finish if segments are used
<span class="fc" id="L3489">            termVector.subComponentFunction.dataCollector.closeSegmentKeyValueRegistration();</span>
<span class="pc bpc" id="L3490" title="1 of 2 branches missed.">            if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3491" title="1 of 2 branches missed.">              for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc" id="L3492">                function.dataCollector.closeSegmentKeyValueRegistration();</span>
<span class="nc" id="L3493">              }</span>
            }
          }
<span class="fc" id="L3496">          termVector.subComponentFunction.dataCollector.closeNewList();</span>
<span class="pc bpc" id="L3497" title="1 of 2 branches missed.">          if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3498" title="1 of 2 branches missed.">            for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc" id="L3499">              function.dataCollector.closeNewList();</span>
<span class="nc" id="L3500">            }</span>
          }
        }
<span class="fc" id="L3503">      }</span>
    }
<span class="fc" id="L3505">  }</span>

  /**
   * Creates the termvector second round.
   *
   * @param termVectorList
   *          the term vector list
   * @param positionsData
   *          the positions data
   * @param docSet
   *          the doc set
   * @param t
   *          the t
   * @param r
   *          the r
   * @param lrc
   *          the lrc
   * @param status
   *          the status
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static void createTermvectorSecondRound(List&lt;ComponentTermVector&gt; termVectorList,
      Map&lt;Integer, Integer&gt; positionsData, List&lt;Integer&gt; docSet, Terms t, LeafReader r, LeafReaderContext lrc,
      Status status) throws IOException {
<span class="pc bpc" id="L3530" title="1 of 2 branches missed.">    if (t != null) {</span>
      BytesRef term;
      TermsEnum termsEnum;
<span class="fc" id="L3533">      PostingsEnum postingsEnum = null;</span>
<span class="fc" id="L3534">      String segmentName = &quot;segment&quot; + lrc.ord;</span>
<span class="fc" id="L3535">      int segmentNumber = lrc.parent.leaves().size();</span>
<span class="fc" id="L3536">      String[] mutableKey = new String[1];</span>
<span class="fc bfc" id="L3537" title="All 2 branches covered.">      for (ComponentTermVector termVector : termVectorList) {</span>
<span class="pc bpc" id="L3538" title="3 of 6 branches missed.">        if (!termVector.full &amp;&amp; termVector.list == null</span>
            &amp;&amp; (termVector.subComponentFunction.dataCollector.segmentRecomputeKeyList != null
<span class="fc bfc" id="L3540" title="All 2 branches covered.">                &amp;&amp; termVector.subComponentFunction.dataCollector.segmentRecomputeKeyList.containsKey(segmentName))) {</span>
<span class="fc" id="L3541">          Set&lt;String&gt; recomputeKeyList = termVector.subComponentFunction.dataCollector.segmentRecomputeKeyList</span>
<span class="fc" id="L3542">              .get(segmentName);</span>
<span class="pc bpc" id="L3543" title="1 of 2 branches missed.">          if (!recomputeKeyList.isEmpty()) {</span>
<span class="fc" id="L3544">            Map&lt;String, Automaton&gt; automatonMap = MtasToken.createAutomatonMap(termVector.prefix,</span>
<span class="fc" id="L3545">                new ArrayList&lt;String&gt;(recomputeKeyList), true);</span>
<span class="fc" id="L3546">            List&lt;CompiledAutomaton&gt; listCompiledAutomata = MtasToken.createAutomata(termVector.prefix,</span>
                termVector.regexp, automatonMap);
<span class="fc bfc" id="L3548" title="All 2 branches covered.">            for (CompiledAutomaton compiledAutomaton : listCompiledAutomata) {</span>
<span class="pc bpc" id="L3549" title="1 of 2 branches missed.">              if (!compiledAutomaton.type.equals(CompiledAutomaton.AUTOMATON_TYPE.NONE)) {</span>
<span class="fc" id="L3550">                termsEnum = t.intersect(compiledAutomaton, null);</span>
<span class="fc" id="L3551">                termVector.subComponentFunction.dataCollector.initNewList(</span>
<span class="fc" id="L3552">                    termVector.subComponentFunction.dataCollector.segmentKeys.size(), segmentName, segmentNumber,</span>
                    termVector.boundary);
<span class="fc" id="L3554">                RegisterStatus registerStatus = null;</span>
<span class="pc bpc" id="L3555" title="1 of 2 branches missed.">                if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3556" title="1 of 2 branches missed.">                  for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc" id="L3557">                    function.dataCollector.initNewList((int) t.size(), segmentName, segmentNumber, null);</span>
<span class="nc" id="L3558">                  }</span>
                }
<span class="pc bpc" id="L3560" title="1 of 2 branches missed.">                if (!docSet.isEmpty()) {</span>
                  int termDocId;
<span class="fc bfc" id="L3562" title="All 2 branches covered.">                  while ((term = termsEnum.next()) != null) {</span>
<span class="pc bpc" id="L3563" title="1 of 2 branches missed.">                    if (validateTermWithStartValue(term, termVector)) {</span>
<span class="fc" id="L3564">                      termDocId = -1;</span>
<span class="fc" id="L3565">                      mutableKey[0] = null;</span>
                      // compute numbers;
<span class="fc" id="L3567">                      TermvectorNumberBasic numberBasic = computeTermvectorNumberBasic(docSet, termDocId, termsEnum, r,</span>
                          lrc, postingsEnum);
<span class="pc bpc" id="L3569" title="1 of 2 branches missed.">                      if (numberBasic.docNumber &gt; 0) {</span>
<span class="fc" id="L3570">                        registerStatus = registerValue(term, termVector, numberBasic, 0, segmentNumber, true,</span>
                            mutableKey);
<span class="fc bfc" id="L3572" title="All 2 branches covered.">                        if (registerStatus != null) {</span>
<span class="fc" id="L3573">                          TermvectorNumberFull numberFull = computeTermvectorNumberFull(docSet, termDocId, termsEnum,</span>
                              lrc, postingsEnum, positionsData);
<span class="pc bpc" id="L3575" title="1 of 2 branches missed.">                          if (numberFull.docNumber &gt; 0) {</span>
<span class="fc" id="L3576">                            registerValue(term, termVector, numberFull, mutableKey);</span>
                          }
                        }
                      }
<span class="fc" id="L3580">                    }</span>
                  }
                }
<span class="fc" id="L3583">                termVector.subComponentFunction.dataCollector.closeNewList();</span>
<span class="pc bpc" id="L3584" title="1 of 2 branches missed.">                if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3585" title="1 of 2 branches missed.">                  for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc" id="L3586">                    function.dataCollector.closeNewList();</span>
<span class="nc" id="L3587">                  }</span>
                }
              }
<span class="fc" id="L3590">            }</span>
          }
        }
<span class="fc" id="L3593">      }</span>
    }
<span class="fc" id="L3595">  }</span>

  /**
   * Validate term with start value.
   *
   * @param term
   *          the term
   * @param termVector
   *          the term vector
   * @return true, if successful
   */
  private static boolean validateTermWithStartValue(BytesRef term, ComponentTermVector termVector) {
<span class="pc bpc" id="L3607" title="1 of 2 branches missed.">    if (termVector.startValue == null) {</span>
<span class="fc" id="L3608">      return true;</span>
<span class="nc bnc" id="L3609" title="All 2 branches missed.">    } else if (termVector.subComponentFunction.sortType.equals(CodecUtil.SORT_TERM)) {</span>
<span class="nc bnc" id="L3610" title="All 2 branches missed.">      if (term.length &gt; termVector.startValue.length) {</span>
<span class="nc" id="L3611">        byte[] zeroBytes = (new BytesRef(&quot;\u0000&quot;)).bytes;</span>
<span class="nc" id="L3612">        int n = (int) (Math.ceil(((double) (term.length - termVector.startValue.length)) / zeroBytes.length));</span>
<span class="nc" id="L3613">        byte[] newBytes = new byte[termVector.startValue.length + n * zeroBytes.length];</span>
<span class="nc" id="L3614">        System.arraycopy(termVector.startValue.bytes, 0, newBytes, 0, termVector.startValue.length);</span>
<span class="nc bnc" id="L3615" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L3616">          System.arraycopy(zeroBytes, 0, newBytes, termVector.startValue.length + i * zeroBytes.length,</span>
              zeroBytes.length);
        }
<span class="nc" id="L3619">        termVector.startValue = new BytesRef(newBytes);</span>
      }
<span class="nc bnc" id="L3621" title="All 2 branches missed.">      if ((termVector.subComponentFunction.sortDirection.equals(CodecUtil.SORT_ASC)</span>
<span class="nc bnc" id="L3622" title="All 2 branches missed.">          &amp;&amp; (termVector.startValue.compareTo(term) &lt; 0))</span>
<span class="nc bnc" id="L3623" title="All 2 branches missed.">          || (termVector.subComponentFunction.sortDirection.equals(CodecUtil.SORT_DESC)</span>
<span class="nc bnc" id="L3624" title="All 2 branches missed.">              &amp;&amp; (termVector.startValue.compareTo(term) &gt; 0))) {</span>
<span class="nc" id="L3625">        return true;</span>
      }
    }
<span class="nc" id="L3628">    return false;</span>
  }

  /**
   * Validate term with distance.
   *
   * @param term
   *          the term
   * @param termVector
   *          the term vector
   * @return true, if successful
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static boolean validateTermWithDistance(BytesRef term, ComponentTermVector termVector) throws IOException {
<span class="pc bpc" id="L3643" title="2 of 4 branches missed.">    if (termVector.distances == null || termVector.distances.isEmpty()) {</span>
<span class="fc" id="L3644">      return true;</span>
    } else {
      // first check maximum for all distances
<span class="nc bnc" id="L3647" title="All 2 branches missed.">      for (SubComponentDistance item : termVector.distances) {</span>
<span class="nc bnc" id="L3648" title="All 2 branches missed.">        if (item.maximum == null) {</span>
<span class="nc" id="L3649">          continue;</span>
        } else {
<span class="nc bnc" id="L3651" title="All 2 branches missed.">          if (!item.getDistance().validateMaximum(term)) {</span>
<span class="nc" id="L3652">            return false;</span>
          }
        }
<span class="nc" id="L3655">      }</span>
      // then check minimum for all distances
<span class="nc bnc" id="L3657" title="All 2 branches missed.">      for (SubComponentDistance item : termVector.distances) {</span>
<span class="nc bnc" id="L3658" title="All 2 branches missed.">        if (item.minimum == null) {</span>
<span class="nc" id="L3659">          continue;</span>
        } else {
<span class="nc bnc" id="L3661" title="All 2 branches missed.">          if (!item.getDistance().validateMinimum(term)) {</span>
<span class="nc" id="L3662">            return false;</span>
          }
        }
<span class="nc" id="L3665">      }</span>
<span class="nc" id="L3666">      return true;</span>
    }
  }

  /**
   * Need second round termvector.
   *
   * @param termVectorList
   *          the term vector list
   * @return true, if successful
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static boolean needSecondRoundTermvector(List&lt;ComponentTermVector&gt; termVectorList) throws IOException {
<span class="fc" id="L3680">    boolean needSecondRound = false;</span>
<span class="fc bfc" id="L3681" title="All 2 branches covered.">    for (ComponentTermVector termVector : termVectorList) {</span>
<span class="fc bfc" id="L3682" title="All 4 branches covered.">      if (!termVector.full &amp;&amp; termVector.list == null) {</span>
        boolean doCheck;
<span class="fc bfc" id="L3684" title="All 2 branches covered.">        doCheck = termVector.subComponentFunction.dataCollector.segmentRegistration != null</span>
            &amp;&amp; (termVector.subComponentFunction.dataCollector.segmentRegistration
<span class="fc bfc" id="L3686" title="All 2 branches covered.">                .equals(MtasDataCollector.SEGMENT_SORT_ASC)</span>
                || termVector.subComponentFunction.dataCollector.segmentRegistration
<span class="pc bpc" id="L3688" title="2 of 4 branches missed.">                    .equals(MtasDataCollector.SEGMENT_SORT_DESC))</span>
            &amp;&amp; termVector.number &gt; 0;
<span class="fc bfc" id="L3690" title="All 2 branches covered.">        doCheck |= termVector.subComponentFunction.dataCollector.segmentRegistration != null</span>
            &amp;&amp; (termVector.subComponentFunction.dataCollector.segmentRegistration
<span class="pc bpc" id="L3692" title="1 of 2 branches missed.">                .equals(MtasDataCollector.SEGMENT_BOUNDARY_ASC)</span>
                || termVector.subComponentFunction.dataCollector.segmentRegistration
<span class="pc bpc" id="L3694" title="3 of 4 branches missed.">                    .equals(MtasDataCollector.SEGMENT_BOUNDARY_DESC))</span>
            &amp;&amp; termVector.number &gt; 0;
<span class="fc bfc" id="L3696" title="All 2 branches covered.">        if (doCheck) {</span>
<span class="fc" id="L3697">          termVector.subComponentFunction.dataCollector.recomputeSegmentKeys();</span>
<span class="fc bfc" id="L3698" title="All 2 branches covered.">          if (!termVector.subComponentFunction.dataCollector.checkExistenceNecessaryKeys()) {</span>
<span class="fc" id="L3699">            needSecondRound = true;</span>
          }
<span class="fc" id="L3701">          termVector.subComponentFunction.dataCollector.reduceToSegmentKeys();</span>
        }
      }
<span class="fc" id="L3704">    }</span>
<span class="fc" id="L3705">    return needSecondRound;</span>
  }

  /**
   * The Class TermvectorNumberBasic.
   */
  private static class TermvectorNumberBasic {

    /** The value sum. */
    public long[] valueSum;

    /** The doc number. */
    public int docNumber;

    /**
     * Instantiates a new termvector number basic.
     */
<span class="fc" id="L3722">    TermvectorNumberBasic() {</span>
<span class="fc" id="L3723">      valueSum = new long[] { 0 };</span>
<span class="fc" id="L3724">      docNumber = 0;</span>
<span class="fc" id="L3725">    }</span>
  }

  /**
   * The Class TermvectorNumberFull.
   */
  private static class TermvectorNumberFull {

    /** The args. */
    public long[] args;

    /** The positions. */
    public int[] positions;

    /** The doc number. */
    public int docNumber;

    /**
     * Instantiates a new termvector number full.
     *
     * @param maxSize
     *          the max size
     */
<span class="fc" id="L3748">    TermvectorNumberFull(int maxSize) {</span>
<span class="fc" id="L3749">      args = new long[maxSize];</span>
<span class="fc" id="L3750">      positions = new int[maxSize];</span>
<span class="fc" id="L3751">      docNumber = 0;</span>
<span class="fc" id="L3752">    }</span>
  }

  /**
   * The Class RegisterStatus.
   */
  private static class RegisterStatus {

    /** The sort value. */
    public long sortValue;

    /** The force. */
    public boolean force;

    /**
     * Instantiates a new register status.
     *
     * @param sortValue
     *          the sort value
     * @param force
     *          the force
     */
<span class="fc" id="L3774">    RegisterStatus(long sortValue, boolean force) {</span>
<span class="fc" id="L3775">      this.sortValue = sortValue;</span>
<span class="fc" id="L3776">      this.force = force;</span>
<span class="fc" id="L3777">    }</span>
  }

  /**
   * Register value.
   *
   * @param term
   *          the term
   * @param termVector
   *          the term vector
   * @param number
   *          the number
   * @param termNumberMaximum
   *          the term number maximum
   * @param segmentNumber
   *          the segment number
   * @param forceAccept
   *          the force accept
   * @param mutableKey
   *          the mutable key
   * @return the register status
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static RegisterStatus registerValue(BytesRef term, ComponentTermVector termVector,
      TermvectorNumberBasic number, Integer termNumberMaximum, Integer segmentNumber, boolean forceAccept,
      String[] mutableKey) throws IOException {
<span class="fc" id="L3805">    long value = termVector.subComponentFunction.parserFunction.getValueLong(number.valueSum, 0);</span>
<span class="fc" id="L3806">    long sortValue = 0;</span>
<span class="fc bfc" id="L3807" title="All 2 branches covered.">    if (termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_SUM)) {</span>
<span class="fc" id="L3808">      sortValue = value;</span>
<span class="pc bpc" id="L3809" title="1 of 2 branches missed.">    } else if (termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_N)) {</span>
<span class="nc" id="L3810">      sortValue = number.docNumber;</span>
    }
<span class="fc" id="L3812">    boolean addItem = false;</span>
<span class="fc" id="L3813">    boolean addItemForced = false;</span>
<span class="fc" id="L3814">    MtasDataCollector&lt;Long, ?&gt; dataCollector = (MtasDataCollector&lt;Long, ?&gt;) termVector.subComponentFunction.dataCollector;</span>
    // sort on term
<span class="fc bfc" id="L3816" title="All 2 branches covered.">    if (termVector.subComponentFunction.sortType.equals(CodecUtil.SORT_TERM)) {</span>
<span class="fc" id="L3817">      addItem = true;</span>
<span class="fc" id="L3818">      addItemForced = true;</span>
      // sort on sum or n
<span class="pc bpc" id="L3820" title="1 of 2 branches missed.">    } else if (termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_SUM)</span>
<span class="nc bnc" id="L3821" title="All 2 branches missed.">        || termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_N)) {</span>
      // always accept
<span class="fc bfc" id="L3823" title="All 2 branches covered.">      if (forceAccept) {</span>
<span class="fc" id="L3824">        addItem = true;</span>
<span class="fc" id="L3825">        addItemForced = addItem;</span>
        // check boundary
<span class="pc bpc" id="L3827" title="1 of 2 branches missed.">      } else if (termVector.boundaryRegistration) {</span>
<span class="nc" id="L3828">        addItem = dataCollector.validateSegmentBoundary(sortValue);</span>
<span class="nc bnc" id="L3829" title="All 2 branches missed.">        if (addItem) {</span>
<span class="nc bnc" id="L3830" title="All 2 branches missed.">          if (mutableKey[0] == null) {</span>
<span class="nc" id="L3831">            mutableKey[0] = MtasToken.getPostfixFromValue(term);</span>
          }
<span class="nc" id="L3833">          String segmentStatus = dataCollector.validateSegmentValue(mutableKey[0], sortValue, termNumberMaximum,</span>
<span class="nc" id="L3834">              segmentNumber, false);</span>
<span class="nc bnc" id="L3835" title="All 2 branches missed.">          if (segmentStatus != null) {</span>
<span class="nc bnc" id="L3836" title="All 2 branches missed.">            if (segmentStatus.equals(MtasDataCollector.SEGMENT_KEY)) {</span>
<span class="nc" id="L3837">              addItemForced = true;</span>
            }
          } else {
            // shouldn't happen
          }
<span class="nc" id="L3842">        }</span>
        // no boundary
      } else {
<span class="fc" id="L3845">        String segmentStatus = dataCollector.validateSegmentValue(sortValue, termNumberMaximum, segmentNumber);</span>
<span class="fc bfc" id="L3846" title="All 2 branches covered.">        if (segmentStatus != null) {</span>
          boolean possibleAddItem;
<span class="fc bfc" id="L3848" title="All 2 branches covered.">          if (segmentStatus.equals(MtasDataCollector.SEGMENT_KEY_OR_NEW)) {</span>
<span class="fc" id="L3849">            possibleAddItem = true;</span>
<span class="pc bpc" id="L3850" title="1 of 2 branches missed.">          } else if (segmentStatus.equals(MtasDataCollector.SEGMENT_POSSIBLE_KEY)) {</span>
<span class="fc" id="L3851">            mutableKey[0] = MtasToken.getPostfixFromValue(term);</span>
<span class="fc" id="L3852">            segmentStatus = dataCollector.validateSegmentValue(mutableKey[0], sortValue, termNumberMaximum,</span>
<span class="fc" id="L3853">                segmentNumber, true);</span>
<span class="fc bfc" id="L3854" title="All 2 branches covered.">            if (segmentStatus != null) {</span>
<span class="fc" id="L3855">              possibleAddItem = true;</span>
            } else {
<span class="fc" id="L3857">              possibleAddItem = false;</span>
            }
          } else {
            // should never happen?
<span class="nc" id="L3861">            possibleAddItem = false;</span>
          }
          // further checks, passed initial
<span class="fc bfc" id="L3864" title="All 2 branches covered.">          if (possibleAddItem) {</span>
<span class="fc bfc" id="L3865" title="All 2 branches covered.">            if (mutableKey[0] == null) {</span>
<span class="fc" id="L3866">              mutableKey[0] = MtasToken.getPostfixFromValue(term);</span>
            }
<span class="fc" id="L3868">            segmentStatus = dataCollector.validateSegmentValue(mutableKey[0], sortValue, termNumberMaximum,</span>
<span class="fc" id="L3869">                segmentNumber, false);</span>
<span class="pc bpc" id="L3870" title="1 of 2 branches missed.">            if (segmentStatus != null) {</span>
<span class="fc" id="L3871">              addItem = true;</span>
<span class="fc bfc" id="L3872" title="All 2 branches covered.">              if (segmentStatus.equals(MtasDataCollector.SEGMENT_KEY)) {</span>
<span class="fc" id="L3873">                addItemForced = true;</span>
              }
            }
          }
<span class="fc" id="L3877">        } else {</span>
<span class="fc" id="L3878">          addItem = false;</span>
        }
<span class="fc" id="L3880">      }</span>
      // don't sort?
    } else {
<span class="nc" id="L3883">      addItem = false;</span>
    }
<span class="fc bfc" id="L3885" title="All 2 branches covered.">    if (addItem) {</span>
<span class="fc" id="L3886">      boolean computeFull = false;</span>
<span class="fc bfc" id="L3887" title="All 2 branches covered.">      if (mutableKey[0] == null) {</span>
<span class="fc" id="L3888">        mutableKey[0] = MtasToken.getPostfixFromValue(term);</span>
      }
      // check dataCollector type
<span class="fc bfc" id="L3891" title="All 2 branches covered.">      if (termVector.subComponentFunction.statsType.equals(CodecUtil.STATS_BASIC)) {</span>
<span class="fc" id="L3892">        dataCollector.add(mutableKey[0], value, number.docNumber);</span>
      } else {
<span class="fc" id="L3894">        computeFull = true;</span>
      }
      // functions
<span class="pc bpc" id="L3897" title="1 of 2 branches missed.">      if (termVector.functions != null) {</span>
<span class="pc bpc" id="L3898" title="1 of 2 branches missed.">        for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc bnc" id="L3899" title="All 4 branches missed.">          if (function.parserFunction.sumRule() &amp;&amp; !function.parserFunction.needPositions()</span>
<span class="nc bnc" id="L3900" title="All 2 branches missed.">              &amp;&amp; function.statsType.equals(CodecUtil.STATS_BASIC)) {</span>
<span class="nc bnc" id="L3901" title="All 2 branches missed.">            if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="nc" id="L3902">              long valueFunction = function.parserFunction.getValueLong(number.valueSum, 0);</span>
<span class="nc" id="L3903">              function.dataCollector.add(mutableKey[0], valueFunction, number.docNumber);</span>
<span class="nc bnc" id="L3904" title="All 2 branches missed.">            } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L3905">              double valueFunction = function.parserFunction.getValueDouble(number.valueSum, 0);</span>
<span class="nc" id="L3906">              function.dataCollector.add(mutableKey[0], valueFunction, number.docNumber);</span>
<span class="nc" id="L3907">            }</span>
          } else {
<span class="nc" id="L3909">            computeFull = true;</span>
          }
<span class="nc" id="L3911">        }</span>
      }
      // add as full?
<span class="fc bfc" id="L3914" title="All 2 branches covered.">      return computeFull ? new RegisterStatus(sortValue, addItemForced) : null;</span>
    } else {
<span class="fc" id="L3916">      return null;</span>
    }
  }

  /**
   * Preliminary register value.
   *
   * @param term
   *          the term
   * @param termVector
   *          the term vector
   * @param number
   *          the number
   * @param termNumberMaximum
   *          the term number maximum
   * @param segmentNumber
   *          the segment number
   * @param mutableKey
   *          the mutable key
   * @return true, if successful
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static boolean preliminaryRegisterValue(BytesRef term, ComponentTermVector termVector,
      TermvectorNumberBasic number, Integer termNumberMaximum, Integer segmentNumber, String[] mutableKey)
      throws IOException {
<span class="nc" id="L3942">    long sortValue = 0;</span>
<span class="nc bnc" id="L3943" title="All 2 branches missed.">    if (termVector.subComponentFunction.sortDirection.equals(CodecUtil.SORT_DESC)</span>
<span class="nc bnc" id="L3944" title="All 2 branches missed.">        &amp;&amp; termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_SUM)) {</span>
<span class="nc" id="L3945">      sortValue = termVector.subComponentFunction.parserFunction.getValueLong(number.valueSum, 0);</span>
<span class="nc bnc" id="L3946" title="All 2 branches missed.">    } else if (termVector.subComponentFunction.sortDirection.equals(CodecUtil.SORT_DESC)</span>
<span class="nc bnc" id="L3947" title="All 2 branches missed.">        &amp;&amp; termVector.subComponentFunction.sortType.equals(CodecUtil.STATS_TYPE_N)) {</span>
<span class="nc" id="L3948">      sortValue = number.docNumber;</span>
    } else {
<span class="nc" id="L3950">      return true;</span>
    }
<span class="nc" id="L3952">    MtasDataCollector&lt;Long, ?&gt; dataCollector = (MtasDataCollector&lt;Long, ?&gt;) termVector.subComponentFunction.dataCollector;</span>
<span class="nc bnc" id="L3953" title="All 2 branches missed.">    if (termVector.boundaryRegistration) {</span>
<span class="nc" id="L3954">      return dataCollector.validateSegmentBoundary(sortValue);</span>
    } else {
<span class="nc" id="L3956">      String segmentStatus = dataCollector.validateSegmentValue(sortValue, termNumberMaximum, segmentNumber);</span>
<span class="nc bnc" id="L3957" title="All 2 branches missed.">      if (segmentStatus != null) {</span>
<span class="nc bnc" id="L3958" title="All 2 branches missed.">        if (segmentStatus.equals(MtasDataCollector.SEGMENT_KEY_OR_NEW)) {</span>
<span class="nc" id="L3959">          return true;</span>
<span class="nc bnc" id="L3960" title="All 2 branches missed.">        } else if (segmentStatus.equals(MtasDataCollector.SEGMENT_POSSIBLE_KEY)) {</span>
<span class="nc" id="L3961">          mutableKey[0] = MtasToken.getPostfixFromValue(term);</span>
<span class="nc" id="L3962">          segmentStatus = dataCollector.validateSegmentValue(mutableKey[0], sortValue, termNumberMaximum, segmentNumber,</span>
              true);
<span class="nc bnc" id="L3964" title="All 2 branches missed.">          return segmentStatus != null;</span>
        } else {
          // should never happen?
<span class="nc" id="L3967">          return false;</span>
        }
      } else {
<span class="nc" id="L3970">        return false;</span>
      }
    }
  }

  /**
   * Register value.
   *
   * @param term
   *          the term
   * @param termVector
   *          the term vector
   * @param number
   *          the number
   * @param mutableKey
   *          the mutable key
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static void registerValue(BytesRef term, ComponentTermVector termVector, TermvectorNumberFull number,
      String[] mutableKey) throws IOException {
<span class="pc bpc" id="L3992" title="1 of 2 branches missed.">    if (number.docNumber &gt; 0) {</span>
<span class="fc bfc" id="L3993" title="All 2 branches covered.">      if (mutableKey[0] == null) {</span>
<span class="fc" id="L3994">        mutableKey[0] = MtasToken.getPostfixFromValue(term);</span>
      }
<span class="fc" id="L3996">      MtasDataCollector&lt;Long, ?&gt; dataCollector = (MtasDataCollector&lt;Long, ?&gt;) termVector.subComponentFunction.dataCollector;</span>
<span class="fc" id="L3997">      long[] valuesLong = new long[number.docNumber];</span>
<span class="fc bfc" id="L3998" title="All 2 branches covered.">      for (int i = 0; i &lt; number.docNumber; i++) {</span>
        try {
<span class="fc" id="L4000">          valuesLong[i] = termVector.subComponentFunction.parserFunction.getValueLong(new long[] { number.args[i] },</span>
              number.positions[i]);
<span class="nc" id="L4002">        } catch (IOException e) {</span>
<span class="nc" id="L4003">          log.debug(e);</span>
<span class="nc" id="L4004">          dataCollector.error(mutableKey[0], e.getMessage(), 1);</span>
<span class="fc" id="L4005">        }</span>
      }
<span class="pc bpc" id="L4007" title="1 of 2 branches missed.">      if (!termVector.subComponentFunction.statsType.equals(CodecUtil.STATS_BASIC)) {</span>
<span class="fc" id="L4008">        dataCollector.add(mutableKey[0], valuesLong, valuesLong.length);</span>
      }
<span class="pc bpc" id="L4010" title="1 of 2 branches missed.">      for (SubComponentFunction function : termVector.functions) {</span>
<span class="nc bnc" id="L4011" title="All 4 branches missed.">        if (!function.parserFunction.sumRule() || function.parserFunction.needPositions()</span>
<span class="nc bnc" id="L4012" title="All 2 branches missed.">            || !function.statsType.equals(CodecUtil.STATS_BASIC)) {</span>
<span class="nc bnc" id="L4013" title="All 2 branches missed.">          if (function.dataType.equals(CodecUtil.DATA_TYPE_LONG)) {</span>
<span class="nc" id="L4014">            valuesLong = new long[number.docNumber];</span>
<span class="nc bnc" id="L4015" title="All 2 branches missed.">            for (int i = 0; i &lt; number.docNumber; i++) {</span>
              try {
<span class="nc" id="L4017">                valuesLong[i] = function.parserFunction.getValueLong(new long[] { number.args[i] },</span>
                    number.positions[i]);
<span class="nc" id="L4019">              } catch (IOException e) {</span>
<span class="nc" id="L4020">                log.debug(e);</span>
<span class="nc" id="L4021">                function.dataCollector.error(mutableKey[0], e.getMessage(), 1);</span>
<span class="nc" id="L4022">              }</span>
            }
<span class="nc" id="L4024">            function.dataCollector.add(mutableKey[0], valuesLong, valuesLong.length);</span>
<span class="nc bnc" id="L4025" title="All 2 branches missed.">          } else if (function.dataType.equals(CodecUtil.DATA_TYPE_DOUBLE)) {</span>
<span class="nc" id="L4026">            double[] valuesDouble = new double[number.docNumber];</span>
<span class="nc bnc" id="L4027" title="All 2 branches missed.">            for (int i = 0; i &lt; number.docNumber; i++) {</span>
              try {
<span class="nc" id="L4029">                valuesDouble[i] = function.parserFunction.getValueDouble(new long[] { number.args[i] },</span>
                    number.positions[i]);
<span class="nc" id="L4031">              } catch (IOException e) {</span>
<span class="nc" id="L4032">                log.debug(e);</span>
<span class="nc" id="L4033">                function.dataCollector.error(mutableKey[0], e.getMessage(), 1);</span>
<span class="nc" id="L4034">              }</span>
            }
<span class="nc" id="L4036">            function.dataCollector.add(mutableKey[0], valuesDouble, valuesDouble.length);</span>
          }
        }
<span class="nc" id="L4039">      }</span>
    }
<span class="fc" id="L4041">  }</span>

  /**
   * Compute termvector number basic.
   *
   * @param termsEnum
   *          the terms enum
   * @param r
   *          the r
   * @return the termvector number basic
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static TermvectorNumberBasic computeTermvectorNumberBasic(TermsEnum termsEnum, LeafReader r)
      throws IOException {
<span class="fc" id="L4056">    TermvectorNumberBasic result = new TermvectorNumberBasic();</span>
<span class="pc bpc" id="L4057" title="1 of 2 branches missed.">    boolean hasDeletedDocuments = (r.getLiveDocs() != null);</span>
<span class="pc bpc" id="L4058" title="1 of 2 branches missed.">    if (!hasDeletedDocuments) {</span>
<span class="fc" id="L4059">      result.valueSum[0] = termsEnum.totalTermFreq();</span>
<span class="fc" id="L4060">      result.docNumber = termsEnum.docFreq();</span>
<span class="pc bpc" id="L4061" title="1 of 2 branches missed.">      if (result.valueSum[0] &gt; -1) {</span>
<span class="fc" id="L4062">        return result;</span>
      }
    }
<span class="nc" id="L4065">    throw new IOException(&quot;should not call this&quot;);</span>
  }

  /**
   * Compute termvector number basic.
   *
   * @param docSet
   *          the doc set
   * @param termDocId
   *          the term doc id
   * @param termsEnum
   *          the terms enum
   * @param r
   *          the r
   * @param lrc
   *          the lrc
   * @param postingsEnum
   *          the postings enum
   * @return the termvector number basic
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static TermvectorNumberBasic computeTermvectorNumberBasic(List&lt;Integer&gt; docSet, int termDocId,
      TermsEnum termsEnum, LeafReader r, LeafReaderContext lrc, PostingsEnum postingsEnum) throws IOException {
<span class="fc" id="L4089">    TermvectorNumberBasic result = new TermvectorNumberBasic();</span>
<span class="pc bpc" id="L4090" title="1 of 2 branches missed.">    boolean hasDeletedDocuments = (r.getLiveDocs() != null);</span>
<span class="pc bpc" id="L4091" title="2 of 4 branches missed.">    if ((docSet.size() == r.numDocs()) &amp;&amp; !hasDeletedDocuments) {</span>
      try {
<span class="fc" id="L4093">        return computeTermvectorNumberBasic(termsEnum, r);</span>
<span class="nc" id="L4094">      } catch (IOException e) {</span>
<span class="nc" id="L4095">        log.debug(&quot;problem&quot;, e);</span>
        // problem
      }
    }
<span class="nc" id="L4099">    result.docNumber = 0;</span>
<span class="nc" id="L4100">    result.valueSum[0] = 0;</span>
<span class="nc" id="L4101">    int localTermDocId = termDocId;</span>
<span class="nc" id="L4102">    Iterator&lt;Integer&gt; docIterator = docSet.iterator();</span>
<span class="nc" id="L4103">    postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.FREQS);</span>
    int docId;
<span class="nc bnc" id="L4105" title="All 2 branches missed.">    while (docIterator.hasNext()) {</span>
<span class="nc" id="L4106">      docId = docIterator.next() - lrc.docBase;</span>
<span class="nc bnc" id="L4107" title="All 4 branches missed.">      if (docId &gt;= localTermDocId</span>
<span class="nc bnc" id="L4108" title="All 2 branches missed.">          &amp;&amp; ((docId == localTermDocId) || ((localTermDocId = postingsEnum.advance(docId)) == docId))) {</span>
<span class="nc" id="L4109">        result.docNumber++;</span>
<span class="nc" id="L4110">        result.valueSum[0] += postingsEnum.freq();</span>
      }
<span class="nc bnc" id="L4112" title="All 2 branches missed.">      if (localTermDocId == DocIdSetIterator.NO_MORE_DOCS) {</span>
<span class="nc" id="L4113">        break;</span>
      }
    }
<span class="nc" id="L4116">    return result;</span>
  }

  /**
   * Compute termvector number full.
   *
   * @param docSet
   *          the doc set
   * @param termDocId
   *          the term doc id
   * @param termsEnum
   *          the terms enum
   * @param lrc
   *          the lrc
   * @param postingsEnum
   *          the postings enum
   * @param positionsData
   *          the positions data
   * @return the termvector number full
   * @throws IOException
   *           Signals that an I/O exception has occurred.
   */
  private static TermvectorNumberFull computeTermvectorNumberFull(List&lt;Integer&gt; docSet, int termDocId,
      TermsEnum termsEnum, LeafReaderContext lrc, PostingsEnum postingsEnum, Map&lt;Integer, Integer&gt; positionsData)
      throws IOException {
<span class="fc" id="L4141">    TermvectorNumberFull result = new TermvectorNumberFull(docSet.size());</span>
<span class="fc" id="L4142">    Iterator&lt;Integer&gt; docIterator = docSet.iterator();</span>
<span class="fc" id="L4143">    int localTermDocId = termDocId;</span>
<span class="fc" id="L4144">    postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.FREQS);</span>
<span class="fc bfc" id="L4145" title="All 2 branches covered.">    while (docIterator.hasNext()) {</span>
<span class="fc" id="L4146">      int docId = docIterator.next() - lrc.docBase;</span>
<span class="fc bfc" id="L4147" title="All 4 branches covered.">      if (docId &gt;= localTermDocId</span>
<span class="fc bfc" id="L4148" title="All 2 branches covered.">          &amp;&amp; ((docId == localTermDocId) || ((localTermDocId = postingsEnum.advance(docId)) == docId))) {</span>
<span class="fc" id="L4149">        result.args[result.docNumber] = postingsEnum.freq();</span>
<span class="pc bpc" id="L4150" title="1 of 2 branches missed.">        result.positions[result.docNumber] = (positionsData == null) ? 0 : positionsData.get(docId + lrc.docBase);</span>
<span class="fc" id="L4151">        result.docNumber++;</span>
      }
<span class="fc" id="L4153">    }</span>
<span class="fc" id="L4154">    return result;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>