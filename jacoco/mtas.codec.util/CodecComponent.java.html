<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CodecComponent.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.codec.util</a> &gt; <span class="el_source">CodecComponent.java</span></div><h1>CodecComponent.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">package mtas.codec.util;</span>

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Serializable;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Base64.Decoder;
import java.util.Base64.Encoder;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import mtas.analysis.token.MtasToken;
import mtas.analysis.token.MtasTokenString;
import mtas.codec.util.CodecComponent.SubComponentFunction;
import mtas.codec.util.CodecSearchTree.MtasTreeHit;
import mtas.codec.util.collector.MtasDataCollector;
import mtas.codec.util.distance.Distance;
import mtas.codec.util.heatmap.HeatmapMtasCounter;
import mtas.codec.util.heatmap.HeatmapMtasCounter.Heatmap;
import mtas.parser.function.MtasFunctionParser;
import mtas.parser.function.ParseException;
import mtas.parser.function.util.MtasFunctionParserFunction;
import mtas.parser.function.util.MtasFunctionParserFunctionDefault;
import mtas.search.spans.util.MtasSpanQuery;
import mtas.solr.handler.component.util.MtasSolrComponentHeatmap;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.lucene.spatial.prefix.PrefixTreeStrategy;
import org.apache.lucene.util.BytesRef;
import org.locationtech.spatial4j.shape.Shape;
import org.noggit.JSONParser;
import org.noggit.ObjectBuilder;

/**
 * The Class CodecComponent.
 */

public class CodecComponent {

  /**
   * Instantiates a new codec component.
   */
<span class="nc" id="L66">  private CodecComponent() {</span>
<span class="nc" id="L67">  }</span>

  /**
   * The Class ComponentFields.
   */
  public static class ComponentFields {

    /** The status. */
    public ComponentStatus status;

    /** The version. */
    public ComponentVersion version;

    /** The list. */
    public Map&lt;String, ComponentField&gt; list;

    /** The collection. */
    public List&lt;ComponentCollection&gt; collection;

    /** The do document. */
    public boolean doDocument;

    /** The do kwic. */
    public boolean doKwic;

    /** The do list. */
    public boolean doList;

    /** The do page. */
    public boolean doPage;

    /** The do heatmap. */
    public boolean doHeatmap;

    /** The do group. */
    public boolean doGroup;

    /** The do term vector. */
    public boolean doTermVector;

    /** The do stats. */
    public boolean doStats;

    /** The do stats spans. */
    public boolean doStatsSpans;

    /** The do stats positions. */
    public boolean doStatsPositions;

    /** The do stats tokens. */
    public boolean doStatsTokens;

    /** The do prefix. */
    public boolean doPrefix;

    /** The do facet. */
    public boolean doFacet;

    /** The do collection. */
    public boolean doCollection;

    /** The do status. */
    public boolean doStatus;

    /** The do version. */
    public boolean doVersion;

    /**
     * Instantiates a new component fields.
     */
<span class="fc" id="L137">    public ComponentFields() {</span>
<span class="fc" id="L138">      status = null;</span>
<span class="fc" id="L139">      list = new HashMap&lt;&gt;();</span>
<span class="fc" id="L140">      collection = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L141">      doDocument = false;</span>
<span class="fc" id="L142">      doKwic = false;</span>
<span class="fc" id="L143">      doList = false;</span>
<span class="fc" id="L144">      doPage = false;</span>
<span class="fc" id="L145">      doHeatmap = false;</span>
<span class="fc" id="L146">      doGroup = false;</span>
<span class="fc" id="L147">      doStats = false;</span>
<span class="fc" id="L148">      doTermVector = false;</span>
<span class="fc" id="L149">      doStatsSpans = false;</span>
<span class="fc" id="L150">      doStatsPositions = false;</span>
<span class="fc" id="L151">      doStatsTokens = false;</span>
<span class="fc" id="L152">      doPrefix = false;</span>
<span class="fc" id="L153">      doFacet = false;</span>
<span class="fc" id="L154">      doCollection = false;</span>
<span class="fc" id="L155">      doStatus = false;</span>
<span class="fc" id="L156">      doVersion = false;</span>
<span class="fc" id="L157">    }</span>
  }

  /**
   * The Interface BasicComponent.
   */
  public abstract static interface BasicComponent {
  }

  /**
   * The Class ComponentField.
   */
  public static class ComponentField implements BasicComponent {

    /** The unique key field. */
    public String uniqueKeyField;

    /** The document list. */
    public List&lt;ComponentDocument&gt; documentList;

    /** The kwic list. */
    public List&lt;ComponentKwic&gt; kwicList;

    /** The list list. */
    public List&lt;ComponentList&gt; listList;

    /** The page list. */
    public List&lt;ComponentPage&gt; pageList;

    /** The heatmap list. */
    public List&lt;ComponentHeatmap&gt; heatmapList;

    /** The group list. */
    public List&lt;ComponentGroup&gt; groupList;

    /** The facet list. */
    public List&lt;ComponentFacet&gt; facetList;

    /** The term vector list. */
    public List&lt;ComponentTermVector&gt; termVectorList;

    /** The stats position list. */
    public List&lt;ComponentPosition&gt; statsPositionList;

    /** The stats token list. */
    public List&lt;ComponentToken&gt; statsTokenList;

    /** The stats span list. */
    public List&lt;ComponentSpan&gt; statsSpanList;

    /** The span query list. */
    public List&lt;MtasSpanQuery&gt; spanQueryList;

    /** The prefix. */
    public ComponentPrefix prefix;

    /**
     * Instantiates a new component field.
     *
     * @param uniqueKeyField
     *          the unique key field
     */
<span class="fc" id="L219">    public ComponentField(String uniqueKeyField) {</span>
<span class="fc" id="L220">      this.uniqueKeyField = uniqueKeyField;</span>
      // initialise
<span class="fc" id="L222">      documentList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L223">      kwicList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L224">      listList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L225">      pageList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L226">      heatmapList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L227">      groupList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L228">      facetList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L229">      termVectorList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L230">      statsPositionList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L231">      statsTokenList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L232">      statsSpanList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L233">      spanQueryList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L234">      prefix = null;</span>
<span class="fc" id="L235">    }</span>
  }

  /**
   * The Class ComponentPrefix.
   */
  public static class ComponentPrefix implements BasicComponent {

    /** The key. */
    public String key;

    /** The single position list. */
    public SortedSet&lt;String&gt; singlePositionList;

    /** The multiple position list. */
    public SortedSet&lt;String&gt; multiplePositionList;

    /** The set position list. */
    public SortedSet&lt;String&gt; setPositionList;

    /** The intersecting list. */
    public SortedSet&lt;String&gt; intersectingList;

    /**
     * Instantiates a new component prefix.
     *
     * @param key
     *          the key
     */
<span class="fc" id="L264">    public ComponentPrefix(String key) {</span>
<span class="fc" id="L265">      this.key = key;</span>
<span class="fc" id="L266">      singlePositionList = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L267">      multiplePositionList = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L268">      setPositionList = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L269">      intersectingList = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L270">    }</span>

    /**
     * Adds the single position.
     *
     * @param prefix
     *          the prefix
     */
    public void addSinglePosition(String prefix) {
<span class="pc bpc" id="L279" title="2 of 6 branches missed.">      if (!prefix.trim().isEmpty() &amp;&amp; !singlePositionList.contains(prefix) &amp;&amp; !multiplePositionList.contains(prefix)) {</span>
<span class="fc" id="L280">        singlePositionList.add(prefix);</span>
      }
<span class="fc" id="L282">    }</span>

    /**
     * Adds the multiple position.
     *
     * @param prefix
     *          the prefix
     */
    public void addMultiplePosition(String prefix) {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">      if (!prefix.trim().isEmpty()) {</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (!singlePositionList.contains(prefix)) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">          if (!multiplePositionList.contains(prefix)) {</span>
<span class="fc" id="L294">            multiplePositionList.add(prefix);</span>
          }
<span class="fc" id="L296">        } else {</span>
<span class="nc" id="L297">          singlePositionList.remove(prefix);</span>
<span class="nc" id="L298">          multiplePositionList.add(prefix);</span>
        }
      }
<span class="fc" id="L301">    }</span>

    /**
     * Adds the set position.
     *
     * @param prefix
     *          the prefix
     */
    public void addSetPosition(String prefix) {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">      if (!prefix.trim().isEmpty()) {</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (!singlePositionList.contains(prefix)) {</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">          if (!setPositionList.contains(prefix)) {</span>
<span class="fc" id="L313">            setPositionList.add(prefix);</span>
          }
<span class="fc" id="L315">        } else {</span>
<span class="nc" id="L316">          singlePositionList.remove(prefix);</span>
<span class="nc" id="L317">          setPositionList.add(prefix);</span>
        }
      }
<span class="fc" id="L320">    }</span>

    /**
     * Adds the intersecting.
     *
     * @param prefix
     *          the prefix
     */
    public void addIntersecting(String prefix) {
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">      if (!prefix.trim().isEmpty()) {</span>
<span class="fc" id="L330">        intersectingList.add(prefix);</span>
      }
<span class="fc" id="L332">    }</span>

  }

  /**
   * The Class ComponentDocument.
   */
  public static class ComponentDocument implements BasicComponent {

    /** The key. */
    public String key;

    /** The prefix. */
    public String prefix;

    /** The regexp. */
    public String regexp;

    /** The ignore regexp. */
    public String ignoreRegexp;

    /** The list. */
    public Set&lt;String&gt; list;

    /** The ignore list. */
    public Set&lt;String&gt; ignoreList;

    /** The list regexp. */
    public boolean listRegexp;

    /** The list expand. */
    public boolean listExpand;

    /** The ignore list regexp. */
    public boolean ignoreListRegexp;

    /** The list expand number. */
    public int listExpandNumber;

    /** The data type. */
    public String dataType;

    /** The stats type. */
    public String statsType;

    /** The stats items. */
    public SortedSet&lt;String&gt; statsItems;

    /** The list number. */
    public int listNumber;

    /** The unique key. */
    public Map&lt;Integer, String&gt; uniqueKey;

    /** The stats data. */
    public Map&lt;Integer, MtasDataCollector&lt;?, ?&gt;&gt; statsData;

    /** The stats list. */
    public Map&lt;Integer, MtasDataCollector&lt;?, ?&gt;&gt; statsList;

    /**
     * Instantiates a new component document.
     *
     * @param key
     *          the key
     * @param prefix
     *          the prefix
     * @param statsType
     *          the stats type
     * @param regexp
     *          the regexp
     * @param list
     *          the list
     * @param listNumber
     *          the list number
     * @param listRegexp
     *          the list regexp
     * @param listExpand
     *          the list expand
     * @param listExpandNumber
     *          the list expand number
     * @param ignoreRegexp
     *          the ignore regexp
     * @param ignoreList
     *          the ignore list
     * @param ignoreListRegexp
     *          the ignore list regexp
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="nc" id="L422">    public ComponentDocument(String key, String prefix, String statsType, String regexp, String[] list, int listNumber,</span>
        Boolean listRegexp, Boolean listExpand, int listExpandNumber, String ignoreRegexp, String[] ignoreList,
        Boolean ignoreListRegexp) throws IOException {
<span class="nc" id="L425">      this.key = key;</span>
<span class="nc" id="L426">      this.prefix = prefix;</span>
<span class="nc" id="L427">      this.regexp = regexp;</span>
<span class="nc bnc" id="L428" title="All 4 branches missed.">      if (list != null &amp;&amp; list.length &gt; 0) {</span>
<span class="nc" id="L429">        this.list = new HashSet&lt;&gt;(Arrays.asList(list));</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        this.listRegexp = listRegexp != null ? listRegexp : false;</span>
<span class="nc bnc" id="L431" title="All 4 branches missed.">        this.listExpand = (listExpand != null &amp;&amp; listExpandNumber &gt; 0) ? listExpand : false;</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (this.listExpand) {</span>
<span class="nc" id="L433">          this.listExpandNumber = listExpandNumber;</span>
<span class="nc" id="L434">        } else {</span>
<span class="nc" id="L435">          this.listExpandNumber = 0;</span>
        }
<span class="nc" id="L437">      } else {</span>
<span class="nc" id="L438">        this.list = null;</span>
<span class="nc" id="L439">        this.listRegexp = false;</span>
<span class="nc" id="L440">        this.listExpand = false;</span>
<span class="nc" id="L441">        this.listExpandNumber = 0;</span>
      }
<span class="nc" id="L443">      this.ignoreRegexp = ignoreRegexp;</span>
<span class="nc bnc" id="L444" title="All 4 branches missed.">      if (ignoreList != null &amp;&amp; ignoreList.length &gt; 0) {</span>
<span class="nc" id="L445">        this.ignoreList = new HashSet&lt;&gt;(Arrays.asList(ignoreList));</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        this.ignoreListRegexp = ignoreListRegexp != null ? ignoreListRegexp : false;</span>
<span class="nc" id="L447">      } else {</span>
<span class="nc" id="L448">        this.ignoreList = null;</span>
<span class="nc" id="L449">        this.ignoreListRegexp = false;</span>
      }
<span class="nc" id="L451">      this.listNumber = listNumber;</span>
<span class="nc" id="L452">      uniqueKey = new HashMap&lt;&gt;();</span>
<span class="nc" id="L453">      dataType = CodecUtil.DATA_TYPE_LONG;</span>
<span class="nc" id="L454">      statsItems = CodecUtil.createStatsItems(statsType);</span>
<span class="nc" id="L455">      this.statsType = CodecUtil.createStatsType(statsItems, null, null);</span>
<span class="nc" id="L456">      this.statsData = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">      if (this.listNumber &gt; 0) {</span>
<span class="nc" id="L458">        this.statsList = new HashMap&lt;&gt;();</span>
<span class="nc" id="L459">      } else {</span>
<span class="nc" id="L460">        this.statsList = null;</span>
      }
<span class="nc" id="L462">    }</span>
  }

  /**
   * The Class ComponentKwic.
   */
  public static class ComponentKwic implements BasicComponent {

    /** The query. */
    public MtasSpanQuery query;

    /** The key. */
    public String key;

    /** The tokens. */
    public Map&lt;Integer, List&lt;KwicToken&gt;&gt; tokens;

    /** The hits. */
    public Map&lt;Integer, List&lt;KwicHit&gt;&gt; hits;

    /** The unique key. */
    public Map&lt;Integer, String&gt; uniqueKey;

    /** The sub total. */
    public Map&lt;Integer, Integer&gt; subTotal;

    /** The min position. */
    public Map&lt;Integer, Integer&gt; minPosition;

    /** The max position. */
    public Map&lt;Integer, Integer&gt; maxPosition;

    /** The prefixes. */
    public List&lt;String&gt; prefixes;

    /** The left. */
    public int left;

    /** The right. */
    public int right;

    /** The start. */
    public int start;

    /** The number. */
    public Integer number;

    /** The page start. */
    public Integer pageStart;

    /** The page end. */
    public Integer pageEnd;

    /** The output. */
    public String output;

    /** The Constant KWIC_OUTPUT_TOKEN. */
    public static final String KWIC_OUTPUT_TOKEN = &quot;token&quot;;

    /** The Constant KWIC_OUTPUT_HIT. */
    public static final String KWIC_OUTPUT_HIT = &quot;hit&quot;;

    /**
     * Instantiates a new component kwic.
     *
     * @param query
     *          the query
     * @param key
     *          the key
     * @param prefixes
     *          the prefixes
     * @param number
     *          the number
     * @param start
     *          the start
     * @param pageStart
     *          the page start
     * @param pageEnd
     *          the page end
     * @param left
     *          the left
     * @param right
     *          the right
     * @param output
     *          the output
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="nc" id="L550">    public ComponentKwic(MtasSpanQuery query, String key, String prefixes, Integer number, int start, Integer pageStart,</span>
        Integer pageEnd, int left, int right, String output) throws IOException {
<span class="nc" id="L552">      this.query = query;</span>
<span class="nc" id="L553">      this.key = key;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">      this.left = (left &gt; 0) ? left : 0;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">      this.right = (right &gt; 0) ? right : 0;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">      this.start = (start &gt; 0) ? start : 0;</span>
<span class="nc bnc" id="L557" title="All 4 branches missed.">      this.number = (number != null &amp;&amp; number &gt;= 0) ? number : null;</span>
<span class="nc bnc" id="L558" title="All 4 branches missed.">      this.pageStart = (pageStart != null &amp;&amp; pageEnd != null) ? pageStart : null;</span>
<span class="nc bnc" id="L559" title="All 4 branches missed.">      this.pageEnd = (pageStart != null &amp;&amp; pageEnd != null) ? pageEnd : null;</span>
<span class="nc" id="L560">      this.output = output;</span>
<span class="nc" id="L561">      tokens = new HashMap&lt;&gt;();</span>
<span class="nc" id="L562">      hits = new HashMap&lt;&gt;();</span>
<span class="nc" id="L563">      uniqueKey = new HashMap&lt;&gt;();</span>
<span class="nc" id="L564">      subTotal = new HashMap&lt;&gt;();</span>
<span class="nc" id="L565">      minPosition = new HashMap&lt;&gt;();</span>
<span class="nc" id="L566">      maxPosition = new HashMap&lt;&gt;();</span>
<span class="nc" id="L567">      this.prefixes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L568" title="All 4 branches missed.">      if ((prefixes != null) &amp;&amp; (prefixes.trim().length() &gt; 0)) {</span>
<span class="nc" id="L569">        List&lt;String&gt; l = Arrays.asList(prefixes.split(Pattern.quote(&quot;,&quot;)));</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (String ls : l) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">          if (ls.trim().length() &gt; 0) {</span>
<span class="nc" id="L572">            this.prefixes.add(ls.trim());</span>
          }
        }
      }
<span class="nc bnc" id="L576" title="All 2 branches missed.">      if (this.output == null) {</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (!this.prefixes.isEmpty()) {</span>
<span class="nc" id="L578">          this.output = ComponentKwic.KWIC_OUTPUT_HIT;</span>
<span class="nc" id="L579">        } else {</span>
<span class="nc" id="L580">          this.output = ComponentKwic.KWIC_OUTPUT_TOKEN;</span>
        }
<span class="nc bnc" id="L582" title="All 2 branches missed.">      } else if (!this.output.equals(ComponentKwic.KWIC_OUTPUT_HIT)</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">          &amp;&amp; !this.output.equals(ComponentKwic.KWIC_OUTPUT_TOKEN)) {</span>
<span class="nc" id="L584">        throw new IOException(&quot;unrecognized output '&quot; + this.output + &quot;'&quot;);</span>
      }
<span class="nc" id="L586">    }</span>
  }

  /**
   * The Class ComponentList.
   */
  public static class ComponentList implements BasicComponent {

    /** The span query. */
    public MtasSpanQuery spanQuery;

    /** The field. */
    public String field;

    /** The query value. */
    public String queryValue;

    /** The query type. */
    public String queryType;

    /** The query prefix. */
    public String queryPrefix;

    /** The query ignore. */
    public String queryIgnore;

    /** The query maximum ignore length. */
    public String queryMaximumIgnoreLength;

    /** The key. */
    public String key;

    /** The query variables. */
    public Map&lt;String, String[]&gt; queryVariables;

    /** The tokens. */
    public List&lt;ListToken&gt; tokens;

    /** The hits. */
    public List&lt;ListHit&gt; hits;

    /** The unique key. */
    public Map&lt;Integer, String&gt; uniqueKey;

    /** The sub total. */
    public Map&lt;Integer, Integer&gt; subTotal;

    /** The min position. */
    public Map&lt;Integer, Integer&gt; minPosition;

    /** The max position. */
    public Map&lt;Integer, Integer&gt; maxPosition;

    /** The prefixes. */
    public List&lt;String&gt; prefixes;

    /** The field values. */
    public Map&lt;Integer, Map&lt;String, Object&gt;&gt; fieldValues;

    /** The field names. */
    public List&lt;String&gt; fieldNames;

    /** The left. */
    public int left;

    /** The right. */
    public int right;

    /** The total. */
    public int total;

    /** The position. */
    public int position;

    /** The start. */
    public int start;

    /** The number. */
    public int number;

    /** The field list. */
    public String fieldList;

    /** The prefix. */
    public String prefix;

    /** The output. */
    public String output;

    /** The Constant LIST_OUTPUT_TOKEN. */
    public static final String LIST_OUTPUT_TOKEN = &quot;token&quot;;

    /** The Constant LIST_OUTPUT_HIT. */
    public static final String LIST_OUTPUT_HIT = &quot;hit&quot;;

    /**
     * Instantiates a new component list.
     *
     * @param spanQuery
     *          the span query
     * @param field
     *          the field
     * @param queryValue
     *          the query value
     * @param queryType
     *          the query type
     * @param queryPrefix
     *          the query prefix
     * @param queryVariables
     *          the query variables
     * @param queryIgnore
     *          the query ignore
     * @param queryMaximumIgnoreLength
     *          the query maximum ignore length
     * @param key
     *          the key
     * @param fieldList
     *          the field list
     * @param prefix
     *          the prefix
     * @param start
     *          the start
     * @param number
     *          the number
     * @param left
     *          the left
     * @param right
     *          the right
     * @param output
     *          the output
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="nc" id="L719">    public ComponentList(MtasSpanQuery spanQuery, String field, String queryValue, String queryType, String queryPrefix,</span>
        Map&lt;String, String[]&gt; queryVariables, String queryIgnore, String queryMaximumIgnoreLength, String key,
        String fieldList, String prefix, int start, int number, int left, int right, String output) throws IOException {
<span class="nc" id="L722">      this.spanQuery = spanQuery;</span>
<span class="nc" id="L723">      this.field = field;</span>
<span class="nc" id="L724">      this.queryValue = queryValue;</span>
<span class="nc" id="L725">      this.queryType = queryType;</span>
<span class="nc" id="L726">      this.queryPrefix = queryPrefix;</span>
<span class="nc" id="L727">      this.queryIgnore = queryIgnore;</span>
<span class="nc" id="L728">      this.queryMaximumIgnoreLength = queryMaximumIgnoreLength;</span>
<span class="nc" id="L729">      this.queryVariables = queryVariables;</span>
<span class="nc" id="L730">      this.key = key;</span>
<span class="nc" id="L731">      this.fieldList = fieldList;</span>
<span class="nc" id="L732">      this.left = left;</span>
<span class="nc" id="L733">      this.right = right;</span>
<span class="nc" id="L734">      this.start = start;</span>
<span class="nc" id="L735">      this.number = number;</span>
<span class="nc" id="L736">      this.output = output;</span>
<span class="nc" id="L737">      this.prefix = prefix;</span>
<span class="nc" id="L738">      total = 0;</span>
<span class="nc" id="L739">      position = 0;</span>
<span class="nc" id="L740">      tokens = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L741">      hits = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L742">      uniqueKey = new HashMap&lt;&gt;();</span>
<span class="nc" id="L743">      subTotal = new HashMap&lt;&gt;();</span>
<span class="nc" id="L744">      minPosition = new HashMap&lt;&gt;();</span>
<span class="nc" id="L745">      maxPosition = new HashMap&lt;&gt;();</span>
<span class="nc" id="L746">      this.prefixes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L747" title="All 4 branches missed.">      if ((prefix != null) &amp;&amp; (prefix.trim().length() &gt; 0)) {</span>
<span class="nc" id="L748">        List&lt;String&gt; l = Arrays.asList(prefix.split(Pattern.quote(&quot;,&quot;)));</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">        for (String ls : l) {</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">          if (ls.trim().length() &gt; 0) {</span>
<span class="nc" id="L751">            this.prefixes.add(ls.trim());</span>
          }
        }
      }
<span class="nc" id="L755">      fieldValues = new HashMap&lt;&gt;();</span>
<span class="nc" id="L756">      fieldNames = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L757" title="All 4 branches missed.">      if ((fieldList != null) &amp;&amp; (fieldList.trim().length() &gt; 0)) {</span>
<span class="nc" id="L758">        List&lt;String&gt; l = Arrays.asList(fieldList.split(Pattern.quote(&quot;,&quot;)));</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        for (String ls : l) {</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">          if (ls.trim().length() &gt; 0) {</span>
<span class="nc" id="L761">            this.fieldNames.add(ls.trim());</span>
          }
        }
      }
      // check output
<span class="nc bnc" id="L766" title="All 2 branches missed.">      if (this.output == null) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">        if (!this.prefixes.isEmpty()) {</span>
<span class="nc" id="L768">          this.output = ComponentList.LIST_OUTPUT_HIT;</span>
<span class="nc" id="L769">        } else {</span>
<span class="nc" id="L770">          this.output = ComponentList.LIST_OUTPUT_TOKEN;</span>
        }
<span class="nc bnc" id="L772" title="All 2 branches missed.">      } else if (!this.output.equals(ComponentList.LIST_OUTPUT_HIT)</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">          &amp;&amp; !this.output.equals(ComponentList.LIST_OUTPUT_TOKEN)) {</span>
<span class="nc" id="L774">        throw new IOException(&quot;unrecognized output '&quot; + this.output + &quot;'&quot;);</span>
      }
<span class="nc" id="L776">    }</span>
  }

  /**
   * The Class ComponentPage.
   */
  public static class ComponentPage implements BasicComponent {
    /** The key. */
    public String key;

    /** The unique key. */
    public Map&lt;Integer, String&gt; uniqueKey;

    /** The min position. */
    public Map&lt;Integer, Integer&gt; minPosition;

    /** The max position. */
    public Map&lt;Integer, Integer&gt; maxPosition;

    /** The word list. */
    public Map&lt;Integer, Map&lt;Integer, PageWordData&gt;&gt; wordList;

    /** The range list. */
    public Map&lt;Integer, Map&lt;Integer, PageRangeData&gt;&gt; rangeList;

    /** The set list. */
    public Map&lt;Integer, Map&lt;Integer, PageSetData&gt;&gt; setList;

    /** The prefixes. */
    public List&lt;String&gt; prefixes;

    /** The start. */
    public int start;

    /** The end. */
    public int end;

    /**
     * Instantiates a new component list.
     *
     * @param field
     *          the field
     * @param key
     *          the key
     * @param prefix
     *          the prefix
     * @param start
     *          the start
     * @param end
     *          the end
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="nc" id="L829">    public ComponentPage(String field, String key, String prefix, int start, int end) throws IOException {</span>
<span class="nc" id="L830">      this.key = key;</span>
<span class="nc" id="L831">      this.start = start;</span>
<span class="nc" id="L832">      this.end = end;</span>
<span class="nc" id="L833">      uniqueKey = new HashMap&lt;&gt;();</span>
<span class="nc" id="L834">      minPosition = new HashMap&lt;&gt;();</span>
<span class="nc" id="L835">      maxPosition = new HashMap&lt;&gt;();</span>
<span class="nc" id="L836">      wordList = new HashMap();</span>
<span class="nc" id="L837">      rangeList = new HashMap();</span>
<span class="nc" id="L838">      setList = new HashMap();</span>
<span class="nc" id="L839">      this.prefixes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L840" title="All 4 branches missed.">      if ((prefix != null) &amp;&amp; (prefix.trim().length() &gt; 0)) {</span>
<span class="nc" id="L841">        List&lt;String&gt; l = Arrays.asList(prefix.split(Pattern.quote(&quot;,&quot;)));</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">        for (String ls : l) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">          if (ls.trim().length() &gt; 0) {</span>
<span class="nc" id="L844">            this.prefixes.add(ls.trim());</span>
          }
        }
      }
<span class="nc" id="L848">    }</span>

  }

  /**
   * The Class ComponentHeatmap.
   */
  public static class ComponentHeatmap implements BasicComponent {

    /** The key. */
    public String key;

    /** The queries. */
    public MtasSpanQuery[] queries;

    /** The strategy. */
    public PrefixTreeStrategy strategy;

    /** The bounds shape. */
    public Shape boundsShape;

    /** The grid level. */
    public Integer gridLevel;
    
    /** The max cells. */
    public int maxCells;

    /** The data type. */
    public String dataType;
    
    /** The stats type. */
    public String statsType;
    
    /** The stats items. */
    public SortedSet&lt;String&gt; statsItems;

    /** The minimum long. */
    public Long minimumLong;

    /** The maximum long. */
    public Long maximumLong;

    /** The parser. */
    public MtasFunctionParserFunction parser;

    /** The hm. */
    public Heatmap hm;

    /** The Constant DEFAULT_MAX_CELLS. */
    private static final int DEFAULT_MAX_CELLS = 100000;

    /**
     * Instantiates a new component heatmap.
     *
     * @param key          the key
     * @param queries the queries
     * @param minimumDouble the minimum double
     * @param maximumDouble the maximum double
     * @param type the type
     * @param functionKey the function key
     * @param functionExpression the function expression
     * @param functionType the function type
     * @param strategy the strategy
     * @param boundsShape the bounds shape
     * @param gridLevel the grid level
     * @param maxCells the max cells
     * @throws IOException Signals that an I/O exception has occurred.
     * @throws ParseException the parse exception
     */
<span class="fc" id="L917">    public ComponentHeatmap(String key, MtasSpanQuery[] queries, Double minimumDouble, Double maximumDouble,</span>
        String type, String[] functionKey, String[] functionExpression, String[] functionType,
        PrefixTreeStrategy strategy, Shape boundsShape, Integer gridLevel, Integer maxCells)
        throws IOException, ParseException {
<span class="fc" id="L921">      this.key = key;</span>
<span class="fc" id="L922">      this.queries = (MtasSpanQuery[]) queries.clone();</span>
<span class="fc" id="L923">      this.strategy = strategy;</span>
<span class="fc" id="L924">      this.boundsShape = boundsShape;</span>
<span class="fc" id="L925">      this.gridLevel = gridLevel;</span>
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">      this.maxCells = maxCells == null ? DEFAULT_MAX_CELLS : maxCells;</span>
<span class="fc" id="L927">      this.parser = new MtasFunctionParserFunctionDefault(queries.length);</span>
<span class="fc" id="L928">      dataType = parser.getType();</span>
<span class="fc" id="L929">      statsItems = CodecUtil.createStatsItems(type);</span>
<span class="fc" id="L930">      statsType = CodecUtil.createStatsType(this.statsItems, null, parser);</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">      if (minimumDouble != null) {</span>
<span class="fc" id="L932">        this.minimumLong = minimumDouble.longValue();</span>
<span class="fc" id="L933">      } else {</span>
<span class="nc" id="L934">        this.minimumLong = null;</span>
      }
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">      if (maximumDouble != null) {</span>
<span class="nc" id="L937">        this.maximumLong = maximumDouble.longValue();</span>
<span class="nc" id="L938">      } else {</span>
<span class="fc" id="L939">        this.maximumLong = null;</span>
      }
<span class="fc" id="L941">      hm = null;</span>
<span class="fc" id="L942">      HeatmapMtasCounter.createHeatmap(this);</span>
      // init functions
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">      if(hm!=null) {</span>
<span class="fc" id="L945">        hm.functions = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L946" title="3 of 6 branches missed.">        if (functionKey != null &amp;&amp; functionExpression != null &amp;&amp; functionType != null) {</span>
<span class="pc bpc" id="L947" title="2 of 4 branches missed.">          if (functionKey.length == functionExpression.length &amp;&amp; functionKey.length == functionType.length) {</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">            for (int i = 0; i &lt; functionKey.length; i++) {</span>
<span class="fc" id="L949">              SubComponentFunction scf = new SubComponentFunction(DataCollector.COLLECTOR_TYPE_LIST, functionKey[i],</span>
<span class="fc" id="L950">                  functionExpression[i], functionType[i]);</span>
<span class="fc" id="L951">              scf.dataCollector.initNewList(hm.columns * hm.rows);</span>
<span class="fc" id="L952">              hm.functions.add(scf);</span>
            }
          }
        }
        // init datacollector
<span class="fc" id="L957">        hm.dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_LIST, dataType, statsType, statsItems,</span>
<span class="fc" id="L958">            null, null, null, null, null, null);</span>
<span class="fc" id="L959">        hm.dataCollector.initNewList(hm.columns * hm.rows);</span>
<span class="fc" id="L960">      } else {</span>
<span class="nc" id="L961">        throw new IOException(&quot;couldn't define hm&quot;);</span>
      }
<span class="fc" id="L963">    }</span>

  }

  /**
   * The Class ComponentGroup.
   */
  public static class ComponentGroup implements BasicComponent {

    /** The span query. */
    public MtasSpanQuery spanQuery;

    /** The data type. */
    public String dataType;

    /** The stats type. */
    public String statsType;

    /** The sort type. */
    public String sortType;

    /** The sort direction. */
    public String sortDirection;

    /** The stats items. */
    public SortedSet&lt;String&gt; statsItems;

    /** The start. */
    public Integer start;

    /** The number. */
    public Integer number;

    /** The key. */
    public String key;

    /** The data collector. */
    public MtasDataCollector&lt;?, ?&gt; dataCollector;

    /** The prefixes. */
    ArrayList&lt;String&gt; prefixes;

    /** The hit inside. */
    HashSet&lt;String&gt; hitInside;

    /** The hit inside left. */
    HashSet&lt;String&gt;[] hitInsideLeft;

    /** The hit inside right. */
    HashSet&lt;String&gt;[] hitInsideRight;

    /** The hit left. */
    HashSet&lt;String&gt;[] hitLeft;

    /** The hit right. */
    HashSet&lt;String&gt;[] hitRight;

    /** The left. */
    HashSet&lt;String&gt;[] left;

    /** The right. */
    HashSet&lt;String&gt;[] right;

    /**
     * Instantiates a new component group.
     *
     * @param spanQuery
     *          the span query
     * @param key
     *          the key
     * @param number
     *          the number
     * @param start
     *          the start
     * @param groupingHitInsidePrefixes
     *          the grouping hit inside prefixes
     * @param groupingHitInsideLeftPosition
     *          the grouping hit inside left position
     * @param groupingHitInsideLeftPrefixes
     *          the grouping hit inside left prefixes
     * @param groupingHitInsideRightPosition
     *          the grouping hit inside right position
     * @param groupingHitInsideRightPrefixes
     *          the grouping hit inside right prefixes
     * @param groupingHitLeftPosition
     *          the grouping hit left position
     * @param groupingHitLeftPrefixes
     *          the grouping hit left prefixes
     * @param groupingHitRightPosition
     *          the grouping hit right position
     * @param groupingHitRightPrefixes
     *          the grouping hit right prefixes
     * @param groupingLeftPosition
     *          the grouping left position
     * @param groupingLeftPrefixes
     *          the grouping left prefixes
     * @param groupingRightPosition
     *          the grouping right position
     * @param groupingRightPrefixes
     *          the grouping right prefixes
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="fc" id="L1066">    public ComponentGroup(MtasSpanQuery spanQuery, String key, int number, int start, String groupingHitInsidePrefixes,</span>
        String[] groupingHitInsideLeftPosition, String[] groupingHitInsideLeftPrefixes,
        String[] groupingHitInsideRightPosition, String[] groupingHitInsideRightPrefixes,
        String[] groupingHitLeftPosition, String[] groupingHitLeftPrefixes, String[] groupingHitRightPosition,
        String[] groupingHitRightPrefixes, String[] groupingLeftPosition, String[] groupingLeftPrefixes,
        String[] groupingRightPosition, String[] groupingRightPrefixes) throws IOException {
<span class="fc" id="L1072">      this.spanQuery = spanQuery;</span>
<span class="fc" id="L1073">      this.key = key;</span>
<span class="fc" id="L1074">      this.dataType = CodecUtil.DATA_TYPE_LONG;</span>
<span class="fc" id="L1075">      this.sortType = CodecUtil.STATS_TYPE_SUM;</span>
<span class="fc" id="L1076">      this.sortDirection = CodecUtil.SORT_DESC;</span>
<span class="fc" id="L1077">      this.statsItems = CodecUtil.createStatsItems(&quot;n,sum,mean&quot;);</span>
<span class="fc" id="L1078">      this.statsType = CodecUtil.createStatsType(this.statsItems, this.sortType, null);</span>
<span class="fc" id="L1079">      this.start = start;</span>
<span class="fc" id="L1080">      this.number = number;</span>
<span class="fc" id="L1081">      HashSet&lt;String&gt; tmpPrefixes = new HashSet&lt;&gt;();</span>
      // analyze grouping condition
<span class="fc bfc" id="L1083" title="All 2 branches covered.">      if (groupingHitInsidePrefixes != null) {</span>
<span class="fc" id="L1084">        hitInside = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1085">        String[] tmpList = groupingHitInsidePrefixes.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        for (String tmpItem : tmpList) {</span>
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">          if (!tmpItem.trim().isEmpty()) {</span>
<span class="fc" id="L1088">            hitInside.add(tmpItem.trim());</span>
          }
        }
<span class="fc" id="L1091">        tmpPrefixes.addAll(hitInside);</span>
<span class="fc" id="L1092">      } else {</span>
<span class="fc" id="L1093">        hitInside = null;</span>
      }
<span class="fc" id="L1095">      hitInsideLeft = createPositionedPrefixes(tmpPrefixes, groupingHitInsideLeftPosition,</span>
<span class="fc" id="L1096">          groupingHitInsideLeftPrefixes);</span>
<span class="fc" id="L1097">      hitInsideRight = createPositionedPrefixes(tmpPrefixes, groupingHitInsideRightPosition,</span>
<span class="fc" id="L1098">          groupingHitInsideRightPrefixes);</span>
<span class="fc" id="L1099">      hitLeft = createPositionedPrefixes(tmpPrefixes, groupingHitLeftPosition, groupingHitLeftPrefixes);</span>
<span class="fc" id="L1100">      hitRight = createPositionedPrefixes(tmpPrefixes, groupingHitRightPosition, groupingHitRightPrefixes);</span>
<span class="fc" id="L1101">      left = createPositionedPrefixes(tmpPrefixes, groupingLeftPosition, groupingLeftPrefixes);</span>
<span class="fc" id="L1102">      right = createPositionedPrefixes(tmpPrefixes, groupingRightPosition, groupingRightPrefixes);</span>
<span class="fc" id="L1103">      prefixes = new ArrayList&lt;&gt;(tmpPrefixes);</span>
      // datacollector
<span class="fc" id="L1105">      dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_LIST, this.dataType, this.statsType,</span>
<span class="fc" id="L1106">          this.statsItems, this.sortType, this.sortDirection, this.start, this.number, null, null);</span>
<span class="fc" id="L1107">    }</span>

    /**
     * Creates the positioned prefixes.
     *
     * @param prefixList
     *          the prefix list
     * @param position
     *          the position
     * @param prefixes
     *          the prefixes
     * @return the hash set[]
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    private static HashSet&lt;String&gt;[] createPositionedPrefixes(HashSet&lt;String&gt; prefixList, String[] position,
        String[] prefixes) throws IOException {
<span class="fc" id="L1124">      Pattern p = Pattern.compile(&quot;^([0-9]+)(\\-([0-9]+))?$&quot;);</span>
      Matcher m;
<span class="pc bpc" id="L1126" title="1 of 4 branches missed.">      if (position == null &amp;&amp; prefixes == null) {</span>
<span class="fc" id="L1127">        return null;</span>
<span class="pc bpc" id="L1128" title="3 of 6 branches missed.">      } else if (prefixes == null || position == null || position.length != prefixes.length) {</span>
<span class="nc" id="L1129">        throw new IOException(&quot;incorrect position/prefixes&quot;);</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">      } else if (position.length == 0) {</span>
<span class="fc" id="L1131">        return null;</span>
      } else {
        // analyze positions
<span class="fc" id="L1134">        int[][] tmpPosition = new int[position.length][];</span>
<span class="fc" id="L1135">        int maxPosition = -1;</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">        for (int i = 0; i &lt; position.length; i++) {</span>
<span class="fc" id="L1137">          m = p.matcher(position[i]);</span>
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">          if (m.find()) {</span>
<span class="fc bfc" id="L1139" title="All 2 branches covered.">            if (m.group(3) == null) {</span>
<span class="fc" id="L1140">              int start = Integer.parseInt(m.group(1));</span>
<span class="fc" id="L1141">              tmpPosition[i] = new int[] { start };</span>
<span class="fc" id="L1142">              maxPosition = Math.max(maxPosition, start);</span>
<span class="fc" id="L1143">            } else {</span>
<span class="fc" id="L1144">              int start = Integer.parseInt(m.group(1));</span>
<span class="fc" id="L1145">              int end = Integer.parseInt(m.group(3));</span>
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">              if (start &gt; end) {</span>
<span class="nc" id="L1147">                throw new IOException(&quot;incorrect position &quot; + position[i]);</span>
              } else {
<span class="fc" id="L1149">                tmpPosition[i] = new int[end - start + 1];</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">                for (int t = start; t &lt;= end; t++)</span>
<span class="fc" id="L1151">                  tmpPosition[i][t - start] = t;</span>
<span class="fc" id="L1152">                maxPosition = Math.max(maxPosition, end);</span>
              }
            }
<span class="fc" id="L1155">          } else {</span>
<span class="nc" id="L1156">            throw new IOException(&quot;incorrect position &quot; + position[i]);</span>
          }
        }
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1160">        HashSet&lt;String&gt;[] result = new HashSet[maxPosition + 1];</span>
<span class="fc" id="L1161">        Arrays.fill(result, null);</span>
        List&lt;String&gt; tmpPrefixList;
        String[] tmpList;
<span class="fc bfc" id="L1164" title="All 2 branches covered.">        for (int i = 0; i &lt; tmpPosition.length; i++) {</span>
<span class="fc" id="L1165">          tmpList = prefixes[i].split(&quot;,&quot;);</span>
<span class="fc" id="L1166">          tmpPrefixList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">          for (String tmpItem : tmpList) {</span>
<span class="pc bpc" id="L1168" title="1 of 2 branches missed.">            if (!tmpItem.trim().isEmpty()) {</span>
<span class="fc" id="L1169">              tmpPrefixList.add(tmpItem.trim());</span>
            }
          }
<span class="pc bpc" id="L1172" title="1 of 2 branches missed.">          if (tmpPrefixList.isEmpty()) {</span>
<span class="nc" id="L1173">            throw new IOException(&quot;incorrect prefixes &quot; + prefixes[i]);</span>
          }
<span class="fc bfc" id="L1175" title="All 2 branches covered.">          for (int t = 0; t &lt; tmpPosition[i].length; t++) {</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">            if (result[tmpPosition[i][t]] == null) {</span>
<span class="fc" id="L1177">              result[tmpPosition[i][t]] = new HashSet&lt;&gt;();</span>
            }
<span class="fc" id="L1179">            result[tmpPosition[i][t]].addAll(tmpPrefixList);</span>
          }
<span class="fc" id="L1181">          prefixList.addAll(tmpPrefixList);</span>
        }
<span class="fc" id="L1183">        return result;</span>
      }
    }

  }

  /**
   * The Class ComponentFacet.
   */
  public static class ComponentFacet implements BasicComponent {

    /** The span queries. */
    public MtasSpanQuery[] spanQueries;

    /** The base fields. */
    public String[] baseFields;

    /** The base field types. */
    public String[] baseFieldTypes;

    /** The base types. */
    public String[] baseTypes;

    /** The base sort types. */
    public String[] baseSortTypes;

    /** The base sort directions. */
    public String[] baseSortDirections;

    /** The base range sizes. */
    public Double[] baseRangeSizes;

    /** The base range bases. */
    public Double[] baseRangeBases;

    /** The base collector types. */
    public String[] baseCollectorTypes;

    /** The base data types. */
    public String[] baseDataTypes;

    /** The base stats types. */
    public String[] baseStatsTypes;

    /** The base stats items. */
    public SortedSet&lt;String&gt;[] baseStatsItems;

    /** The key. */
    public String key;

    /** The data collector. */
    public MtasDataCollector&lt;?, ?&gt; dataCollector;

    /** The base function list. */
    public HashMap&lt;MtasDataCollector&lt;?, ?&gt;, SubComponentFunction[]&gt;[] baseFunctionList;

    /** The base numbers. */
    public Integer[] baseNumbers;

    /** The base minimum longs. */
    public Long[] baseMinimumLongs;

    /** The base maximum longs. */
    public Long[] baseMaximumLongs;

    /** The base parsers. */
    public MtasFunctionParserFunction[] baseParsers;

    /** The base function keys. */
    public String[][] baseFunctionKeys;

    /** The base function expressions. */
    public String[][] baseFunctionExpressions;

    /** The base function types. */
    public String[][] baseFunctionTypes;

    /** The base function parser functions. */
    public MtasFunctionParserFunction[][] baseFunctionParserFunctions;

    /** The Constant TYPE_STRING. */
    public static final String TYPE_STRING = &quot;string&quot;;

    /** The Constant TYPE_POINTFIELD_WITHOUT_DOCVALUES. */
    public static final String TYPE_POINTFIELD_WITHOUT_DOCVALUES = &quot;pointfield_without_docvalues&quot;;

    /**
     * Instantiates a new component facet.
     *
     * @param spanQueries
     *          the span queries
     * @param field
     *          the field
     * @param key
     *          the key
     * @param baseFields
     *          the base fields
     * @param baseFieldTypes
     *          the base field types
     * @param baseTypes
     *          the base types
     * @param baseRangeSizes
     *          the base range sizes
     * @param baseRangeBases
     *          the base range bases
     * @param baseSortTypes
     *          the base sort types
     * @param baseSortDirections
     *          the base sort directions
     * @param baseNumbers
     *          the base numbers
     * @param baseMinimumDoubles
     *          the base minimum doubles
     * @param baseMaximumDoubles
     *          the base maximum doubles
     * @param baseFunctionKeys
     *          the base function keys
     * @param baseFunctionExpressions
     *          the base function expressions
     * @param baseFunctionTypes
     *          the base function types
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     * @throws ParseException
     *           the parse exception
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1310">    public ComponentFacet(MtasSpanQuery[] spanQueries, String field, String key, String[] baseFields,</span>
        String[] baseFieldTypes, String[] baseTypes, Double[] baseRangeSizes, Double[] baseRangeBases,
        String[] baseSortTypes, String[] baseSortDirections, Integer[] baseNumbers, Double[] baseMinimumDoubles,
        Double[] baseMaximumDoubles, String[][] baseFunctionKeys, String[][] baseFunctionExpressions,
        String[][] baseFunctionTypes) throws IOException, ParseException {
<span class="nc" id="L1315">      this.spanQueries = (MtasSpanQuery[]) spanQueries.clone();</span>
<span class="nc" id="L1316">      this.key = key;</span>
<span class="nc" id="L1317">      this.baseFields = (String[]) baseFields.clone();</span>
<span class="nc" id="L1318">      this.baseFieldTypes = (String[]) baseFieldTypes.clone();</span>
<span class="nc" id="L1319">      this.baseTypes = (String[]) baseTypes.clone();</span>
<span class="nc" id="L1320">      this.baseRangeSizes = (Double[]) baseRangeSizes.clone();</span>
<span class="nc" id="L1321">      this.baseRangeBases = (Double[]) baseRangeBases.clone();</span>
<span class="nc" id="L1322">      this.baseSortTypes = (String[]) baseSortTypes.clone();</span>
<span class="nc" id="L1323">      this.baseSortDirections = (String[]) baseSortDirections.clone();</span>
<span class="nc" id="L1324">      this.baseNumbers = (Integer[]) baseNumbers.clone();</span>
      // compute types
<span class="nc" id="L1326">      this.baseMinimumLongs = new Long[baseFields.length];</span>
<span class="nc" id="L1327">      this.baseMaximumLongs = new Long[baseFields.length];</span>
<span class="nc" id="L1328">      this.baseCollectorTypes = new String[baseFields.length];</span>
<span class="nc" id="L1329">      this.baseStatsItems = new SortedSet[baseFields.length];</span>
<span class="nc" id="L1330">      this.baseStatsTypes = new String[baseFields.length];</span>
<span class="nc" id="L1331">      this.baseDataTypes = new String[baseFields.length];</span>
<span class="nc" id="L1332">      this.baseParsers = new MtasFunctionParserFunction[baseFields.length];</span>
<span class="nc" id="L1333">      this.baseFunctionList = new HashMap[baseFields.length];</span>
<span class="nc" id="L1334">      this.baseFunctionParserFunctions = new MtasFunctionParserFunction[baseFields.length][];</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">      for (int i = 0; i &lt; baseFields.length; i++) {</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (baseMinimumDoubles[i] != null) {</span>
<span class="nc" id="L1337">          this.baseMinimumLongs[i] = baseMinimumDoubles[i].longValue();</span>
<span class="nc" id="L1338">        } else {</span>
<span class="nc" id="L1339">          this.baseMinimumLongs[i] = null;</span>
        }
<span class="nc bnc" id="L1341" title="All 2 branches missed.">        if (baseMaximumDoubles[i] != null) {</span>
<span class="nc" id="L1342">          this.baseMaximumLongs[i] = baseMaximumDoubles[i].longValue();</span>
<span class="nc" id="L1343">        } else {</span>
<span class="nc" id="L1344">          this.baseMaximumLongs[i] = null;</span>
        }
<span class="nc" id="L1346">        baseDataTypes[i] = CodecUtil.DATA_TYPE_LONG;</span>
<span class="nc" id="L1347">        baseFunctionList[i] = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1348">        baseFunctionParserFunctions[i] = null;</span>
<span class="nc" id="L1349">        baseParsers[i] = new MtasFunctionParserFunctionDefault(this.spanQueries.length);</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        if (this.baseSortDirections[i] == null) {</span>
<span class="nc" id="L1351">          this.baseSortDirections[i] = CodecUtil.SORT_ASC;</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">        } else if (!this.baseSortDirections[i].equals(CodecUtil.SORT_ASC)</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">            &amp;&amp; !this.baseSortDirections[i].equals(CodecUtil.SORT_DESC)) {</span>
<span class="nc" id="L1354">          throw new IOException(&quot;unrecognized sortDirection &quot; + this.baseSortDirections[i]);</span>
        }
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        if (this.baseSortTypes[i] == null) {</span>
<span class="nc" id="L1357">          this.baseSortTypes[i] = CodecUtil.SORT_TERM;</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        } else if (!this.baseSortTypes[i].equals(CodecUtil.SORT_TERM)</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            &amp;&amp; !CodecUtil.isStatsType(this.baseSortTypes[i])) {</span>
<span class="nc" id="L1360">          throw new IOException(&quot;unrecognized sortType &quot; + this.baseSortTypes[i]);</span>
        }
<span class="nc" id="L1362">        this.baseCollectorTypes[i] = DataCollector.COLLECTOR_TYPE_LIST;</span>
<span class="nc" id="L1363">        this.baseStatsItems[i] = CodecUtil.createStatsItems(this.baseTypes[i]);</span>
<span class="nc" id="L1364">        this.baseStatsTypes[i] = CodecUtil.createStatsType(baseStatsItems[i], this.baseSortTypes[i],</span>
<span class="nc" id="L1365">            new MtasFunctionParserFunctionDefault(1));</span>
      }
      boolean doFunctions;
<span class="nc bnc" id="L1368" title="All 6 branches missed.">      doFunctions = baseFunctionKeys != null &amp;&amp; baseFunctionExpressions != null &amp;&amp; baseFunctionTypes != null;</span>
<span class="nc bnc" id="L1369" title="All 4 branches missed.">      doFunctions = doFunctions ? baseFunctionKeys.length == baseFields.length : false;</span>
<span class="nc bnc" id="L1370" title="All 4 branches missed.">      doFunctions = doFunctions ? baseFunctionTypes.length == baseFields.length : false;</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">      if (doFunctions) {</span>
<span class="nc" id="L1372">        this.baseFunctionKeys = new String[baseFields.length][];</span>
<span class="nc" id="L1373">        this.baseFunctionExpressions = new String[baseFields.length][];</span>
<span class="nc" id="L1374">        this.baseFunctionTypes = new String[baseFields.length][];</span>
<span class="nc bnc" id="L1375" title="All 2 branches missed.">        for (int i = 0; i &lt; baseFields.length; i++) {</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">          if (baseFunctionKeys[i].length == baseFunctionExpressions[i].length</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">              &amp;&amp; baseFunctionKeys[i].length == baseFunctionTypes[i].length) {</span>
<span class="nc" id="L1378">            this.baseFunctionKeys[i] = new String[baseFunctionKeys[i].length];</span>
<span class="nc" id="L1379">            this.baseFunctionExpressions[i] = new String[baseFunctionExpressions[i].length];</span>
<span class="nc" id="L1380">            this.baseFunctionTypes[i] = new String[baseFunctionTypes[i].length];</span>
<span class="nc" id="L1381">            baseFunctionParserFunctions[i] = new MtasFunctionParserFunction[baseFunctionExpressions[i].length];</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">            for (int j = 0; j &lt; baseFunctionKeys[i].length; j++) {</span>
<span class="nc" id="L1383">              this.baseFunctionKeys[i][j] = baseFunctionKeys[i][j];</span>
<span class="nc" id="L1384">              this.baseFunctionExpressions[i][j] = baseFunctionExpressions[i][j];</span>
<span class="nc" id="L1385">              this.baseFunctionTypes[i][j] = baseFunctionTypes[i][j];</span>
<span class="nc" id="L1386">              baseFunctionParserFunctions[i][j] = new MtasFunctionParser(</span>
<span class="nc" id="L1387">                  new BufferedReader(new StringReader(baseFunctionExpressions[i][j]))).parse();</span>
            }
<span class="nc" id="L1389">          } else {</span>
<span class="nc" id="L1390">            this.baseFunctionKeys[i] = new String[0];</span>
<span class="nc" id="L1391">            this.baseFunctionExpressions[i] = new String[0];</span>
<span class="nc" id="L1392">            this.baseFunctionTypes[i] = new String[0];</span>
<span class="nc" id="L1393">            baseFunctionParserFunctions[i] = new MtasFunctionParserFunction[0];</span>
          }
        }
      }
<span class="nc bnc" id="L1397" title="All 2 branches missed.">      if (baseFields.length &gt; 0) {</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        if (baseFields.length == 1) {</span>
<span class="nc" id="L1399">          dataCollector = DataCollector.getCollector(this.baseCollectorTypes[0], this.baseDataTypes[0],</span>
<span class="nc" id="L1400">              this.baseStatsTypes[0], this.baseStatsItems[0], this.baseSortTypes[0], this.baseSortDirections[0], 0,</span>
<span class="nc" id="L1401">              this.baseNumbers[0], null, null);</span>
<span class="nc" id="L1402">        } else {</span>
<span class="nc" id="L1403">          String[] subBaseCollectorTypes = Arrays.copyOfRange(baseCollectorTypes, 1, baseDataTypes.length);</span>
<span class="nc" id="L1404">          String[] subBaseDataTypes = Arrays.copyOfRange(baseDataTypes, 1, baseDataTypes.length);</span>
<span class="nc" id="L1405">          String[] subBaseStatsTypes = Arrays.copyOfRange(baseStatsTypes, 1, baseStatsTypes.length);</span>
<span class="nc" id="L1406">          SortedSet&lt;String&gt;[] subBaseStatsItems = Arrays.copyOfRange(baseStatsItems, 1, baseStatsItems.length);</span>
<span class="nc" id="L1407">          String[] subBaseSortTypes = Arrays.copyOfRange(baseSortTypes, 1, baseSortTypes.length);</span>
<span class="nc" id="L1408">          String[] subBaseSortDirections = Arrays.copyOfRange(baseSortDirections, 1, baseSortDirections.length);</span>
<span class="nc" id="L1409">          Integer[] subNumbers = Arrays.copyOfRange(baseNumbers, 1, baseNumbers.length);</span>
<span class="nc" id="L1410">          Integer[] subStarts = ArrayUtils.toObject(new int[subNumbers.length]);</span>
<span class="nc" id="L1411">          dataCollector = DataCollector.getCollector(this.baseCollectorTypes[0], this.baseDataTypes[0],</span>
<span class="nc" id="L1412">              this.baseStatsTypes[0], this.baseStatsItems[0], this.baseSortTypes[0], this.baseSortDirections[0], 0,</span>
<span class="nc" id="L1413">              this.baseNumbers[0], subBaseCollectorTypes, subBaseDataTypes, subBaseStatsTypes, subBaseStatsItems,</span>
<span class="nc" id="L1414">              subBaseSortTypes, subBaseSortDirections, subStarts, subNumbers, null, null);</span>
        }
<span class="nc" id="L1416">      } else {</span>
<span class="nc" id="L1417">        throw new IOException(&quot;no baseFields&quot;);</span>
      }
<span class="nc" id="L1419">    }</span>

    /**
     * Function sum rule.
     *
     * @return true, if successful
     */
    public boolean functionSumRule() {
<span class="nc bnc" id="L1427" title="All 2 branches missed.">      if (baseFunctionParserFunctions != null) {</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        for (int i = 0; i &lt; baseFields.length; i++) {</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">          for (MtasFunctionParserFunction function : baseFunctionParserFunctions[i]) {</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            if (!function.sumRule()) {</span>
<span class="nc" id="L1431">              return false;</span>
            }
          }
        }
      }
<span class="nc" id="L1436">      return true;</span>
    }

    /**
     * Function need positions.
     *
     * @return true, if successful
     */
    public boolean functionNeedPositions() {
<span class="nc bnc" id="L1445" title="All 2 branches missed.">      if (baseFunctionParserFunctions != null) {</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">        for (int i = 0; i &lt; baseFields.length; i++) {</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">          for (MtasFunctionParserFunction function : baseFunctionParserFunctions[i]) {</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            if (function.needPositions()) {</span>
<span class="nc" id="L1449">              return true;</span>
            }
          }
        }
      }
<span class="nc" id="L1454">      return false;</span>
    }

    /**
     * Base parser sum rule.
     *
     * @return true, if successful
     */
    public boolean baseParserSumRule() {
<span class="nc bnc" id="L1463" title="All 2 branches missed.">      for (int i = 0; i &lt; baseFields.length; i++) {</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">        if (!baseParsers[i].sumRule()) {</span>
<span class="nc" id="L1465">          return false;</span>
        }
      }
<span class="nc" id="L1468">      return true;</span>
    }

    /**
     * Base parser need positions.
     *
     * @return true, if successful
     */
    public boolean baseParserNeedPositions() {
<span class="nc bnc" id="L1477" title="All 2 branches missed.">      for (int i = 0; i &lt; baseFields.length; i++) {</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">        if (baseParsers[i].needPositions()) {</span>
<span class="nc" id="L1479">          return true;</span>
        }
      }
<span class="nc" id="L1482">      return false;</span>
    }

  }

  /**
   * The Class ComponentTermVector.
   */
  public static class ComponentTermVector implements BasicComponent {

    /** The key. */
    public String key;

    /** The prefix. */
    public String prefix;

    /** The distances. */
    public List&lt;SubComponentDistance&gt; distances;

    /** The regexp. */
    public String regexp;

    /** The ignore regexp. */
    public String ignoreRegexp;

    /** The boundary. */
    public String boundary;

    /** The full. */
    public boolean full;

    /** The list. */
    public Set&lt;String&gt; list;

    /** The ignore list. */
    public Set&lt;String&gt; ignoreList;

    /** The list regexp. */
    public boolean listRegexp;

    /** The ignore list regexp. */
    public boolean ignoreListRegexp;

    /** The functions. */
    public List&lt;SubComponentFunction&gt; functions;

    /** The number. */
    public int number;

    /** The start value. */
    public BytesRef startValue;

    /** The sub component function. */
    public SubComponentFunction subComponentFunction;

    /** The boundary registration. */
    public boolean boundaryRegistration;

    /** The sort type. */
    public String sortType;

    /** The sort direction. */
    public String sortDirection;

    /**
     * Instantiates a new component term vector.
     *
     * @param key
     *          the key
     * @param prefix
     *          the prefix
     * @param distanceKey
     *          the distance key
     * @param distanceType
     *          the distance type
     * @param distanceBase
     *          the distance base
     * @param distanceParameter
     *          the distance parameter
     * @param distanceMinimum
     *          the distance minimum
     * @param distanceMaximum
     *          the distance maximum
     * @param regexp
     *          the regexp
     * @param full
     *          the full
     * @param type
     *          the type
     * @param sortType
     *          the sort type
     * @param sortDirection
     *          the sort direction
     * @param startValue
     *          the start value
     * @param number
     *          the number
     * @param functionKey
     *          the function key
     * @param functionExpression
     *          the function expression
     * @param functionType
     *          the function type
     * @param boundary
     *          the boundary
     * @param list
     *          the list
     * @param listRegexp
     *          the list regexp
     * @param ignoreRegexp
     *          the ignore regexp
     * @param ignoreList
     *          the ignore list
     * @param ignoreListRegexp
     *          the ignore list regexp
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     * @throws ParseException
     *           the parse exception
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L1603">    public ComponentTermVector(String key, String prefix, String[] distanceKey, String[] distanceType,</span>
        String[] distanceBase, Map[] distanceParameter, String[] distanceMinimum, String[] distanceMaximum,
        String regexp, Boolean full, String type, String sortType, String sortDirection, String startValue, int number,
        String[] functionKey, String[] functionExpression, String[] functionType, String boundary, String[] list,
        Boolean listRegexp, String ignoreRegexp, String[] ignoreList, Boolean ignoreListRegexp)
        throws IOException, ParseException {
<span class="fc" id="L1609">      this.key = key;</span>
<span class="fc" id="L1610">      this.prefix = prefix;</span>
<span class="fc" id="L1611">      distances = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1612" title="3 of 8 branches missed.">      if (distanceKey != null &amp;&amp; distanceType != null &amp;&amp; distanceBase != null &amp;&amp; distanceParameter != null</span>
<span class="pc bpc" id="L1613" title="1 of 2 branches missed.">          &amp;&amp; distanceMaximum != null) {</span>
<span class="pc bpc" id="L1614" title="2 of 4 branches missed.">        if (distanceKey.length == distanceType.length &amp;&amp; distanceKey.length == distanceBase.length</span>
<span class="pc bpc" id="L1615" title="2 of 4 branches missed.">            &amp;&amp; distanceKey.length == distanceParameter.length &amp;&amp; distanceKey.length == distanceMaximum.length) {</span>
<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">          for (int i = 0; i &lt; distanceKey.length; i++) {</span>
<span class="nc" id="L1617">            SubComponentDistance item = new SubComponentDistance(distanceKey[i], distanceType[i], this.prefix,</span>
<span class="nc" id="L1618">                distanceBase[i], distanceParameter[i], distanceMinimum[i], distanceMaximum[i]);</span>
<span class="nc" id="L1619">            distances.add(item);</span>
          }
        }
      }
<span class="fc" id="L1623">      this.regexp = regexp;</span>
<span class="pc bpc" id="L1624" title="1 of 4 branches missed.">      this.full = (full != null &amp;&amp; full) ? true : false;</span>
<span class="fc bfc" id="L1625" title="All 2 branches covered.">      if (sortType == null) {</span>
<span class="fc" id="L1626">        this.sortType = CodecUtil.SORT_TERM;</span>
<span class="fc" id="L1627">      } else {</span>
<span class="fc" id="L1628">        this.sortType = sortType;</span>
      }
<span class="fc bfc" id="L1630" title="All 2 branches covered.">      if (sortDirection == null) {</span>
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">        if (this.sortType.equals(CodecUtil.SORT_TERM)) {</span>
<span class="fc" id="L1632">          this.sortDirection = CodecUtil.SORT_ASC;</span>
<span class="fc" id="L1633">        } else {</span>
<span class="nc" id="L1634">          this.sortDirection = CodecUtil.SORT_DESC;</span>
        }
<span class="nc" id="L1636">      } else {</span>
<span class="fc" id="L1637">        this.sortDirection = sortDirection;</span>
      }
<span class="pc bpc" id="L1639" title="1 of 4 branches missed.">      if (list != null &amp;&amp; list.length &gt; 0) {</span>
<span class="fc" id="L1640">        this.list = new HashSet(Arrays.asList(list));</span>
<span class="pc bpc" id="L1641" title="1 of 2 branches missed.">        this.listRegexp = listRegexp != null ? listRegexp : false;</span>
<span class="fc" id="L1642">        this.boundary = null;</span>
<span class="fc" id="L1643">        this.number = Integer.MAX_VALUE;</span>
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">        if (!this.full) {</span>
<span class="fc" id="L1645">          this.sortType = CodecUtil.SORT_TERM;</span>
<span class="fc" id="L1646">          this.sortDirection = CodecUtil.SORT_ASC;</span>
        }
<span class="fc" id="L1648">      } else {</span>
<span class="fc" id="L1649">        this.list = null;</span>
<span class="fc" id="L1650">        this.listRegexp = false;</span>
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">        this.startValue = (startValue != null) ? new BytesRef(prefix + MtasToken.DELIMITER + startValue) : null;</span>
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">        if (boundary == null) {</span>
<span class="fc" id="L1653">          this.boundary = null;</span>
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">          if (number &lt; -1) {</span>
<span class="nc" id="L1655">            throw new IOException(&quot;number should not be &quot; + number);</span>
<span class="fc bfc" id="L1656" title="All 2 branches covered.">          } else if (number &gt;= 0) {</span>
<span class="fc" id="L1657">            this.number = number;</span>
<span class="fc" id="L1658">          } else {</span>
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">            if (!full) {</span>
<span class="nc" id="L1660">              throw new IOException(&quot;number &quot; + number + &quot; only supported for full termvector&quot;);</span>
            } else {
<span class="fc" id="L1662">              this.number = Integer.MAX_VALUE;</span>
            }
          }
<span class="fc" id="L1665">        } else {</span>
<span class="nc" id="L1666">          this.boundary = boundary;</span>
<span class="nc" id="L1667">          this.number = Integer.MAX_VALUE;</span>
        }
      }
<span class="fc" id="L1670">      this.ignoreRegexp = ignoreRegexp;</span>
<span class="pc bpc" id="L1671" title="1 of 4 branches missed.">      if (ignoreList != null &amp;&amp; ignoreList.length &gt; 0) {</span>
<span class="fc" id="L1672">        this.ignoreList = new HashSet(Arrays.asList(ignoreList));</span>
<span class="pc bpc" id="L1673" title="1 of 2 branches missed.">        this.ignoreListRegexp = ignoreListRegexp != null ? ignoreListRegexp : false;</span>
<span class="fc" id="L1674">      } else {</span>
<span class="fc" id="L1675">        this.ignoreList = null;</span>
<span class="fc" id="L1676">        this.ignoreListRegexp = false;</span>
      }
<span class="fc" id="L1678">      functions = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1679" title="2 of 6 branches missed.">      if (functionKey != null &amp;&amp; functionExpression != null &amp;&amp; functionType != null) {</span>
<span class="pc bpc" id="L1680" title="2 of 4 branches missed.">        if (functionKey.length == functionExpression.length &amp;&amp; functionKey.length == functionType.length) {</span>
<span class="pc bpc" id="L1681" title="1 of 2 branches missed.">          for (int i = 0; i &lt; functionKey.length; i++) {</span>
<span class="nc" id="L1682">            functions.add(new SubComponentFunction(DataCollector.COLLECTOR_TYPE_LIST, functionKey[i],</span>
<span class="nc" id="L1683">                functionExpression[i], functionType[i]));</span>
          }
        }
      }
<span class="pc bpc" id="L1687" title="1 of 4 branches missed.">      if (!this.sortType.equals(CodecUtil.SORT_TERM) &amp;&amp; !CodecUtil.isStatsType(this.sortType)) {</span>
<span class="nc" id="L1688">        throw new IOException(&quot;unknown sortType '&quot; + this.sortType + &quot;'&quot;);</span>
<span class="fc bfc" id="L1689" title="All 4 branches covered.">      } else if (!full &amp;&amp; !this.sortType.equals(CodecUtil.SORT_TERM)) {</span>
<span class="pc bpc" id="L1690" title="3 of 4 branches missed.">        if (!(this.sortType.equals(CodecUtil.STATS_TYPE_SUM) || this.sortType.equals(CodecUtil.STATS_TYPE_N))) {</span>
<span class="nc" id="L1691">          throw new IOException(&quot;sortType '&quot; + this.sortType + &quot;' only supported with full termVector&quot;);</span>
        }
      }
<span class="fc bfc" id="L1694" title="All 2 branches covered.">      if (!this.sortType.equals(CodecUtil.SORT_TERM)) {</span>
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">        if (startValue != null) {</span>
<span class="nc" id="L1696">          throw new IOException(</span>
<span class="nc" id="L1697">              &quot;startValue '&quot; + startValue + &quot;' only supported with termVector sorted on &quot; + CodecUtil.SORT_TERM);</span>
        }
      }
<span class="pc bpc" id="L1700" title="1 of 4 branches missed.">      if (!this.sortDirection.equals(CodecUtil.SORT_ASC) &amp;&amp; !this.sortDirection.equals(CodecUtil.SORT_DESC)) {</span>
<span class="nc" id="L1701">        throw new IOException(&quot;unrecognized sortDirection '&quot; + this.sortDirection + &quot;'&quot;);</span>
      }
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">      boundaryRegistration = this.boundary != null;</span>
<span class="fc" id="L1704">      String segmentRegistration = null;</span>
<span class="fc bfc" id="L1705" title="All 2 branches covered.">      if (this.full) {</span>
<span class="fc" id="L1706">        this.boundary = null;</span>
<span class="fc" id="L1707">        segmentRegistration = null;</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">      } else if (this.boundary != null) {</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">        if (this.sortDirection.equals(CodecUtil.SORT_ASC)) {</span>
<span class="nc" id="L1710">          segmentRegistration = MtasDataCollector.SEGMENT_BOUNDARY_ASC;</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">        } else if (this.sortDirection.equals(CodecUtil.SORT_DESC)) {</span>
<span class="nc" id="L1712">          segmentRegistration = MtasDataCollector.SEGMENT_BOUNDARY_DESC;</span>
        }
<span class="pc bfc" id="L1714" title="All 2 branches covered.">      } else if (!this.sortType.equals(CodecUtil.SORT_TERM)) {</span>
<span class="fc bfc" id="L1715" title="All 2 branches covered.">        if (this.sortDirection.equals(CodecUtil.SORT_ASC)) {</span>
<span class="fc" id="L1716">          segmentRegistration = MtasDataCollector.SEGMENT_SORT_ASC;</span>
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">        } else if (this.sortDirection.equals(CodecUtil.SORT_DESC)) {</span>
<span class="fc" id="L1718">          segmentRegistration = MtasDataCollector.SEGMENT_SORT_DESC;</span>
        }
      }
      // create main subComponentFunction
<span class="fc" id="L1722">      this.subComponentFunction = new SubComponentFunction(DataCollector.COLLECTOR_TYPE_LIST, key, type,</span>
<span class="fc" id="L1723">          new MtasFunctionParserFunctionDefault(1), this.sortType, this.sortDirection, 0, this.number,</span>
<span class="fc" id="L1724">          segmentRegistration, boundary);</span>
<span class="fc" id="L1725">    }</span>

    /**
     * Function sum rule.
     *
     * @return true, if successful
     */
    public boolean functionSumRule() {
<span class="nc bnc" id="L1733" title="All 2 branches missed.">      if (functions != null) {</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">        for (SubComponentFunction function : functions) {</span>
<span class="nc bnc" id="L1735" title="All 2 branches missed.">          if (!function.parserFunction.sumRule()) {</span>
<span class="nc" id="L1736">            return false;</span>
          }
        }
      }
<span class="nc" id="L1740">      return true;</span>
    }

    /**
     * Function need positions.
     *
     * @return true, if successful
     */
    public boolean functionNeedPositions() {
<span class="pc bpc" id="L1749" title="1 of 2 branches missed.">      if (functions != null) {</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">        for (SubComponentFunction function : functions) {</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">          if (function.parserFunction.needPositions()) {</span>
<span class="nc" id="L1752">            return true;</span>
          }
        }
      }
<span class="fc" id="L1756">      return false;</span>
    }

  }

  /**
   * The Class ComponentStatus.
   */
  public static class ComponentStatus implements BasicComponent {

    /** The handler. */
    public String handler;

    /** The name. */
    public String name;

    /** The key. */
    public String key;

    /** The number of documents. */
    public Integer numberOfDocuments;

    /** The number of segments. */
    public Integer numberOfSegments;

    /** The get mtas handler. */
    public boolean getMtasHandler;

    /** The get number of documents. */
    public boolean getNumberOfDocuments;

    /** The get number of segments. */
    public boolean getNumberOfSegments;

    /**
     * Instantiates a new component status.
     *
     * @param name
     *          the name
     * @param key
     *          the key
     * @param getMtasHandler
     *          the get mtas handler
     * @param getNumberOfDocuments
     *          the get number of documents
     * @param getNumberOfSegments
     *          the get number of segments
     */
<span class="fc" id="L1804">    public ComponentStatus(String name, String key, boolean getMtasHandler, boolean getNumberOfDocuments,</span>
        boolean getNumberOfSegments) {
<span class="fc" id="L1806">      this.name = Objects.requireNonNull(name, &quot;no name&quot;);</span>
<span class="fc" id="L1807">      this.key = key;</span>
<span class="fc" id="L1808">      this.getMtasHandler = getMtasHandler;</span>
<span class="fc" id="L1809">      this.getNumberOfDocuments = getNumberOfDocuments;</span>
<span class="fc" id="L1810">      this.getNumberOfSegments = getNumberOfSegments;</span>
<span class="fc" id="L1811">      handler = null;</span>
<span class="fc" id="L1812">      numberOfDocuments = null;</span>
<span class="fc" id="L1813">      numberOfSegments = null;</span>
<span class="fc" id="L1814">    }</span>

  }

  /**
   * The Class ComponentVersion.
   */
  public static class ComponentVersion implements BasicComponent {

    /**
     * Instantiates a new component version.
     */
<span class="nc" id="L1826">    public ComponentVersion() {</span>

<span class="nc" id="L1828">    }</span>
  }

  /**
   * The Interface ComponentStats.
   */
  public abstract static interface ComponentStats extends BasicComponent {
  }

  /**
   * The Class ComponentSpan.
   */
  public static class ComponentSpan implements ComponentStats {

    /** The queries. */
    public MtasSpanQuery[] queries;

    /** The key. */
    public String key;

    /** The data type. */
    public String dataType;

    /** The stats type. */
    public String statsType;

    /** The stats items. */
    public SortedSet&lt;String&gt; statsItems;

    /** The minimum long. */
    public Long minimumLong;

    /** The maximum long. */
    public Long maximumLong;

    /** The data collector. */
    public MtasDataCollector&lt;?, ?&gt; dataCollector;

    /** The functions. */
    public List&lt;SubComponentFunction&gt; functions;

    /** The parser. */
    public MtasFunctionParserFunction parser;

    /**
     * Instantiates a new component span.
     *
     * @param queries
     *          the queries
     * @param key
     *          the key
     * @param minimumDouble
     *          the minimum double
     * @param maximumDouble
     *          the maximum double
     * @param type
     *          the type
     * @param functionKey
     *          the function key
     * @param functionExpression
     *          the function expression
     * @param functionType
     *          the function type
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     * @throws ParseException
     *           the parse exception
     */
<span class="fc" id="L1896">    public ComponentSpan(MtasSpanQuery[] queries, String key, Double minimumDouble, Double maximumDouble, String type,</span>
        String[] functionKey, String[] functionExpression, String[] functionType) throws IOException, ParseException {
<span class="fc" id="L1898">      this.queries = (MtasSpanQuery[]) queries.clone();</span>
<span class="fc" id="L1899">      this.key = key;</span>
<span class="fc" id="L1900">      functions = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1901" title="2 of 6 branches missed.">      if (functionKey != null &amp;&amp; functionExpression != null &amp;&amp; functionType != null) {</span>
<span class="pc bpc" id="L1902" title="2 of 4 branches missed.">        if (functionKey.length == functionExpression.length &amp;&amp; functionKey.length == functionType.length) {</span>
<span class="fc bfc" id="L1903" title="All 2 branches covered.">          for (int i = 0; i &lt; functionKey.length; i++) {</span>
<span class="fc" id="L1904">            functions.add(new SubComponentFunction(DataCollector.COLLECTOR_TYPE_DATA, functionKey[i],</span>
<span class="fc" id="L1905">                functionExpression[i], functionType[i]));</span>
          }
        }
      }
<span class="fc" id="L1909">      parser = new MtasFunctionParserFunctionDefault(queries.length);</span>
<span class="fc" id="L1910">      dataType = parser.getType();</span>
<span class="fc" id="L1911">      statsItems = CodecUtil.createStatsItems(type);</span>
<span class="fc" id="L1912">      statsType = CodecUtil.createStatsType(this.statsItems, null, parser);</span>
<span class="fc bfc" id="L1913" title="All 2 branches covered.">      if (minimumDouble != null) {</span>
<span class="fc" id="L1914">        this.minimumLong = minimumDouble.longValue();</span>
<span class="fc" id="L1915">      } else {</span>
<span class="fc" id="L1916">        this.minimumLong = null;</span>
      }
<span class="fc bfc" id="L1918" title="All 2 branches covered.">      if (maximumDouble != null) {</span>
<span class="fc" id="L1919">        this.maximumLong = maximumDouble.longValue();</span>
<span class="fc" id="L1920">      } else {</span>
<span class="fc" id="L1921">        this.maximumLong = null;</span>
      }
<span class="fc" id="L1923">      dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_DATA, dataType, this.statsType,</span>
<span class="fc" id="L1924">          this.statsItems, null, null, null, null, null, null);</span>
<span class="fc" id="L1925">    }</span>

    /**
     * Function sum rule.
     *
     * @return true, if successful
     */
    public boolean functionSumRule() {
<span class="pc bpc" id="L1933" title="1 of 2 branches missed.">      if (functions != null) {</span>
<span class="fc bfc" id="L1934" title="All 2 branches covered.">        for (SubComponentFunction function : functions) {</span>
<span class="pc bpc" id="L1935" title="1 of 2 branches missed.">          if (!function.parserFunction.sumRule()) {</span>
<span class="nc" id="L1936">            return false;</span>
          }
        }
      }
<span class="fc" id="L1940">      return true;</span>
    }

    /**
     * Function basic.
     *
     * @return true, if successful
     */
    public boolean functionBasic() {
<span class="pc bpc" id="L1949" title="1 of 2 branches missed.">      if (functions != null) {</span>
<span class="fc bfc" id="L1950" title="All 2 branches covered.">        for (SubComponentFunction function : functions) {</span>
<span class="pc bpc" id="L1951" title="1 of 2 branches missed.">          if (!function.statsType.equals(CodecUtil.STATS_BASIC)) {</span>
<span class="nc" id="L1952">            return false;</span>
          }
        }
      }
<span class="fc" id="L1956">      return true;</span>
    }

    /**
     * Function need positions.
     *
     * @return true, if successful
     */
    public boolean functionNeedPositions() {
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">      if (functions != null) {</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">        for (SubComponentFunction function : functions) {</span>
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">          if (function.parserFunction.needPositions()) {</span>
<span class="nc" id="L1968">            return true;</span>
          }
        }
      }
<span class="fc" id="L1972">      return false;</span>
    }

    /**
     * Function need arguments.
     *
     * @return the sets the
     */
    public Set&lt;Integer&gt; functionNeedArguments() {
<span class="fc" id="L1981">      Set&lt;Integer&gt; list = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L1982" title="1 of 2 branches missed.">      if (functions != null) {</span>
<span class="fc bfc" id="L1983" title="All 2 branches covered.">        for (SubComponentFunction function : functions) {</span>
<span class="fc" id="L1984">          list.addAll(function.parserFunction.needArgument());</span>
        }
      }
<span class="fc" id="L1987">      return list;</span>
    }

  }

  /**
   * The Class ComponentPosition.
   */
  public static class ComponentPosition implements ComponentStats {

    /** The key. */
    public String key;

    /** The data type. */
    public String dataType;

    /** The stats type. */
    public String statsType;

    /** The stats items. */
    public SortedSet&lt;String&gt; statsItems;

    /** The minimum long. */
    public Long minimumLong;

    /** The maximum long. */
    public Long maximumLong;

    /** The data collector. */
    public MtasDataCollector&lt;?, ?&gt; dataCollector;

    /**
     * Instantiates a new component position.
     *
     * @param key
     *          the key
     * @param minimumDouble
     *          the minimum double
     * @param maximumDouble
     *          the maximum double
     * @param statsType
     *          the stats type
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     * @throws ParseException
     *           the parse exception
     */
<span class="fc" id="L2034">    public ComponentPosition(String key, Double minimumDouble, Double maximumDouble, String statsType)</span>
        throws IOException, ParseException {
<span class="fc" id="L2036">      this.key = key;</span>
<span class="fc" id="L2037">      dataType = CodecUtil.DATA_TYPE_LONG;</span>
<span class="fc" id="L2038">      this.statsItems = CodecUtil.createStatsItems(statsType);</span>
<span class="fc" id="L2039">      this.statsType = CodecUtil.createStatsType(this.statsItems, null, null);</span>
<span class="fc bfc" id="L2040" title="All 2 branches covered.">      if (minimumDouble != null) {</span>
<span class="fc" id="L2041">        this.minimumLong = minimumDouble.longValue();</span>
<span class="fc" id="L2042">      } else {</span>
<span class="fc" id="L2043">        this.minimumLong = null;</span>
      }
<span class="fc bfc" id="L2045" title="All 2 branches covered.">      if (maximumDouble != null) {</span>
<span class="fc" id="L2046">        this.maximumLong = maximumDouble.longValue();</span>
<span class="fc" id="L2047">      } else {</span>
<span class="fc" id="L2048">        this.maximumLong = null;</span>
      }
<span class="fc" id="L2050">      dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_DATA, dataType, this.statsType,</span>
<span class="fc" id="L2051">          this.statsItems, null, null, null, null, null, null);</span>
<span class="fc" id="L2052">    }</span>
  }

  /**
   * The Class ComponentToken.
   */
  public static class ComponentToken implements ComponentStats {

    /** The key. */
    public String key;

    /** The data type. */
    public String dataType;

    /** The stats type. */
    public String statsType;

    /** The stats items. */
    public SortedSet&lt;String&gt; statsItems;

    /** The minimum long. */
    public Long minimumLong;

    /** The maximum long. */
    public Long maximumLong;

    /** The data collector. */
    public MtasDataCollector&lt;?, ?&gt; dataCollector;

    /**
     * Instantiates a new component token.
     *
     * @param key
     *          the key
     * @param minimumDouble
     *          the minimum double
     * @param maximumDouble
     *          the maximum double
     * @param statsType
     *          the stats type
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     * @throws ParseException
     *           the parse exception
     */
<span class="fc" id="L2097">    public ComponentToken(String key, Double minimumDouble, Double maximumDouble, String statsType)</span>
        throws IOException, ParseException {
<span class="fc" id="L2099">      this.key = key;</span>
<span class="fc" id="L2100">      dataType = CodecUtil.DATA_TYPE_LONG;</span>
<span class="fc" id="L2101">      this.statsItems = CodecUtil.createStatsItems(statsType);</span>
<span class="fc" id="L2102">      this.statsType = CodecUtil.createStatsType(this.statsItems, null, null);</span>
<span class="fc bfc" id="L2103" title="All 2 branches covered.">      if (minimumDouble != null) {</span>
<span class="fc" id="L2104">        this.minimumLong = minimumDouble.longValue();</span>
<span class="fc" id="L2105">      } else {</span>
<span class="fc" id="L2106">        this.minimumLong = null;</span>
      }
<span class="fc bfc" id="L2108" title="All 2 branches covered.">      if (maximumDouble != null) {</span>
<span class="fc" id="L2109">        this.maximumLong = maximumDouble.longValue();</span>
<span class="fc" id="L2110">      } else {</span>
<span class="fc" id="L2111">        this.maximumLong = null;</span>
      }
<span class="fc" id="L2113">      dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_DATA, dataType, this.statsType,</span>
<span class="fc" id="L2114">          this.statsItems, null, null, null, null, null, null);</span>
<span class="fc" id="L2115">    }</span>
  }

  /**
   * The Class ComponentCollection.
   */
  public static class ComponentCollection implements BasicComponent {

    /** The Constant ACTION_CREATE. */
    public static final String ACTION_CREATE = &quot;create&quot;;

    /** The Constant ACTION_CHECK. */
    public static final String ACTION_CHECK = &quot;check&quot;;

    /** The Constant ACTION_LIST. */
    public static final String ACTION_LIST = &quot;list&quot;;

    /** The Constant ACTION_POST. */
    public static final String ACTION_POST = &quot;post&quot;;

    /** The Constant ACTION_IMPORT. */
    public static final String ACTION_IMPORT = &quot;import&quot;;

    /** The Constant ACTION_DELETE. */
    public static final String ACTION_DELETE = &quot;delete&quot;;

    /** The Constant ACTION_EMPTY. */
    public static final String ACTION_EMPTY = &quot;empty&quot;;

    /** The Constant ACTION_GET. */
    public static final String ACTION_GET = &quot;get&quot;;

    /** The key. */
    public String key;

    /** The version. */
    public String version;

    /** The original version. */
    public String originalVersion;

    /** The id. */
    public String id;

    /** The action. */
    private String action;

    /** The fields. */
    private Set&lt;String&gt; fields;

    /** The values. */
    private HashSet&lt;String&gt; values;

    /**
     * Instantiates a new component collection.
     *
     * @param key
     *          the key
     * @param action
     *          the action
     */
<span class="fc" id="L2176">    public ComponentCollection(String key, String action) {</span>
<span class="fc" id="L2177">      this.key = key;</span>
<span class="fc" id="L2178">      this.action = action;</span>
<span class="fc" id="L2179">      this.version = null;</span>
<span class="fc" id="L2180">      this.originalVersion = null;</span>
<span class="fc" id="L2181">      values = new HashSet&lt;&gt;();</span>
<span class="fc" id="L2182">    }</span>

    /**
     * Sets the list variables.
     *
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void setListVariables() throws IOException {
<span class="pc bpc" id="L2191" title="1 of 2 branches missed.">      if (action.equals(ACTION_LIST)) {</span>
        // do nothing
      } else {
<span class="nc" id="L2194">        throw new IOException(&quot;not allowed with action &quot; + action);</span>
      }
<span class="fc" id="L2196">    }</span>

    /**
     * Sets the create variables.
     *
     * @param id
     *          the id
     * @param fields
     *          the fields
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void setCreateVariables(String id, Set&lt;String&gt; fields) throws IOException {
<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">      if (action.equals(ACTION_CREATE)) {</span>
<span class="fc" id="L2210">        this.id = id;</span>
<span class="fc" id="L2211">        this.fields = fields;</span>
<span class="fc" id="L2212">      } else {</span>
<span class="nc" id="L2213">        throw new IOException(&quot;not allowed with action &quot; + action);</span>
      }
<span class="fc" id="L2215">    }</span>

    /**
     * Sets the check variables.
     *
     * @param id
     *          the new check variables
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void setCheckVariables(String id) throws IOException {
<span class="pc bpc" id="L2226" title="1 of 2 branches missed.">      if (action.equals(ACTION_CHECK)) {</span>
<span class="fc" id="L2227">        this.id = id;</span>
<span class="fc" id="L2228">      } else {</span>
<span class="nc" id="L2229">        throw new IOException(&quot;not allowed with action &quot; + action);</span>
      }
<span class="fc" id="L2231">    }</span>

    /**
     * Sets the gets the variables.
     *
     * @param id
     *          the new gets the variables
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void setGetVariables(String id) throws IOException {
<span class="nc bnc" id="L2242" title="All 2 branches missed.">      if (action.equals(ACTION_GET)) {</span>
<span class="nc" id="L2243">        this.id = id;</span>
<span class="nc" id="L2244">      } else {</span>
<span class="nc" id="L2245">        throw new IOException(&quot;not allowed with action &quot; + action);</span>
      }
<span class="nc" id="L2247">    }</span>

    /**
     * Sets the post variables.
     *
     * @param id
     *          the id
     * @param values
     *          the values
     * @param originalVersion
     *          the original version
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void setPostVariables(String id, HashSet&lt;String&gt; values, String originalVersion) throws IOException {
<span class="pc bpc" id="L2262" title="1 of 2 branches missed.">      if (action.equals(ACTION_POST)) {</span>
<span class="fc" id="L2263">        this.id = id;</span>
<span class="fc" id="L2264">        this.values = values;</span>
<span class="fc" id="L2265">        this.originalVersion = originalVersion;</span>
<span class="fc" id="L2266">      } else {</span>
<span class="nc" id="L2267">        throw new IOException(&quot;not allowed with action &quot; + action);</span>
      }
<span class="fc" id="L2269">    }</span>

    /**
     * Sets the import variables.
     *
     * @param id
     *          the id
     * @param url
     *          the url
     * @param collection
     *          the collection
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void setImportVariables(String id, String url, String collection) throws IOException {
<span class="nc bnc" id="L2284" title="All 2 branches missed.">      if (action.equals(ACTION_IMPORT)) {</span>
<span class="nc" id="L2285">        this.id = id;</span>
<span class="nc" id="L2286">        StringBuilder importUrlBuffer = new StringBuilder(url);</span>
<span class="nc" id="L2287">        importUrlBuffer.append(&quot;select&quot;);</span>
<span class="nc" id="L2288">        importUrlBuffer.append(&quot;?q=*:*&amp;rows=0&amp;wt=json&quot;);</span>
<span class="nc" id="L2289">        importUrlBuffer.append(&quot;&amp;mtas=true&amp;mtas.collection=true&quot;);</span>
<span class="nc" id="L2290">        importUrlBuffer.append(&quot;&amp;mtas.collection.0.key=0&quot;);</span>
<span class="nc" id="L2291">        importUrlBuffer.append(&quot;&amp;mtas.collection.0.action=get&quot;);</span>
<span class="nc" id="L2292">        importUrlBuffer.append(&quot;&amp;mtas.collection.0.id=&quot; + URLEncoder.encode(collection, &quot;UTF-8&quot;));</span>
<span class="nc" id="L2293">        Map&lt;String, Object&gt; params = getImport(importUrlBuffer.toString());</span>
        try {
<span class="nc bnc" id="L2295" title="All 4 branches missed.">          if (params.containsKey(&quot;mtas&quot;) &amp;&amp; params.get(&quot;mtas&quot;) instanceof Map) {</span>
<span class="nc" id="L2296">            Map&lt;String, Object&gt; mtasParams = (Map&lt;String, Object&gt;) params.get(&quot;mtas&quot;);</span>
<span class="nc bnc" id="L2297" title="All 4 branches missed.">            if (mtasParams.containsKey(&quot;collection&quot;) &amp;&amp; mtasParams.get(&quot;collection&quot;) instanceof List) {</span>
<span class="nc" id="L2298">              List&lt;Object&gt; mtasCollectionList = (List&lt;Object&gt;) mtasParams.get(&quot;collection&quot;);</span>
<span class="nc bnc" id="L2299" title="All 4 branches missed.">              if (mtasCollectionList.size() == 1 &amp;&amp; mtasCollectionList.get(0) instanceof Map) {</span>
<span class="nc" id="L2300">                Map&lt;String, Object&gt; collectionData = (Map&lt;String, Object&gt;) mtasCollectionList.get(0);</span>
<span class="nc bnc" id="L2301" title="All 4 branches missed.">                if (collectionData.containsKey(&quot;values&quot;) &amp;&amp; collectionData.get(&quot;values&quot;) instanceof List) {</span>
<span class="nc" id="L2302">                  List&lt;String&gt; valuesList = (List&lt;String&gt;) collectionData.get(&quot;values&quot;);</span>
<span class="nc bnc" id="L2303" title="All 2 branches missed.">                  for (String valueItem : valuesList) {</span>
<span class="nc" id="L2304">                    values.add(valueItem);</span>
                  }
<span class="nc" id="L2306">                } else {</span>
<span class="nc" id="L2307">                  throw new IOException(&quot;no values in response&quot;);</span>
                }
              } else {
<span class="nc" id="L2310">                throw new IOException(&quot;no valid mtas collection item in response&quot;);</span>
              }
            } else {
<span class="nc" id="L2313">              throw new IOException(&quot;no valid mtas collection in response&quot;);</span>
            }
          } else {
<span class="nc" id="L2316">            throw new IOException(&quot;no valid mtas in response&quot;);</span>
          }
<span class="nc" id="L2318">        } catch (ClassCastException e) {</span>
<span class="nc" id="L2319">          throw new IOException(&quot;unexpected response&quot;, e);</span>
        }
      } else {
<span class="nc" id="L2322">        throw new IOException(&quot;not allowed with action &quot; + action);</span>
      }
<span class="nc" id="L2324">    }</span>

    /**
     * Gets the import.
     *
     * @param collectionGetUrl
     *          the collection get url
     * @return the import
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    private Map&lt;String, Object&gt; getImport(String collectionGetUrl) throws IOException {
      // get data
<span class="nc" id="L2337">      URL url = new URL(collectionGetUrl);</span>
<span class="nc" id="L2338">      HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span>
<span class="nc" id="L2339">      connection.setDoOutput(false);</span>
<span class="nc" id="L2340">      connection.setDoInput(true);</span>
<span class="nc" id="L2341">      connection.setInstanceFollowRedirects(false);</span>
<span class="nc" id="L2342">      connection.setRequestMethod(&quot;GET&quot;);</span>
<span class="nc" id="L2343">      connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);</span>
<span class="nc" id="L2344">      connection.setRequestProperty(&quot;charset&quot;, &quot;utf-8&quot;);</span>
<span class="nc" id="L2345">      connection.setUseCaches(false);</span>
      // process response
<span class="nc" id="L2347">      InputStream is = null;</span>
      try {
<span class="nc" id="L2349">        is = connection.getInputStream();</span>
<span class="nc" id="L2350">      } catch (IOException ioe) {</span>
<span class="nc" id="L2351">        throw new IOException(&quot;Couldn't get data from url&quot;);</span>
      }
<span class="nc" id="L2353">      InputStreamReader in = new InputStreamReader((InputStream) is, &quot;UTF8&quot;);</span>
<span class="nc" id="L2354">      Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2355">      getParamsFromJSON(params, IOUtils.toString(in));</span>
<span class="nc" id="L2356">      connection.disconnect();</span>
<span class="nc" id="L2357">      return params;</span>
    }

    /**
     * Sets the delete variables.
     *
     * @param id
     *          the new delete variables
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void setDeleteVariables(String id) throws IOException {
<span class="pc bpc" id="L2369" title="1 of 2 branches missed.">      if (action.equals(ACTION_DELETE)) {</span>
<span class="fc" id="L2370">        this.id = id;</span>
<span class="fc" id="L2371">      } else {</span>
<span class="nc" id="L2372">        throw new IOException(&quot;not allowed with action &quot; + action);</span>
      }
<span class="fc" id="L2374">    }</span>

    /**
     * Action.
     *
     * @return the string
     */
    public String action() {
<span class="fc" id="L2382">      return action;</span>
    }

    /**
     * Original version.
     *
     * @return the string
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public String originalVersion() throws IOException {
<span class="pc bpc" id="L2393" title="1 of 2 branches missed.">      if (action.equals(ACTION_POST)) {</span>
<span class="fc" id="L2394">        return originalVersion;</span>
      } else {
<span class="nc" id="L2396">        throw new IOException(&quot;unexpected call for &quot; + action);</span>
      }
    }

    /**
     * Values.
     *
     * @return the hash set
     */
    public HashSet&lt;String&gt; values() {
<span class="fc" id="L2406">      return values;</span>
    }

    /**
     * Fields.
     *
     * @return the sets the
     */
    public Set&lt;String&gt; fields() {
<span class="fc" id="L2415">      return fields;</span>
    }

    /**
     * Adds the value.
     *
     * @param value
     *          the value
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public void addValue(String value) throws IOException {
<span class="pc bpc" id="L2427" title="1 of 2 branches missed.">      if (action.equals(ACTION_CREATE)) {</span>
<span class="pc bpc" id="L2428" title="1 of 2 branches missed.">        if (version == null) {</span>
<span class="fc" id="L2429">          values.add(value);</span>
<span class="fc" id="L2430">        } else {</span>
<span class="nc" id="L2431">          throw new IOException(&quot;version already set&quot;);</span>
        }
      } else {
<span class="nc" id="L2434">        throw new IOException(&quot;not allowed for action '&quot; + action + &quot;'&quot;);</span>
      }
<span class="fc" id="L2436">    }</span>

    /**
     * Gets the params from JSON.
     *
     * @param params
     *          the params
     * @param json
     *          the json
     * @return the params from JSON
     */
    private static void getParamsFromJSON(Map&lt;String, Object&gt; params, String json) {
<span class="nc" id="L2448">      JSONParser parser = new JSONParser(json);</span>
      try {
<span class="nc" id="L2450">        Object o = ObjectBuilder.getVal(parser);</span>
<span class="nc bnc" id="L2451" title="All 2 branches missed.">        if (!(o instanceof Map))</span>
<span class="nc" id="L2452">          return;</span>
<span class="nc" id="L2453">        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) o;</span>
        // To make consistent with json.param handling, we should make query
        // params come after json params (i.e. query params should
        // appear to overwrite json params.

        // Solr params are based on String though, so we need to convert
<span class="nc bnc" id="L2459" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L2460">          String key = entry.getKey();</span>
<span class="nc" id="L2461">          Object val = entry.getValue();</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">          if (params.get(key) != null) {</span>
<span class="nc" id="L2463">            continue;</span>
          }

<span class="nc bnc" id="L2466" title="All 2 branches missed.">          if (val == null) {</span>
<span class="nc" id="L2467">            params.remove(key);</span>
<span class="nc" id="L2468">          } else {</span>
<span class="nc" id="L2469">            params.put(key, val);</span>
          }
        }

<span class="nc" id="L2473">      } catch (Exception e) {</span>
        // ignore parse exceptions at this stage, they may be caused by
        // incomplete
        // macro expansions
<span class="nc" id="L2477">        return;</span>
      }

<span class="nc" id="L2480">    }</span>

  }

  /**
   * The Class SubComponentDistance.
   */
  public static class SubComponentDistance implements Serializable {

    /** The Constant serialVersionUID. */
    private static final long serialVersionUID = 1L;

    /** The key. */
    public String key;

    /** The type. */
    public String type;

    /** The base. */
    public String base;

    /** The prefix. */
    public String prefix;

    /** The minimum. */
    public Double minimum;

    /** The maximum. */
    public Double maximum;

    /** The parameters. */
    public Map&lt;String, String&gt; parameters;

    /** The distance. */
<span class="nc" id="L2514">    public transient Distance distance = null;</span>

    /** The Constant NAME_LEVENSHTEIN. */
    private static final String NAME_LEVENSHTEIN = &quot;levenshtein&quot;;

    /** The Constant NAME_DAMERAULEVENSHTEIN. */
    private static final String NAME_DAMERAULEVENSHTEIN = &quot;damerau-levenshtein&quot;;

    /** The Constant NAME_MORSE. */
    private static final String NAME_MORSE = &quot;morse&quot;;

    /**
     * Instantiates a new sub component distance.
     *
     * @param key
     *          the key
     * @param type
     *          the type
     * @param prefix
     *          the prefix
     * @param base
     *          the base
     * @param parameters
     *          the parameters
     * @param minimum
     *          the minimum
     * @param maximum
     *          the maximum
     */
<span class="nc" id="L2543">    public SubComponentDistance(String key, String type, String prefix, String base, Map&lt;String, String&gt; parameters,</span>
        String minimum, String maximum) {
<span class="nc" id="L2545">      this.key = key;</span>
<span class="nc" id="L2546">      this.prefix = prefix;</span>
<span class="nc" id="L2547">      this.type = type;</span>
<span class="nc" id="L2548">      this.base = base;</span>
<span class="nc" id="L2549">      this.parameters = parameters;</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">      this.minimum = minimum != null ? Double.parseDouble(minimum) : null;</span>
<span class="nc bnc" id="L2551" title="All 2 branches missed.">      this.maximum = maximum != null ? Double.parseDouble(maximum) : null;</span>
<span class="nc" id="L2552">    }</span>

    /**
     * Gets the distance.
     *
     * @return the distance
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
    public Distance getDistance() throws IOException {
<span class="nc bnc" id="L2562" title="All 2 branches missed.">      if (distance == null) {</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">        if (type != null) {</span>
          try {
<span class="nc" id="L2565">            Constructor&lt;Distance&gt; constructor = (Constructor&lt;Distance&gt;) Class</span>
<span class="nc" id="L2566">                .forName(&quot;mtas.codec.util.distance.&quot; + createClassName(type) + &quot;Distance&quot;)</span>
<span class="nc" id="L2567">                .getConstructor(String.class, String.class, Double.class, Double.class, Map.class);</span>
<span class="nc" id="L2568">            distance = constructor.newInstance(prefix, base, minimum, maximum, parameters);</span>
<span class="nc" id="L2569">          } catch (ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException</span>
<span class="nc" id="L2570">              | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {</span>
<span class="nc" id="L2571">            throw new IllegalStateException(e);</span>
          }
          // distance = new MorseDistance(prefix, base, maximum, parameters);
        } else {
<span class="nc" id="L2575">          throw new IOException(&quot;unrecognized distance &quot; + type);</span>
        }
      }
<span class="nc" id="L2578">      return distance;</span>
    }

    /**
     * Creates the class name.
     *
     * @param type
     *          the type
     * @return the string
     */
    private String createClassName(String type) {
<span class="nc" id="L2589">      final char DASH = '-';</span>
<span class="nc" id="L2590">      Objects.requireNonNull(type, &quot;Type is obligatory&quot;);</span>
<span class="nc" id="L2591">      final StringBuilder output = new StringBuilder(type.length());</span>
<span class="nc" id="L2592">      boolean lastCharacterWasDash = true;</span>
      boolean thisCharacterWasDash;
<span class="nc bnc" id="L2594" title="All 2 branches missed.">      for (final char currentCharacter : type.toCharArray()) {</span>
<span class="nc bnc" id="L2595" title="All 2 branches missed.">        thisCharacterWasDash = (currentCharacter == DASH);</span>
<span class="nc bnc" id="L2596" title="All 2 branches missed.">        if (!thisCharacterWasDash) {</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">          if (lastCharacterWasDash) {</span>
<span class="nc" id="L2598">            output.append(Character.toTitleCase(currentCharacter));</span>
<span class="nc" id="L2599">          } else {</span>
<span class="nc" id="L2600">            output.append(currentCharacter);</span>
          }
        }
<span class="nc" id="L2603">        lastCharacterWasDash = thisCharacterWasDash;</span>
      }
<span class="nc" id="L2605">      return output.toString();</span>
    }

  }

  /**
   * The Class SubComponentFunction.
   */
  public static class SubComponentFunction {

    /** The key. */
    public String key;

    /** The expression. */
    public String expression;

    /** The type. */
    public String type;

    /** The parser function. */
    public MtasFunctionParserFunction parserFunction;

    /** The stats type. */
    public String statsType;

    /** The data type. */
    public String dataType;

    /** The sort type. */
    public String sortType;

    /** The sort direction. */
    public String sortDirection;

    /** The stats items. */
    public SortedSet&lt;String&gt; statsItems;

    /** The data collector. */
    public MtasDataCollector&lt;?, ?&gt; dataCollector;

    /**
     * Instantiates a new sub component function.
     *
     * @param collectorType
     *          the collector type
     * @param key
     *          the key
     * @param type
     *          the type
     * @param parserFunction
     *          the parser function
     * @param sortType
     *          the sort type
     * @param sortDirection
     *          the sort direction
     * @param start
     *          the start
     * @param number
     *          the number
     * @param segmentRegistration
     *          the segment registration
     * @param boundary
     *          the boundary
     * @throws ParseException
     *           the parse exception
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="fc" id="L2673">    public SubComponentFunction(String collectorType, String key, String type,</span>
        MtasFunctionParserFunction parserFunction, String sortType, String sortDirection, Integer start, Integer number,
        String segmentRegistration, String boundary) throws ParseException, IOException {
<span class="fc" id="L2676">      this.key = key;</span>
<span class="fc" id="L2677">      this.expression = null;</span>
<span class="fc" id="L2678">      this.type = type;</span>
<span class="fc" id="L2679">      this.parserFunction = parserFunction;</span>
<span class="fc" id="L2680">      this.sortType = sortType;</span>
<span class="fc" id="L2681">      this.sortDirection = sortDirection;</span>
<span class="fc" id="L2682">      this.dataType = parserFunction.getType();</span>
<span class="fc" id="L2683">      this.statsItems = CodecUtil.createStatsItems(this.type);</span>
<span class="fc" id="L2684">      this.statsType = CodecUtil.createStatsType(statsItems, sortType, parserFunction);</span>
<span class="pc bpc" id="L2685" title="1 of 2 branches missed.">      if (collectorType.equals(DataCollector.COLLECTOR_TYPE_LIST)) {</span>
<span class="fc" id="L2686">        dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_LIST, dataType, statsType, statsItems,</span>
<span class="fc" id="L2687">            sortType, sortDirection, start, number, null, null, null, null, null, null, null, null, segmentRegistration,</span>
<span class="fc" id="L2688">            boundary);</span>
<span class="pc bnc" id="L2689" title="All 2 branches missed.">      } else if (collectorType.equals(DataCollector.COLLECTOR_TYPE_DATA)) {</span>
<span class="nc" id="L2690">        dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_DATA, dataType, statsType, statsItems,</span>
<span class="nc" id="L2691">            sortType, sortDirection, start, number, segmentRegistration, boundary);</span>
      }
<span class="fc" id="L2693">    }</span>

    /**
     * Instantiates a new sub component function.
     *
     * @param collectorType
     *          the collector type
     * @param key
     *          the key
     * @param expression
     *          the expression
     * @param type
     *          the type
     * @throws ParseException
     *           the parse exception
     * @throws IOException
     *           Signals that an I/O exception has occurred.
     */
<span class="fc" id="L2711">    public SubComponentFunction(String collectorType, String key, String expression, String type)</span>
        throws ParseException, IOException {
<span class="fc" id="L2713">      this.key = key;</span>
<span class="fc" id="L2714">      this.expression = expression;</span>
<span class="fc" id="L2715">      this.type = type;</span>
<span class="fc" id="L2716">      this.sortType = null;</span>
<span class="fc" id="L2717">      this.sortDirection = null;</span>
<span class="fc" id="L2718">      parserFunction = new MtasFunctionParser(new BufferedReader(new StringReader(this.expression))).parse();</span>
<span class="fc" id="L2719">      dataType = parserFunction.getType();</span>
<span class="fc" id="L2720">      statsItems = CodecUtil.createStatsItems(this.type);</span>
<span class="fc" id="L2721">      statsType = CodecUtil.createStatsType(statsItems, null, parserFunction);</span>
<span class="fc bfc" id="L2722" title="All 2 branches covered.">      if (collectorType.equals(DataCollector.COLLECTOR_TYPE_LIST)) {</span>
<span class="fc" id="L2723">        dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_LIST, dataType, statsType, statsItems,</span>
<span class="fc" id="L2724">            sortType, sortDirection, 0, Integer.MAX_VALUE, null, null);</span>
<span class="pc bpc" id="L2725" title="1 of 2 branches missed.">      } else if (collectorType.equals(DataCollector.COLLECTOR_TYPE_DATA)) {</span>
<span class="fc" id="L2726">        dataCollector = DataCollector.getCollector(DataCollector.COLLECTOR_TYPE_DATA, dataType, statsType, statsItems,</span>
<span class="fc" id="L2727">            sortType, sortDirection, null, null, null, null);</span>
      }
<span class="fc" id="L2729">    }</span>
  }

  /**
   * The Class KwicToken.
   */
  public static class KwicToken {

    /** The start position. */
    public int startPosition;

    /** The end position. */
    public int endPosition;

    /** The tokens. */
    public List&lt;MtasTokenString&gt; tokens;

    /**
     * Instantiates a new kwic token.
     *
     * @param match
     *          the match
     * @param tokens
     *          the tokens
     */
<span class="nc" id="L2754">    public KwicToken(Match match, List&lt;MtasTokenString&gt; tokens) {</span>
<span class="nc" id="L2755">      startPosition = match.startPosition;</span>
<span class="nc" id="L2756">      endPosition = match.endPosition - 1;</span>
<span class="nc" id="L2757">      this.tokens = tokens;</span>
<span class="nc" id="L2758">    }</span>

  }

  /**
   * The Class KwicHit.
   */
  public static class KwicHit {

    /** The start position. */
    public int startPosition;

    /** The end position. */
    public int endPosition;

    /** The hits. */
    public Map&lt;Integer, List&lt;String&gt;&gt; hits;

    /**
     * Instantiates a new kwic hit.
     *
     * @param match
     *          the match
     * @param hits
     *          the hits
     */
<span class="nc" id="L2784">    public KwicHit(Match match, Map&lt;Integer, List&lt;String&gt;&gt; hits) {</span>
<span class="nc" id="L2785">      startPosition = match.startPosition;</span>
<span class="nc" id="L2786">      endPosition = match.endPosition - 1;</span>
<span class="nc" id="L2787">      this.hits = hits;</span>
<span class="nc" id="L2788">    }</span>
  }

  /**
   * The Class GroupHit.
   */
  public static class GroupHit {

    /** The hash. */
    private int hash;

    /** The hash left. */
    private int hashLeft;

    /** The hash hit. */
    private int hashHit;

    /** The hash right. */
    private int hashRight;

    /** The key. */
    private String key;

    /** The key left. */
    private String keyLeft;

    /** The key hit. */
    private String keyHit;

    /** The key right. */
    private String keyRight;

    /** The data hit. */
    public List&lt;String&gt;[] dataHit;

    /** The data left. */
    public List&lt;String&gt;[] dataLeft;

    /** The data right. */
    public List&lt;String&gt;[] dataRight;

    /** The missing hit. */
    public Set&lt;String&gt;[] missingHit;

    /** The missing left. */
    public Set&lt;String&gt;[] missingLeft;

    /** The missing right. */
    public Set&lt;String&gt;[] missingRight;

    /** The unknown hit. */
    public Set&lt;String&gt;[] unknownHit;

    /** The unknown left. */
    public Set&lt;String&gt;[] unknownLeft;

    /** The unknown right. */
    public Set&lt;String&gt;[] unknownRight;

    /** The Constant KEY_START. */
    public static final String KEY_START = MtasToken.DELIMITER + &quot;grouphit&quot; + MtasToken.DELIMITER;

    /**
     * Sort.
     *
     * @param data
     *          the data
     * @return the list
     */
    private List&lt;MtasTreeHit&lt;String&gt;&gt; sort(List&lt;MtasTreeHit&lt;String&gt;&gt; data) {
<span class="fc" id="L2858">      Collections.sort(data, new Comparator&lt;MtasTreeHit&lt;String&gt;&gt;() {</span>
        @Override
        public int compare(MtasTreeHit&lt;String&gt; hit1, MtasTreeHit&lt;String&gt; hit2) {
<span class="fc" id="L2861">          int compare = Integer.compare(hit1.additionalId, hit2.additionalId);</span>
<span class="fc bfc" id="L2862" title="All 2 branches covered.">          compare = (compare == 0) ? Long.compare(hit1.additionalRef, hit2.additionalRef) : compare;</span>
<span class="fc" id="L2863">          return compare;</span>
        }
      });
<span class="fc" id="L2866">      return data;</span>
    }

    /**
     * Instantiates a new group hit.
     *
     * @param list
     *          the list
     * @param start
     *          the start
     * @param end
     *          the end
     * @param hitStart
     *          the hit start
     * @param hitEnd
     *          the hit end
     * @param group
     *          the group
     * @param knownPrefixes
     *          the known prefixes
     * @throws UnsupportedEncodingException
     *           the unsupported encoding exception
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L2890">    public GroupHit(List&lt;MtasTreeHit&lt;String&gt;&gt; list, int start, int end, int hitStart, int hitEnd, ComponentGroup group,</span>
        Set&lt;String&gt; knownPrefixes) throws UnsupportedEncodingException {
      // compute dimensions
<span class="fc" id="L2893">      int leftRangeStart = start;</span>
<span class="fc" id="L2894">      int leftRangeEnd = Math.min(end, hitStart - 1);</span>
<span class="fc" id="L2895">      int leftRangeLength = Math.max(0, 1 + leftRangeEnd - leftRangeStart);</span>
<span class="fc" id="L2896">      int hitLength = 1 + hitEnd - hitStart;</span>
<span class="fc" id="L2897">      int rightRangeStart = Math.max(start, hitEnd + 1);</span>
<span class="fc" id="L2898">      int rightRangeEnd = end;</span>
<span class="fc" id="L2899">      int rightRangeLength = Math.max(0, 1 + rightRangeEnd - rightRangeStart);</span>
      // create initial arrays
<span class="fc bfc" id="L2901" title="All 2 branches covered.">      if (leftRangeLength &gt; 0) {</span>
<span class="fc" id="L2902">        keyLeft = &quot;&quot;;</span>
<span class="fc" id="L2903">        dataLeft = (ArrayList&lt;String&gt;[]) new ArrayList[leftRangeLength];</span>
<span class="fc" id="L2904">        missingLeft = (HashSet&lt;String&gt;[]) new HashSet[leftRangeLength];</span>
<span class="fc" id="L2905">        unknownLeft = (HashSet&lt;String&gt;[]) new HashSet[leftRangeLength];</span>
<span class="fc bfc" id="L2906" title="All 2 branches covered.">        for (int p = 0; p &lt; leftRangeLength; p++) {</span>
<span class="fc" id="L2907">          dataLeft[p] = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2908">          missingLeft[p] = new HashSet&lt;&gt;();</span>
<span class="fc" id="L2909">          unknownLeft[p] = new HashSet&lt;&gt;();</span>
        }
<span class="fc" id="L2911">      } else {</span>
<span class="fc" id="L2912">        keyLeft = null;</span>
<span class="fc" id="L2913">        dataLeft = null;</span>
<span class="fc" id="L2914">        missingLeft = null;</span>
<span class="fc" id="L2915">        unknownLeft = null;</span>
      }
<span class="pc bpc" id="L2917" title="1 of 2 branches missed.">      if (hitLength &gt; 0) {</span>
<span class="fc" id="L2918">        keyHit = &quot;&quot;;</span>
<span class="fc" id="L2919">        dataHit = (ArrayList&lt;String&gt;[]) new ArrayList[hitLength];</span>
<span class="fc" id="L2920">        missingHit = (HashSet&lt;String&gt;[]) new HashSet[hitLength];</span>
<span class="fc" id="L2921">        unknownHit = (HashSet&lt;String&gt;[]) new HashSet[hitLength];</span>
<span class="fc bfc" id="L2922" title="All 2 branches covered.">        for (int p = 0; p &lt; hitLength; p++) {</span>
<span class="fc" id="L2923">          dataHit[p] = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2924">          missingHit[p] = new HashSet&lt;&gt;();</span>
<span class="fc" id="L2925">          unknownHit[p] = new HashSet&lt;&gt;();</span>
        }
<span class="fc" id="L2927">      } else {</span>
<span class="nc" id="L2928">        keyHit = null;</span>
<span class="nc" id="L2929">        dataHit = null;</span>
<span class="nc" id="L2930">        missingHit = null;</span>
<span class="nc" id="L2931">        unknownHit = null;</span>
      }
<span class="fc bfc" id="L2933" title="All 2 branches covered.">      if (rightRangeLength &gt; 0) {</span>
<span class="fc" id="L2934">        keyRight = &quot;&quot;;</span>
<span class="fc" id="L2935">        dataRight = (ArrayList&lt;String&gt;[]) new ArrayList[rightRangeLength];</span>
<span class="fc" id="L2936">        missingRight = (HashSet&lt;String&gt;[]) new HashSet[rightRangeLength];</span>
<span class="fc" id="L2937">        unknownRight = (HashSet&lt;String&gt;[]) new HashSet[rightRangeLength];</span>
<span class="fc bfc" id="L2938" title="All 2 branches covered.">        for (int p = 0; p &lt; rightRangeLength; p++) {</span>
<span class="fc" id="L2939">          dataRight[p] = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2940">          missingRight[p] = new HashSet&lt;&gt;();</span>
<span class="fc" id="L2941">          unknownRight[p] = new HashSet&lt;&gt;();</span>
        }
<span class="fc" id="L2943">      } else {</span>
<span class="fc" id="L2944">        keyRight = null;</span>
<span class="fc" id="L2945">        dataRight = null;</span>
<span class="fc" id="L2946">        missingRight = null;</span>
<span class="fc" id="L2947">        unknownRight = null;</span>
      }

      // construct missing sets
<span class="fc bfc" id="L2951" title="All 2 branches covered.">      if (group.hitInside != null) {</span>
<span class="fc bfc" id="L2952" title="All 2 branches covered.">        for (int p = hitStart; p &lt;= hitEnd; p++) {</span>
<span class="fc" id="L2953">          missingHit[p - hitStart].addAll(group.hitInside);</span>
        }
      }
<span class="fc bfc" id="L2956" title="All 2 branches covered.">      if (group.hitInsideLeft != null) {</span>
<span class="fc bfc" id="L2957" title="All 2 branches covered.">        for (int p = hitStart; p &lt;= Math.min(hitEnd, hitStart + group.hitInsideLeft.length - 1); p++) {</span>
<span class="pc bpc" id="L2958" title="1 of 2 branches missed.">          if (group.hitInsideLeft[p - hitStart] != null) {</span>
<span class="fc" id="L2959">            missingHit[p - hitStart].addAll(group.hitInsideLeft[p - hitStart]);</span>
          }
        }
      }
<span class="fc bfc" id="L2963" title="All 2 branches covered.">      if (group.hitLeft != null) {</span>
<span class="fc bfc" id="L2964" title="All 2 branches covered.">        for (int p = hitStart; p &lt;= Math.min(hitEnd, hitStart + group.hitLeft.length - 1); p++) {</span>
<span class="pc bpc" id="L2965" title="1 of 2 branches missed.">          if (group.hitLeft[p - hitStart] != null) {</span>
<span class="fc" id="L2966">            missingHit[p - hitStart].addAll(group.hitLeft[p - hitStart]);</span>
          }
        }
      }
<span class="fc bfc" id="L2970" title="All 2 branches covered.">      if (group.hitInsideRight != null) {</span>
<span class="fc bfc" id="L2971" title="All 2 branches covered.">        for (int p = Math.max(hitStart, hitEnd - group.hitInsideRight.length + 1); p &lt;= hitEnd; p++) {</span>
<span class="fc bfc" id="L2972" title="All 2 branches covered.">          if (group.hitInsideRight[hitEnd - p] != null) {</span>
<span class="fc" id="L2973">            missingHit[p - hitStart].addAll(group.hitInsideRight[hitEnd - p]);</span>
          }
        }
      }
<span class="fc bfc" id="L2977" title="All 2 branches covered.">      if (group.hitRight != null) {</span>
<span class="fc bfc" id="L2978" title="All 2 branches covered.">        for (int p = hitStart; p &lt;= Math.min(hitEnd, hitStart + group.hitRight.length - 1); p++) {</span>
<span class="fc bfc" id="L2979" title="All 2 branches covered.">          if (group.hitRight[p - hitStart] != null) {</span>
<span class="fc" id="L2980">            missingHit[p - hitStart].addAll(group.hitRight[p - hitStart]);</span>
          }
        }
      }
<span class="fc bfc" id="L2984" title="All 2 branches covered.">      if (group.left != null) {</span>
<span class="fc bfc" id="L2985" title="All 2 branches covered.">        for (int p = 0; p &lt; Math.min(leftRangeLength, group.left.length); p++) {</span>
<span class="fc bfc" id="L2986" title="All 2 branches covered.">          if (group.left[p] != null) {</span>
<span class="fc" id="L2987">            missingLeft[p].addAll(group.left[p]);</span>
          }
        }
      }
<span class="fc bfc" id="L2991" title="All 2 branches covered.">      if (group.hitRight != null) {</span>
<span class="fc bfc" id="L2992" title="All 2 branches covered.">        for (int p = 0; p &lt; Math.min(leftRangeLength, group.hitRight.length - dataHit.length); p++) {</span>
<span class="pc bpc" id="L2993" title="1 of 2 branches missed.">          if (group.hitRight[p + dataHit.length] != null) {</span>
<span class="fc" id="L2994">            missingLeft[p].addAll(group.hitRight[p + dataHit.length]);</span>
          }
        }
      }
<span class="fc bfc" id="L2998" title="All 2 branches covered.">      if (group.right != null) {</span>
<span class="fc bfc" id="L2999" title="All 2 branches covered.">        for (int p = 0; p &lt; Math.min(rightRangeLength, group.right.length); p++) {</span>
<span class="fc bfc" id="L3000" title="All 2 branches covered.">          if (group.right[p] != null) {</span>
<span class="fc" id="L3001">            missingRight[p].addAll(group.right[p]);</span>
          }
        }
      }
<span class="fc bfc" id="L3005" title="All 2 branches covered.">      if (group.hitLeft != null) {</span>
<span class="fc bfc" id="L3006" title="All 2 branches covered.">        for (int p = 0; p &lt; Math.min(rightRangeLength, group.hitLeft.length - dataHit.length); p++) {</span>
<span class="pc bpc" id="L3007" title="1 of 2 branches missed.">          if (group.hitLeft[p + dataHit.length] != null) {</span>
<span class="fc" id="L3008">            missingRight[p].addAll(group.hitLeft[p + dataHit.length]);</span>
          }
        }
      }

      // fill arrays and update missing administration
<span class="fc" id="L3014">      List&lt;MtasTreeHit&lt;String&gt;&gt; sortedList = sort(list);</span>
<span class="fc bfc" id="L3015" title="All 2 branches covered.">      for (MtasTreeHit&lt;String&gt; hit : sortedList) {</span>
        // inside hit
<span class="pc bpc" id="L3017" title="1 of 6 branches missed.">        if (group.hitInside != null &amp;&amp; hit.idData != null &amp;&amp; group.hitInside.contains(hit.idData)) {</span>
<span class="fc bfc" id="L3018" title="All 2 branches covered.">          for (int p = Math.max(hitStart, hit.startPosition); p &lt;= Math.min(hitEnd, hit.endPosition); p++) {</span>
<span class="fc" id="L3019">            dataHit[p - hitStart].add(hit.refData);</span>
<span class="fc" id="L3020">            missingHit[p - hitStart].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
          }
<span class="fc bfc" id="L3022" title="All 6 branches covered.">        } else if ((group.hitInsideLeft != null || group.hitLeft != null || group.hitInsideRight != null</span>
<span class="pc bpc" id="L3023" title="1 of 4 branches missed.">            || group.hitRight != null) &amp;&amp; hit.idData != null) {</span>
<span class="fc bfc" id="L3024" title="All 2 branches covered.">          for (int p = Math.max(hitStart, hit.startPosition); p &lt;= Math.min(hitEnd, hit.endPosition); p++) {</span>
<span class="fc" id="L3025">            int pHitLeft = p - hitStart;</span>
<span class="fc" id="L3026">            int pHitRight = hitEnd - p;</span>
<span class="pc bpc" id="L3027" title="1 of 4 branches missed.">            if (group.hitInsideLeft != null &amp;&amp; pHitLeft &lt;= (group.hitInsideLeft.length - 1)</span>
<span class="pc bpc" id="L3028" title="1 of 4 branches missed.">                &amp;&amp; group.hitInsideLeft[pHitLeft] != null &amp;&amp; group.hitInsideLeft[pHitLeft].contains(hit.idData)) {</span>
              // keyHit += hit.refData;
<span class="fc" id="L3030">              dataHit[p - hitStart].add(hit.refData);</span>
<span class="fc" id="L3031">              missingHit[p - hitStart].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
<span class="pc bpc" id="L3032" title="1 of 4 branches missed.">            } else if (group.hitLeft != null &amp;&amp; pHitLeft &lt;= (group.hitLeft.length - 1)</span>
<span class="pc bpc" id="L3033" title="1 of 4 branches missed.">                &amp;&amp; group.hitLeft[pHitLeft] != null &amp;&amp; group.hitLeft[pHitLeft].contains(hit.idData)) {</span>
              // keyHit += hit.refData;
<span class="fc" id="L3035">              dataHit[p - hitStart].add(hit.refData);</span>
<span class="fc" id="L3036">              missingHit[p - hitStart].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
<span class="pc bpc" id="L3037" title="1 of 4 branches missed.">            } else if (group.hitInsideRight != null &amp;&amp; pHitRight &lt;= (group.hitInsideRight.length - 1)</span>
<span class="fc bfc" id="L3038" title="All 4 branches covered.">                &amp;&amp; group.hitInsideRight[pHitRight] != null &amp;&amp; group.hitInsideRight[pHitRight].contains(hit.idData)) {</span>
<span class="fc" id="L3039">              dataHit[p - hitStart].add(hit.refData);</span>
<span class="fc" id="L3040">              missingHit[p - hitStart].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
<span class="pc bpc" id="L3041" title="1 of 4 branches missed.">            } else if (group.hitRight != null &amp;&amp; pHitRight &lt;= (group.hitRight.length - 1)</span>
<span class="fc bfc" id="L3042" title="All 4 branches covered.">                &amp;&amp; group.hitRight[pHitRight] != null &amp;&amp; group.hitRight[pHitRight].contains(hit.idData)) {</span>
<span class="fc" id="L3043">              dataHit[p - hitStart].add(hit.refData);</span>
<span class="fc" id="L3044">              missingHit[p - hitStart].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
            }
          }
        }
        // left
<span class="fc bfc" id="L3049" title="All 2 branches covered.">        if (hit.startPosition &lt; hitStart) {</span>
<span class="pc bpc" id="L3050" title="2 of 6 branches missed.">          if ((group.left != null || (group.hitRight != null &amp;&amp; group.hitRight.length &gt; (1 + hitEnd - hitStart)))</span>
<span class="pc bpc" id="L3051" title="1 of 2 branches missed.">              &amp;&amp; hit.idData != null) {</span>
<span class="fc bfc" id="L3052" title="All 2 branches covered.">            for (int p = Math.min(hit.endPosition, hitStart - 1); p &gt;= hit.startPosition; p--) {</span>
<span class="fc" id="L3053">              int pLeft = hitStart - 1 - p;</span>
<span class="fc" id="L3054">              int pHitRight = hitEnd - p;</span>
<span class="fc bfc" id="L3055" title="All 6 branches covered.">              if (group.left != null &amp;&amp; pLeft &lt;= (group.left.length - 1) &amp;&amp; group.left[pLeft] != null</span>
<span class="fc bfc" id="L3056" title="All 2 branches covered.">                  &amp;&amp; group.left[pLeft].contains(hit.idData)) {</span>
<span class="fc" id="L3057">                dataLeft[hitStart - 1 - p].add(hit.refData);</span>
<span class="fc" id="L3058">                missingLeft[hitStart - 1 - p].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
<span class="fc bfc" id="L3059" title="All 4 branches covered.">              } else if (group.hitRight != null &amp;&amp; pHitRight &lt;= (group.hitRight.length - 1)</span>
<span class="pc bpc" id="L3060" title="1 of 4 branches missed.">                  &amp;&amp; group.hitRight[pHitRight] != null &amp;&amp; group.hitRight[pHitRight].contains(hit.idData)) {</span>
<span class="fc" id="L3061">                dataLeft[hitStart - 1 - p].add(hit.refData);</span>
<span class="fc" id="L3062">                missingLeft[hitStart - 1 - p].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
              }
            }
          }
        }
        // right
<span class="fc bfc" id="L3068" title="All 2 branches covered.">        if (hit.endPosition &gt; hitEnd) {</span>
<span class="pc bpc" id="L3069" title="2 of 6 branches missed.">          if ((group.right != null || (group.hitLeft != null &amp;&amp; group.hitLeft.length &gt; (1 + hitEnd - hitStart)))</span>
<span class="pc bpc" id="L3070" title="1 of 2 branches missed.">              &amp;&amp; hit.idData != null) {</span>
<span class="fc bfc" id="L3071" title="All 2 branches covered.">            for (int p = Math.max(hit.startPosition, hitEnd + 1); p &lt;= hit.endPosition; p++) {</span>
<span class="fc" id="L3072">              int pRight = p - hitEnd - 1;</span>
<span class="fc" id="L3073">              int pHitLeft = p - hitStart;</span>
<span class="fc bfc" id="L3074" title="All 6 branches covered.">              if (group.right != null &amp;&amp; pRight &lt;= (group.right.length - 1) &amp;&amp; group.right[pRight] != null</span>
<span class="fc bfc" id="L3075" title="All 2 branches covered.">                  &amp;&amp; group.right[pRight].contains(hit.idData)) {</span>
<span class="fc" id="L3076">                dataRight[p - rightRangeStart].add(hit.refData);</span>
<span class="fc" id="L3077">                missingRight[p - rightRangeStart].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
<span class="fc bfc" id="L3078" title="All 4 branches covered.">              } else if (group.hitLeft != null &amp;&amp; pHitLeft &lt;= (group.hitLeft.length - 1)</span>
<span class="pc bpc" id="L3079" title="1 of 4 branches missed.">                  &amp;&amp; group.hitLeft[pHitLeft] != null &amp;&amp; group.hitLeft[pHitLeft].contains(hit.idData)) {</span>
<span class="fc" id="L3080">                dataRight[p - rightRangeStart].add(hit.refData);</span>
<span class="fc" id="L3081">                missingRight[p - rightRangeStart].remove(MtasToken.getPrefixFromValue(hit.refData));</span>
              }
            }
          }
        }
      }
      // register unknown
<span class="fc bfc" id="L3088" title="All 2 branches covered.">      if (missingLeft != null) {</span>
<span class="fc bfc" id="L3089" title="All 2 branches covered.">        for (int i = 0; i &lt; missingLeft.length; i++) {</span>
<span class="fc bfc" id="L3090" title="All 2 branches covered.">          for (String prefix : missingLeft[i]) {</span>
<span class="pc bpc" id="L3091" title="1 of 2 branches missed.">            if (!knownPrefixes.contains(prefix)) {</span>
<span class="nc" id="L3092">              unknownLeft[i].add(prefix);</span>
            }
          }
        }
      }
<span class="pc bpc" id="L3097" title="1 of 2 branches missed.">      if (missingHit != null) {</span>
<span class="fc bfc" id="L3098" title="All 2 branches covered.">        for (int i = 0; i &lt; missingHit.length; i++) {</span>
<span class="fc bfc" id="L3099" title="All 2 branches covered.">          for (String prefix : missingHit[i]) {</span>
<span class="pc bpc" id="L3100" title="1 of 2 branches missed.">            if (!knownPrefixes.contains(prefix)) {</span>
<span class="nc" id="L3101">              unknownHit[i].add(prefix);</span>
            }
          }
        }
      }
<span class="fc bfc" id="L3106" title="All 2 branches covered.">      if (missingRight != null) {</span>
<span class="fc bfc" id="L3107" title="All 2 branches covered.">        for (int i = 0; i &lt; missingRight.length; i++) {</span>
<span class="pc bpc" id="L3108" title="1 of 2 branches missed.">          for (String prefix : missingRight[i]) {</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">            if (!knownPrefixes.contains(prefix)) {</span>
<span class="nc" id="L3110">              unknownRight[i].add(prefix);</span>
            }
          }
        }
      }
      // construct keys
<span class="fc" id="L3116">      keyLeft = dataToString(dataLeft, missingLeft, true);</span>
<span class="fc" id="L3117">      keyHit = dataToString(dataHit, missingHit, false);</span>
<span class="fc" id="L3118">      keyRight = dataToString(dataRight, missingRight, false);</span>
<span class="fc" id="L3119">      key = KEY_START;</span>
<span class="fc bfc" id="L3120" title="All 2 branches covered.">      if (keyLeft != null) {</span>
<span class="fc" id="L3121">        key += keyLeft;</span>
<span class="fc" id="L3122">        hashLeft = keyLeft.hashCode();</span>
<span class="fc" id="L3123">      } else {</span>
<span class="fc" id="L3124">        hashLeft = 1;</span>
      }
<span class="fc" id="L3126">      key += &quot;|&quot;;</span>
<span class="pc bpc" id="L3127" title="1 of 2 branches missed.">      if (keyHit != null) {</span>
<span class="fc" id="L3128">        key += keyHit;</span>
<span class="fc" id="L3129">        hashHit = keyHit.hashCode();</span>
<span class="fc" id="L3130">      } else {</span>
<span class="nc" id="L3131">        hashHit = 1;</span>
      }
<span class="fc" id="L3133">      key += &quot;|&quot;;</span>
<span class="fc bfc" id="L3134" title="All 2 branches covered.">      if (keyRight != null) {</span>
<span class="fc" id="L3135">        key += keyRight;</span>
<span class="fc" id="L3136">        hashRight = keyRight.hashCode();</span>
<span class="fc" id="L3137">      } else {</span>
<span class="fc" id="L3138">        hashRight = 1;</span>
      }
      // compute hash
<span class="fc" id="L3141">      hash = hashHit * (hashLeft ^ 3) * (hashRight ^ 5);</span>
<span class="fc" id="L3142">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="fc" id="L3151">      return hash;</span>
    }

    /**
     * Data equals.
     *
     * @param d1
     *          the d 1
     * @param d2
     *          the d 2
     * @return true, if successful
     */
    private boolean dataEquals(List&lt;String&gt;[] d1, List&lt;String&gt;[] d2) {
      List&lt;String&gt; a1;
      List&lt;String&gt; a2;
<span class="pc bpc" id="L3166" title="1 of 4 branches missed.">      if (d1 == null &amp;&amp; d2 == null) {</span>
<span class="fc" id="L3167">        return true;</span>
<span class="pc bpc" id="L3168" title="2 of 4 branches missed.">      } else if (d1 == null || d2 == null) {</span>
<span class="nc" id="L3169">        return false;</span>
      } else {
<span class="pc bpc" id="L3171" title="1 of 2 branches missed.">        if (d1.length == d2.length) {</span>
<span class="fc bfc" id="L3172" title="All 2 branches covered.">          for (int i = 0; i &lt; d1.length; i++) {</span>
<span class="fc" id="L3173">            a1 = d1[i];</span>
<span class="fc" id="L3174">            a2 = d2[i];</span>
<span class="pc bpc" id="L3175" title="3 of 6 branches missed.">            if (a1 != null &amp;&amp; a2 != null &amp;&amp; a1.size() == a2.size()) {</span>
<span class="fc bfc" id="L3176" title="All 2 branches covered.">              for (int j = 0; j &lt; a1.size(); j++) {</span>
<span class="pc bpc" id="L3177" title="1 of 2 branches missed.">                if (!a1.get(j).equals(a2.get(j))) {</span>
<span class="nc" id="L3178">                  return false;</span>
                }
              }
<span class="fc" id="L3181">            } else {</span>
<span class="nc" id="L3182">              return false;</span>
            }
          }
<span class="fc" id="L3185">          return true;</span>
        } else {
<span class="nc" id="L3187">          return false;</span>
        }
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L3199" title="1 of 2 branches missed.">      if (this == obj)</span>
<span class="nc" id="L3200">        return true;</span>
<span class="pc bpc" id="L3201" title="1 of 2 branches missed.">      if (obj == null)</span>
<span class="nc" id="L3202">        return false;</span>
<span class="pc bpc" id="L3203" title="1 of 2 branches missed.">      if (getClass() != obj.getClass())</span>
<span class="nc" id="L3204">        return false;</span>
<span class="fc" id="L3205">      GroupHit other = (GroupHit) obj;</span>
<span class="fc bfc" id="L3206" title="All 2 branches covered.">      if (hashCode() != other.hashCode())</span>
<span class="fc" id="L3207">        return false;</span>
<span class="pc bpc" id="L3208" title="1 of 2 branches missed.">      if (!dataEquals(dataHit, other.dataHit))</span>
<span class="nc" id="L3209">        return false;</span>
<span class="pc bpc" id="L3210" title="1 of 2 branches missed.">      if (!dataEquals(dataLeft, other.dataLeft))</span>
<span class="nc" id="L3211">        return false;</span>
<span class="pc bpc" id="L3212" title="1 of 2 branches missed.">      if (!dataEquals(dataRight, other.dataRight))</span>
<span class="nc" id="L3213">        return false;</span>
<span class="fc" id="L3214">      return true;</span>
    }

    /**
     * Data to string.
     *
     * @param data
     *          the data
     * @param missing
     *          the missing
     * @param reverse
     *          the reverse
     * @return the string
     * @throws UnsupportedEncodingException
     *           the unsupported encoding exception
     */
    private String dataToString(List&lt;String&gt;[] data, Set&lt;String&gt;[] missing, boolean reverse)
        throws UnsupportedEncodingException {
<span class="fc" id="L3232">      StringBuilder text = null;</span>
<span class="fc" id="L3233">      Encoder encoder = Base64.getEncoder();</span>
      String prefix;
      String postfix;
      List&lt;String&gt; dataItem;
      Set&lt;String&gt; missingItem;
<span class="pc bpc" id="L3238" title="2 of 6 branches missed.">      if (data != null &amp;&amp; missing != null &amp;&amp; data.length == missing.length) {</span>
<span class="fc bfc" id="L3239" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc bfc" id="L3240" title="All 2 branches covered.">          if (reverse) {</span>
<span class="fc" id="L3241">            dataItem = data[(data.length - i - 1)];</span>
<span class="fc" id="L3242">            missingItem = missing[(data.length - i - 1)];</span>
<span class="fc" id="L3243">          } else {</span>
<span class="fc" id="L3244">            dataItem = data[i];</span>
<span class="fc" id="L3245">            missingItem = missing[i];</span>
          }
<span class="fc bfc" id="L3247" title="All 2 branches covered.">          if (i &gt; 0) {</span>
<span class="fc" id="L3248">            text.append(&quot;,&quot;);</span>
<span class="fc" id="L3249">          } else {</span>
<span class="fc" id="L3250">            text = new StringBuilder();</span>
          }
<span class="fc bfc" id="L3252" title="All 2 branches covered.">          for (int j = 0; j &lt; dataItem.size(); j++) {</span>
<span class="fc bfc" id="L3253" title="All 2 branches covered.">            if (j &gt; 0) {</span>
<span class="fc" id="L3254">              text.append(&quot;&amp;&quot;);</span>
            }
<span class="fc" id="L3256">            prefix = MtasToken.getPrefixFromValue(dataItem.get(j));</span>
<span class="fc" id="L3257">            postfix = MtasToken.getPostfixFromValue(dataItem.get(j));</span>
<span class="fc" id="L3258">            text.append(encoder.encodeToString(prefix.getBytes(StandardCharsets.UTF_8)));</span>
<span class="fc bfc" id="L3259" title="All 2 branches covered.">            if (!postfix.isEmpty()) {</span>
<span class="fc" id="L3260">              text.append(&quot;.&quot;);</span>
<span class="fc" id="L3261">              text.append(encoder.encodeToString(postfix.getBytes(StandardCharsets.UTF_8)));</span>
            }
          }
<span class="pc bpc" id="L3264" title="1 of 2 branches missed.">          if (missingItem != null) {</span>
<span class="fc" id="L3265">            String[] tmpMissing = missingItem.toArray(new String[missingItem.size()]);</span>
<span class="fc bfc" id="L3266" title="All 2 branches covered.">            for (int j = 0; j &lt; tmpMissing.length; j++) {</span>
<span class="fc bfc" id="L3267" title="All 4 branches covered.">              if (j &gt; 0 || !dataItem.isEmpty()) {</span>
<span class="fc" id="L3268">                text.append(&quot;&amp;&quot;);</span>
              }
<span class="fc" id="L3270">              text.append(encoder.encodeToString((&quot;!&quot; + tmpMissing[j]).getBytes(StandardCharsets.UTF_8)));</span>
            }
          }
        }
      }
<span class="fc bfc" id="L3275" title="All 2 branches covered.">      return text != null ? text.toString() : null;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    public String toString() {
<span class="fc" id="L3284">      return key;</span>
    }

    /**
     * Key to sub sub object.
     *
     * @param key
     *          the key
     * @param newKey
     *          the new key
     * @return the map[]
     */
    private static Map&lt;String, String&gt;[] keyToSubSubObject(String key, StringBuilder newKey) {
<span class="fc bfc" id="L3297" title="All 2 branches covered.">      if (!key.isEmpty()) {</span>
<span class="fc" id="L3298">        newKey.append(&quot; [&quot;);</span>
        String prefix;
        String postfix;
<span class="fc" id="L3301">        String[] parts = key.split(Pattern.quote(&quot;&amp;&quot;));</span>
<span class="fc" id="L3302">        Map&lt;String, String&gt;[] result = new HashMap[parts.length];</span>
<span class="fc" id="L3303">        Pattern pattern = Pattern.compile(&quot;^([^\\.]*)\\.([^\\.]*)$&quot;);</span>
<span class="fc" id="L3304">        Decoder decoder = Base64.getDecoder();</span>
        Matcher matcher;
<span class="fc" id="L3306">        StringBuilder tmpNewKey = null;</span>
<span class="fc bfc" id="L3307" title="All 2 branches covered.">        for (int i = 0; i &lt; parts.length; i++) {</span>
<span class="pc bpc" id="L3308" title="1 of 2 branches missed.">          if (parts[i].isEmpty()) {</span>
<span class="nc" id="L3309">            result[i] = null;</span>
<span class="nc" id="L3310">          } else {</span>
<span class="fc" id="L3311">            HashMap&lt;String, String&gt; subResult = new HashMap&lt;&gt;();</span>
<span class="fc" id="L3312">            matcher = pattern.matcher(parts[i]);</span>
<span class="fc bfc" id="L3313" title="All 2 branches covered.">            if (tmpNewKey != null) {</span>
<span class="fc" id="L3314">              tmpNewKey.append(&quot; &amp; &quot;);</span>
<span class="fc" id="L3315">            } else {</span>
<span class="fc" id="L3316">              tmpNewKey = new StringBuilder();</span>
            }
<span class="fc bfc" id="L3318" title="All 2 branches covered.">            if (matcher.matches()) {</span>
<span class="fc" id="L3319">              prefix = new String(decoder.decode(matcher.group(1).getBytes(StandardCharsets.UTF_8)),</span>
<span class="fc" id="L3320">                  StandardCharsets.UTF_8);</span>
<span class="fc" id="L3321">              postfix = new String(decoder.decode(matcher.group(2).getBytes(StandardCharsets.UTF_8)),</span>
<span class="fc" id="L3322">                  StandardCharsets.UTF_8);</span>
<span class="fc" id="L3323">              tmpNewKey.append(prefix.replace(&quot;=&quot;, &quot;\\=&quot;));</span>
<span class="fc" id="L3324">              tmpNewKey.append(&quot;=\&quot;&quot; + postfix.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;) + &quot;\&quot;&quot;);</span>
<span class="fc" id="L3325">              subResult.put(&quot;prefix&quot;, prefix);</span>
<span class="fc" id="L3326">              subResult.put(&quot;value&quot;, postfix);</span>
<span class="fc" id="L3327">            } else {</span>
<span class="fc" id="L3328">              prefix = new String(decoder.decode(parts[i].getBytes(StandardCharsets.UTF_8)), StandardCharsets.UTF_8);</span>
<span class="fc" id="L3329">              tmpNewKey.append(prefix.replace(&quot;=&quot;, &quot;\\=&quot;));</span>
<span class="fc bfc" id="L3330" title="All 2 branches covered.">              if (prefix.startsWith(&quot;!&quot;)) {</span>
<span class="fc" id="L3331">                subResult.put(&quot;missing&quot;, prefix.substring(1));</span>
<span class="fc" id="L3332">              } else {</span>
<span class="fc" id="L3333">                subResult.put(&quot;prefix&quot;, prefix);</span>
              }
            }
<span class="fc" id="L3336">            result[i] = subResult;</span>
          }
        }
<span class="pc bpc" id="L3339" title="1 of 2 branches missed.">        if (tmpNewKey != null) {</span>
<span class="fc" id="L3340">          newKey.append(tmpNewKey);</span>
        }
<span class="fc" id="L3342">        newKey.append(&quot;]&quot;);</span>
<span class="fc" id="L3343">        return result;</span>
      } else {
<span class="fc" id="L3345">        newKey.append(&quot; []&quot;);</span>
<span class="fc" id="L3346">        return null;</span>
      }
    }

    /**
     * Key to sub object.
     *
     * @param key
     *          the key
     * @param newKey
     *          the new key
     * @return the map
     */
    private static Map&lt;Integer, Map&lt;String, String&gt;[]&gt; keyToSubObject(String key, StringBuilder newKey) {
<span class="fc" id="L3360">      Map&lt;Integer, Map&lt;String, String&gt;[]&gt; result = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L3361" title="1 of 4 branches missed.">      if (key == null || key.trim().isEmpty()) {</span>
<span class="fc" id="L3362">        return null;</span>
      } else {
<span class="fc" id="L3364">        String[] parts = key.split(Pattern.quote(&quot;,&quot;), -1);</span>
<span class="pc bpc" id="L3365" title="1 of 2 branches missed.">        if (parts.length &gt; 0) {</span>
<span class="fc bfc" id="L3366" title="All 2 branches covered.">          for (int i = 0; i &lt; parts.length; i++) {</span>
<span class="fc" id="L3367">            result.put(i, keyToSubSubObject(parts[i].trim(), newKey));</span>
          }
<span class="fc" id="L3369">          return result;</span>
        } else {
<span class="nc" id="L3371">          return null;</span>
        }
      }
    }

    /**
     * Key to object.
     *
     * @param key
     *          the key
     * @param newKey
     *          the new key
     * @return the map
     */
    public static Map&lt;String, Map&lt;Integer, Map&lt;String, String&gt;[]&gt;&gt; keyToObject(String key, StringBuilder newKey) {
<span class="pc bpc" id="L3386" title="1 of 2 branches missed.">      if (key.startsWith(KEY_START)) {</span>
<span class="fc" id="L3387">        String content = key.substring(KEY_START.length());</span>
<span class="fc" id="L3388">        StringBuilder keyLeft = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L3389">        StringBuilder keyHit = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L3390">        StringBuilder keyRight = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L3391">        Map&lt;String, Map&lt;Integer, Map&lt;String, String&gt;[]&gt;&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L3392">        Map&lt;Integer, Map&lt;String, String&gt;[]&gt; resultLeft = null;</span>
<span class="fc" id="L3393">        Map&lt;Integer, Map&lt;String, String&gt;[]&gt; resultHit = null;</span>
<span class="fc" id="L3394">        Map&lt;Integer, Map&lt;String, String&gt;[]&gt; resultRight = null;</span>
<span class="fc" id="L3395">        String[] parts = content.split(Pattern.quote(&quot;|&quot;), -1);</span>
<span class="pc bpc" id="L3396" title="1 of 2 branches missed.">        if (parts.length == 3) {</span>
<span class="fc" id="L3397">          resultLeft = keyToSubObject(parts[0].trim(), keyLeft);</span>
<span class="fc" id="L3398">          resultHit = keyToSubObject(parts[1].trim(), keyHit);</span>
<span class="fc" id="L3399">          resultRight = keyToSubObject(parts[2].trim(), keyRight);</span>
<span class="pc bnc" id="L3400" title="All 2 branches missed.">        } else if (parts.length == 1) {</span>
<span class="nc" id="L3401">          resultHit = keyToSubObject(parts[0].trim(), keyHit);</span>
        }
<span class="fc bfc" id="L3403" title="All 2 branches covered.">        if (resultLeft != null) {</span>
<span class="fc" id="L3404">          result.put(&quot;left&quot;, resultLeft);</span>
        }
<span class="fc" id="L3406">        result.put(&quot;hit&quot;, resultHit);</span>
<span class="fc bfc" id="L3407" title="All 2 branches covered.">        if (resultRight != null) {</span>
<span class="fc" id="L3408">          result.put(&quot;right&quot;, resultRight);</span>
        }
<span class="fc" id="L3410">        newKey.append(keyLeft);</span>
<span class="fc" id="L3411">        newKey.append(&quot; |&quot;);</span>
<span class="fc" id="L3412">        newKey.append(keyHit);</span>
<span class="fc" id="L3413">        newKey.append(&quot; |&quot;);</span>
<span class="fc" id="L3414">        newKey.append(keyRight);</span>
<span class="fc" id="L3415">        return result;</span>
      } else {
<span class="nc" id="L3417">        return null;</span>
      }
    }

  }

  /**
   * The Class ListToken.
   */
  public static class ListToken {

    /** The doc id. */
    public Integer docId;

    /** The doc position. */
    public Integer docPosition;

    /** The start position. */
    public int startPosition;

    /** The end position. */
    public int endPosition;

    /** The tokens. */
    public List&lt;MtasTokenString&gt; tokens;

    /**
     * Instantiates a new list token.
     *
     * @param docId
     *          the doc id
     * @param docPosition
     *          the doc position
     * @param match
     *          the match
     * @param tokens
     *          the tokens
     */
<span class="nc" id="L3455">    public ListToken(Integer docId, Integer docPosition, Match match, List&lt;MtasTokenString&gt; tokens) {</span>
<span class="nc" id="L3456">      this.docId = docId;</span>
<span class="nc" id="L3457">      this.docPosition = docPosition;</span>
<span class="nc" id="L3458">      startPosition = match.startPosition;</span>
<span class="nc" id="L3459">      endPosition = match.endPosition - 1;</span>
<span class="nc" id="L3460">      this.tokens = tokens;</span>
<span class="nc" id="L3461">    }</span>
  }

  /**
   * The Class ListHit.
   */
  public static class ListHit {

    /** The doc id. */
    public Integer docId;

    /** The doc position. */
    public Integer docPosition;

    /** The start position. */
    public int startPosition;

    /** The end position. */
    public int endPosition;

    /** The hits. */
    public Map&lt;Integer, List&lt;String&gt;&gt; hits;

    /**
     * Instantiates a new list hit.
     *
     * @param docId
     *          the doc id
     * @param docPosition
     *          the doc position
     * @param match
     *          the match
     * @param hits
     *          the hits
     */
<span class="nc" id="L3496">    public ListHit(Integer docId, Integer docPosition, Match match, Map&lt;Integer, List&lt;String&gt;&gt; hits) {</span>
<span class="nc" id="L3497">      this.docId = docId;</span>
<span class="nc" id="L3498">      this.docPosition = docPosition;</span>
<span class="nc" id="L3499">      startPosition = match.startPosition;</span>
<span class="nc" id="L3500">      endPosition = match.endPosition - 1;</span>
<span class="nc" id="L3501">      this.hits = hits;</span>
<span class="nc" id="L3502">    }</span>
  }

  /**
   * The Class PageWordData.
   */
  public static class PageWordData {

    /** The words. */
    public List&lt;PageWord&gt; words;

    /**
     * Adds the.
     *
     * @param token
     *          the token
     */
    public void add(MtasTokenString token) {
<span class="nc" id="L3520">      words.add(new PageWord(token));</span>
<span class="nc" id="L3521">    }</span>

    /**
     * Instantiates a new page word data.
     */
<span class="nc" id="L3526">    public PageWordData() {</span>
<span class="nc" id="L3527">      words = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3528">    }</span>
  }

  /**
   * The Class PageWord.
   */
  public static class PageWord {

    /** The id. */
    public int id;

    /** The prefix. */
    public String prefix;

    /** The postfix. */
    public String postfix;

    /** The parent id. */
    public Integer parentId;

    /**
     * Instantiates a new page word.
     *
     * @param token
     *          the token
     */
<span class="nc" id="L3554">    public PageWord(MtasTokenString token) {</span>
<span class="nc" id="L3555">      id = token.getId();</span>
<span class="nc" id="L3556">      prefix = token.getPrefix();</span>
<span class="nc" id="L3557">      postfix = token.getPostfix();</span>
<span class="nc" id="L3558">      parentId = token.getParentId();</span>
<span class="nc" id="L3559">    }</span>

  }

  /**
   * The Class PageRangeData.
   */
  public static class PageRangeData {

    /** The ranges. */
    public List&lt;PageRange&gt; ranges;

    /**
     * Adds the.
     *
     * @param token
     *          the token
     */
    public void add(MtasTokenString token) {
<span class="nc" id="L3578">      ranges.add(new PageRange(token));</span>
<span class="nc" id="L3579">    }</span>

    /**
     * Instantiates a new page range data.
     */
<span class="nc" id="L3584">    public PageRangeData() {</span>
<span class="nc" id="L3585">      ranges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3586">    }</span>
  }

  /**
   * The Class PageRange.
   */
  public static class PageRange {

    /** The id. */
    public int id;

    /** The start. */
    public int start;

    /** The end. */
    public int end;

    /** The prefix. */
    public String prefix;

    /** The postfix. */
    public String postfix;

    /** The parent id. */
    public Integer parentId;

    /**
     * Instantiates a new page range.
     *
     * @param token
     *          the token
     */
<span class="nc" id="L3618">    public PageRange(MtasTokenString token) {</span>
<span class="nc" id="L3619">      id = token.getId();</span>
<span class="nc" id="L3620">      start = token.getPositionStart();</span>
<span class="nc" id="L3621">      end = token.getPositionEnd();</span>
<span class="nc" id="L3622">      prefix = token.getPrefix();</span>
<span class="nc" id="L3623">      postfix = token.getPostfix();</span>
<span class="nc" id="L3624">      parentId = token.getParentId();</span>
<span class="nc" id="L3625">    }</span>

  }

  /**
   * The Class PageSetData.
   */
  public static class PageSetData {

    /** The sets. */
    public List&lt;PageSet&gt; sets;

    /**
     * Adds the.
     *
     * @param token
     *          the token
     */
    public void add(MtasTokenString token) {
<span class="nc" id="L3644">      sets.add(new PageSet(token));</span>
<span class="nc" id="L3645">    }</span>

    /**
     * Instantiates a new page set data.
     */
<span class="nc" id="L3650">    public PageSetData() {</span>
<span class="nc" id="L3651">      sets = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3652">    }</span>
  }

  /**
   * The Class PageSet.
   */
  public static class PageSet {

    /** The id. */
    public int id;

    /** The positions. */
    public int[] positions;

    /** The prefix. */
    public String prefix;

    /** The postfix. */
    public String postfix;

    /** The parent id. */
    public Integer parentId;

    /**
     * Instantiates a new page set.
     *
     * @param token
     *          the token
     */
<span class="nc" id="L3681">    public PageSet(MtasTokenString token) {</span>
<span class="nc" id="L3682">      id = token.getId();</span>
<span class="nc" id="L3683">      positions = token.getPositions();</span>
<span class="nc" id="L3684">      prefix = token.getPrefix();</span>
<span class="nc" id="L3685">      postfix = token.getPostfix();</span>
<span class="nc" id="L3686">      parentId = token.getParentId();</span>
<span class="nc" id="L3687">    }</span>

  }

  /**
   * The Class Match.
   */
  public static class Match {

    /** The start position. */
    public int startPosition;

    /** The end position. */
    public int endPosition;

    /**
     * Instantiates a new match.
     *
     * @param startPosition
     *          the start position
     * @param endPosition
     *          the end position
     */
<span class="fc" id="L3710">    public Match(int startPosition, int endPosition) {</span>
<span class="fc" id="L3711">      this.startPosition = startPosition;</span>
<span class="fc" id="L3712">      this.endPosition = endPosition;</span>
<span class="fc" id="L3713">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L3722" title="All 2 branches missed.">      if (this == obj)</span>
<span class="nc" id="L3723">        return true;</span>
<span class="nc bnc" id="L3724" title="All 2 branches missed.">      if (obj == null)</span>
<span class="nc" id="L3725">        return false;</span>
<span class="nc bnc" id="L3726" title="All 2 branches missed.">      if (getClass() != obj.getClass())</span>
<span class="nc" id="L3727">        return false;</span>
<span class="nc" id="L3728">      final Match that = (Match) obj;</span>
<span class="nc bnc" id="L3729" title="All 4 branches missed.">      return startPosition == that.startPosition &amp;&amp; endPosition == that.endPosition;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="nc" id="L3739">      int h = this.getClass().getSimpleName().hashCode();</span>
<span class="nc" id="L3740">      h = (h * 5) ^ startPosition;</span>
<span class="nc" id="L3741">      h = (h * 7) ^ endPosition;</span>
<span class="nc" id="L3742">      return h;</span>
    }

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>