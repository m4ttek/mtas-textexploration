<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasIgnoreItem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.search.spans.util</a> &gt; <span class="el_source">MtasIgnoreItem.java</span></div><h1>MtasIgnoreItem.java</h1><pre class="source lang-java linenums">package mtas.search.spans.util;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.lucene.search.spans.Spans;

/**
 * The Class MtasIgnoreItem.
 */
public class MtasIgnoreItem {

  /** The Constant log. */
<span class="fc" id="L18">  private static final Log log = LogFactory.getLog(MtasIgnoreItem.class);</span>

  /** The Constant DEFAULT_MAXIMUM_IGNORE_LENGTH. */
  public static final int DEFAULT_MAXIMUM_IGNORE_LENGTH = 10;

  /** The ignore spans. */
  Spans ignoreSpans;

  /** The current doc id. */
  int currentDocId;

  /** The current position. */
  int currentPosition;

  /** The minimum position. */
  int minimumPosition;

  /** The maximum ignore length. */
  int maximumIgnoreLength;

  /** The base start position list. */
  HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; baseStartPositionList;

  /** The base end position list. */
  HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; baseEndPositionList;

  /** The full end position list. */
  HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; fullEndPositionList;

  /** The min base start position. */
  HashMap&lt;Integer, Integer&gt; minBaseStartPosition;

  /** The max base end position. */
  HashMap&lt;Integer, Integer&gt; maxBaseEndPosition;

  /** The min full start position. */
  HashMap&lt;Integer, Integer&gt; minFullStartPosition;

  /** The max full end position. */
  HashMap&lt;Integer, Integer&gt; maxFullEndPosition;

  /**
   * Instantiates a new mtas ignore item.
   *
   * @param ignoreSpans the ignore spans
   * @param maximumIgnoreLength the maximum ignore length
   */
<span class="fc" id="L65">  public MtasIgnoreItem(Spans ignoreSpans, Integer maximumIgnoreLength) {</span>
<span class="fc" id="L66">    this.ignoreSpans = ignoreSpans;</span>
<span class="fc" id="L67">    currentDocId = -1;</span>
<span class="fc" id="L68">    currentPosition = -1;</span>
<span class="fc" id="L69">    minimumPosition = -1;</span>
<span class="fc" id="L70">    baseStartPositionList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L71">    baseEndPositionList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L72">    fullEndPositionList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L73">    minBaseStartPosition = new HashMap&lt;&gt;();</span>
<span class="fc" id="L74">    maxBaseEndPosition = new HashMap&lt;&gt;();</span>
<span class="fc" id="L75">    minFullStartPosition = new HashMap&lt;&gt;();</span>
<span class="fc" id="L76">    maxFullEndPosition = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">    if (maximumIgnoreLength == null) {</span>
<span class="fc" id="L78">      this.maximumIgnoreLength = DEFAULT_MAXIMUM_IGNORE_LENGTH;</span>
    } else {
<span class="fc" id="L80">      this.maximumIgnoreLength = maximumIgnoreLength;</span>
    }
<span class="fc" id="L82">  }</span>

  /**
   * Advance to doc.
   *
   * @param docId the doc id
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public boolean advanceToDoc(int docId) throws IOException {
<span class="pc bpc" id="L92" title="1 of 4 branches missed.">    if (ignoreSpans == null || currentDocId == Spans.NO_MORE_DOCS) {</span>
<span class="fc" id="L93">      return false;</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    } else if (currentDocId == docId) {</span>
<span class="nc" id="L95">      return true;</span>
    } else {
<span class="fc" id="L97">      baseEndPositionList.clear();</span>
<span class="fc" id="L98">      fullEndPositionList.clear();</span>
<span class="fc" id="L99">      maxBaseEndPosition.clear();</span>
<span class="fc" id="L100">      minFullStartPosition.clear();</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">      if (currentDocId &lt; docId) {</span>
<span class="fc" id="L102">        currentDocId = ignoreSpans.advance(docId);</span>
<span class="fc" id="L103">        currentPosition = -1;</span>
<span class="fc" id="L104">        minimumPosition = -1;</span>
      }
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">      return currentDocId == docId;</span>
    }
  }

  /**
   * Gets the min start position.
   *
   * @param docId the doc id
   * @param position the position
   * @return the min start position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public int getMinStartPosition(int docId, int position) throws IOException {
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">      if (position &lt; minimumPosition) {</span>
<span class="nc" id="L121">        throw new IOException(</span>
            &quot;Unexpected position, should be &gt;= &quot; + minimumPosition + &quot;!&quot;);
      } else {
<span class="fc" id="L124">        computeFullStartPositionMinimum(position);</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (minFullStartPosition.containsKey(position)) {</span>
<span class="fc" id="L126">          return minFullStartPosition.get(position);</span>
        } else {
<span class="nc" id="L128">          return 0;</span>
        }
      }
    } else {
<span class="fc" id="L132">      return 0;</span>
    }
  }

  /**
   * Gets the max end position.
   *
   * @param docId the doc id
   * @param position the position
   * @return the max end position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public int getMaxEndPosition(int docId, int position) throws IOException {
<span class="nc bnc" id="L145" title="All 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">      if (position &lt; minimumPosition) {</span>
<span class="nc" id="L147">        throw new IOException(</span>
            &quot;Unexpected position, should be &gt;= &quot; + minimumPosition + &quot;!&quot;);
      }
<span class="nc" id="L150">      computeFullEndPositionList(position);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">      if (maxFullEndPosition.containsKey(position)) {</span>
<span class="nc" id="L152">        return maxFullEndPosition.get(position);</span>
      } else {
<span class="nc" id="L154">        return 0;</span>
      }
    } else {
<span class="nc" id="L157">      return 0;</span>
    }
  }

  /**
   * Gets the full end position list.
   *
   * @param docId the doc id
   * @param position the position
   * @return the full end position list
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public Set&lt;Integer&gt; getFullEndPositionList(int docId, int position)
      throws IOException {
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">      if (position &lt; minimumPosition) {</span>
<span class="nc" id="L173">        throw new IOException(</span>
            &quot;Unexpected startPosition, should be &gt;= &quot; + minimumPosition + &quot;!&quot;);
      } else {
<span class="fc" id="L176">        computeFullEndPositionList(position);</span>
<span class="fc" id="L177">        return fullEndPositionList.get(position);</span>
      }
    } else {
<span class="fc" id="L180">      return null;</span>
    }
  }

  /**
   * Compute full start position minimum.
   *
   * @param position the position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private void computeFullStartPositionMinimum(int position)
      throws IOException {
<span class="pc bpc" id="L192" title="2 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; !minFullStartPosition.containsKey(position)) {</span>
<span class="fc" id="L193">      HashSet&lt;Integer&gt; list = baseStartPositionList.get(position);</span>
<span class="fc" id="L194">      HashSet&lt;Integer&gt; newList = new HashSet&lt;&gt;();</span>
<span class="fc" id="L195">      int minimumStartPosition = position;</span>
<span class="pc bpc" id="L196" title="3 of 4 branches missed.">      while (list != null &amp;&amp; !list.isEmpty()) {</span>
<span class="nc" id="L197">        newList.clear();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        for (int startPosition : list) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">          if (minFullStartPosition.containsKey(startPosition)) {</span>
<span class="nc" id="L200">            minimumStartPosition = Math.min(minimumStartPosition,</span>
<span class="nc" id="L201">                minFullStartPosition.get(startPosition));</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">          } else if (baseStartPositionList.containsKey(startPosition)) {</span>
<span class="nc" id="L203">            newList.addAll(baseStartPositionList.get(startPosition));</span>
          } else {
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (startPosition &lt; minimumStartPosition) {</span>
<span class="nc" id="L206">              minimumStartPosition = startPosition;</span>
            }
          }
<span class="nc" id="L209">        }</span>
<span class="nc" id="L210">        list.clear();</span>
<span class="nc" id="L211">        list.addAll(newList);</span>
      }
<span class="fc" id="L213">      minFullStartPosition.put(position, minimumStartPosition);</span>
    }
<span class="fc" id="L215">  }</span>

  /**
   * Compute full end position list.
   *
   * @param position the position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private void computeFullEndPositionList(int position) throws IOException {
<span class="pc bpc" id="L224" title="2 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; !fullEndPositionList.containsKey(position)) {</span>
      // initial fill
<span class="fc" id="L226">      moveTo(position);</span>
<span class="fc" id="L227">      HashSet&lt;Integer&gt; list = baseEndPositionList.get(position);</span>
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">      if (list != null &amp;&amp; !list.isEmpty()) {</span>
<span class="fc" id="L229">        int maxEndPosition = maxBaseEndPosition.get(position);</span>
<span class="fc" id="L230">        HashSet&lt;Integer&gt; checkList = new HashSet&lt;&gt;();</span>
<span class="fc" id="L231">        HashSet&lt;Integer&gt; subCheckList = new HashSet&lt;&gt;();</span>
<span class="fc" id="L232">        checkList.addAll(list);</span>
<span class="fc" id="L233">        int depth = 1;</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        while (!checkList.isEmpty()) {</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">          if (depth &gt; maximumIgnoreLength) {</span>
<span class="nc" id="L236">            checkList.clear();</span>
<span class="nc" id="L237">            subCheckList.clear();</span>
<span class="nc" id="L238">            throw new IOException(&quot;too many successive ignores, maximum is &quot;</span>
                + maximumIgnoreLength);
          } else {
<span class="fc bfc" id="L241" title="All 2 branches covered.">            for (Integer checkItem : checkList) {</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">              if (fullEndPositionList.get(checkItem) != null) {</span>
<span class="nc" id="L243">                list.addAll(fullEndPositionList.get(checkItem));</span>
<span class="nc" id="L244">                maxEndPosition = Math.max(maxEndPosition,</span>
<span class="nc" id="L245">                    maxFullEndPosition.get(checkItem));</span>
              } else {
<span class="fc" id="L247">                moveTo(checkItem);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                if (baseEndPositionList.containsKey(checkItem)) {</span>
<span class="fc" id="L249">                  list.addAll(baseEndPositionList.get(checkItem));</span>
<span class="fc" id="L250">                  maxEndPosition = Math.max(maxEndPosition,</span>
<span class="fc" id="L251">                      maxBaseEndPosition.get(checkItem));</span>
<span class="fc" id="L252">                  subCheckList.addAll(baseEndPositionList.get(checkItem));</span>
                } else {
                  // ready for checkItem
                }
              }
<span class="fc" id="L257">            }</span>
<span class="fc" id="L258">            checkList.clear();</span>
<span class="fc" id="L259">            checkList.addAll(subCheckList);</span>
<span class="fc" id="L260">            subCheckList.clear();</span>
<span class="fc" id="L261">            depth++;</span>
          }
        }
<span class="fc" id="L264">        fullEndPositionList.put(position, list);</span>
<span class="fc" id="L265">        maxFullEndPosition.put(position, (maxEndPosition - position));</span>
<span class="fc" id="L266">      } else {</span>
<span class="fc" id="L267">        fullEndPositionList.put(position, null);</span>
<span class="fc" id="L268">        maxFullEndPosition.put(position, 0);</span>
      }
    }
<span class="fc" id="L271">  }</span>

  /**
   * Move to.
   *
   * @param position the position
   */
  private void moveTo(int position) {
<span class="fc bfc" id="L279" title="All 2 branches covered.">    while (position &gt;= currentPosition) {</span>
      try {
<span class="fc" id="L281">        currentPosition = ignoreSpans.nextStartPosition();</span>
<span class="fc bfc" id="L282" title="All 4 branches covered.">        if (currentPosition != Spans.NO_MORE_POSITIONS</span>
            &amp;&amp; currentPosition &gt;= minimumPosition) {
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">          if (!baseEndPositionList.containsKey(currentPosition)) {</span>
<span class="fc" id="L285">            baseEndPositionList.put(currentPosition, new HashSet&lt;Integer&gt;());</span>
<span class="fc" id="L286">            maxBaseEndPosition.put(currentPosition, currentPosition);</span>
          } else {
<span class="nc" id="L288">            maxBaseEndPosition.put(currentPosition,</span>
<span class="nc" id="L289">                Math.max(maxBaseEndPosition.get(currentPosition),</span>
<span class="nc" id="L290">                    ignoreSpans.endPosition()));</span>
          }
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">          if (!baseStartPositionList.containsKey(ignoreSpans.endPosition())) {</span>
<span class="fc" id="L293">            baseStartPositionList.put(ignoreSpans.endPosition(),</span>
                new HashSet&lt;Integer&gt;());
<span class="fc" id="L295">            minBaseStartPosition.put(ignoreSpans.endPosition(),</span>
<span class="fc" id="L296">                ignoreSpans.endPosition());</span>
          } else {
<span class="nc" id="L298">            minBaseStartPosition.put(ignoreSpans.endPosition(),</span>
<span class="nc" id="L299">                Math.min(minBaseStartPosition.get(ignoreSpans.endPosition()),</span>
                    currentPosition));
          }
<span class="fc" id="L302">          baseStartPositionList.get(ignoreSpans.endPosition())</span>
<span class="fc" id="L303">              .add(currentPosition);</span>
<span class="fc" id="L304">          baseEndPositionList.get(currentPosition)</span>
<span class="fc" id="L305">              .add(ignoreSpans.endPosition());</span>
        }
<span class="nc" id="L307">      } catch (IOException e) {</span>
<span class="nc" id="L308">        log.debug(e);</span>
<span class="nc" id="L309">        currentPosition = Spans.NO_MORE_POSITIONS;</span>
<span class="nc" id="L310">        break;</span>
<span class="fc" id="L311">      }</span>
    }
<span class="fc" id="L313">  }</span>

  /**
   * Removes the before.
   *
   * @param docId the doc id
   * @param position the position
   */
  public void removeBefore(int docId, int position) {
<span class="pc bpc" id="L322" title="1 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="fc" id="L323">      baseStartPositionList.entrySet()</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L325">      baseEndPositionList.entrySet()</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L327">      fullEndPositionList.entrySet()</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L329">      minBaseStartPosition.entrySet()</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L331">      maxBaseEndPosition.entrySet()</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L333">      minFullStartPosition.entrySet()</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L335">      maxFullEndPosition.entrySet()</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">      if (minimumPosition &lt; position) {</span>
<span class="fc" id="L338">        minimumPosition = position;</span>
      }
<span class="fc bfc" id="L340" title="All 2 branches covered.">      if (currentPosition &lt; position) {</span>
<span class="fc" id="L341">        currentPosition = position;</span>
      }
    }
<span class="fc" id="L344">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>