<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasExtendedSpanTermQuery.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.search.spans.util</a> &gt; <span class="el_source">MtasExtendedSpanTermQuery.java</span></div><h1>MtasExtendedSpanTermQuery.java</h1><pre class="source lang-java linenums">package mtas.search.spans.util;

import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import mtas.analysis.token.MtasToken;
import mtas.codec.util.CodecUtil;
import org.apache.lucene.index.FieldInfo;
import org.apache.lucene.index.IndexReaderContext;
import org.apache.lucene.index.LeafReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.TermContext;
import org.apache.lucene.index.TermState;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.spans.FilterSpans;
import org.apache.lucene.search.spans.SpanTermQuery;
import org.apache.lucene.search.spans.SpanWeight;
import org.apache.lucene.search.spans.Spans;

/**
 * The Class MtasExtendedSpanTermQuery.
 */
public class MtasExtendedSpanTermQuery extends SpanTermQuery {

  /** The prefix. */
  private String prefix;

  /** The value. */
  private String value;

  /** The single position. */
  private boolean singlePosition;

  /** The local term. */
  private Term localTerm;

  /**
   * Instantiates a new mtas extended span term query.
   *
   * @param term the term
   */
  public MtasExtendedSpanTermQuery(Term term) {
<span class="nc" id="L50">    this(term, true);</span>
<span class="nc" id="L51">  }</span>

  /**
   * Instantiates a new mtas extended span term query.
   *
   * @param term the term
   * @param singlePosition the single position
   */
  private MtasExtendedSpanTermQuery(Term term, boolean singlePosition) {
<span class="nc" id="L60">    this(new SpanTermQuery(term), singlePosition);</span>
<span class="nc" id="L61">  }</span>

  /**
   * Instantiates a new mtas extended span term query.
   *
   * @param query the query
   * @param singlePosition the single position
   */
  public MtasExtendedSpanTermQuery(SpanTermQuery query,
      boolean singlePosition) {
<span class="fc" id="L71">    super(query.getTerm());</span>
<span class="fc" id="L72">    localTerm = query.getTerm();</span>
<span class="fc" id="L73">    this.singlePosition = singlePosition;</span>
<span class="fc" id="L74">    int i = localTerm.text().indexOf(MtasToken.DELIMITER);</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">    if (i &gt;= 0) {</span>
<span class="fc" id="L76">      prefix = localTerm.text().substring(0, i);</span>
<span class="fc" id="L77">      value = localTerm.text().substring((i + MtasToken.DELIMITER.length()));</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">      value = (value.length() &gt; 0) ? value : null;</span>
    } else {
<span class="nc" id="L80">      prefix = localTerm.text();</span>
<span class="nc" id="L81">      value = null;</span>
    }
<span class="fc" id="L83">  }</span>

  /*
   * (non-Javadoc)
   * 
   * @see
   * org.apache.lucene.search.spans.SpanTermQuery#createWeight(org.apache.lucene
   * .search.IndexSearcher, boolean)
   */
  @Override
  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, float boost)
      throws IOException {
    final TermContext context;
<span class="fc" id="L96">    final IndexReaderContext topContext = searcher.getTopReaderContext();</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">    if (termContext == null) {</span>
<span class="fc" id="L98">      context = TermContext.build(topContext, localTerm);</span>
    } else {
<span class="nc" id="L100">      context = termContext;</span>
    }
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">    return new SpanTermWeight(context, searcher,</span>
<span class="pc" id="L103">        needsScores ? Collections.singletonMap(localTerm, context) : null, boost);</span>
  }

  /**
   * The Class SpanTermWeight.
   */
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">  public class SpanTermWeight extends SpanWeight {</span>

    /** The Constant METHOD_GET_DELEGATE. */
    private static final String METHOD_GET_DELEGATE = &quot;getDelegate&quot;;

    /** The term context. */
    final TermContext termContext;

    /**
     * Instantiates a new span term weight.
     *
     * @param termContext the term context
     * @param searcher the searcher
     * @param terms the terms
     * @throws IOException Signals that an I/O exception has occurred.
     */
    public SpanTermWeight(TermContext termContext, IndexSearcher searcher,
<span class="fc" id="L126">        Map&lt;Term, TermContext&gt; terms, float boost) throws IOException {</span>
<span class="fc" id="L127">      super(MtasExtendedSpanTermQuery.this, searcher, terms, boost);</span>
<span class="fc" id="L128">      this.termContext = termContext;</span>
<span class="pc bpc" id="L129" title="2 of 4 branches missed.">      assert termContext != null : &quot;TermContext must not be null&quot;;</span>
<span class="fc" id="L130">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.lucene.search.Weight#extractTerms(java.util.Set)
     */
    @Override
    public void extractTerms(Set&lt;Term&gt; terms) {
<span class="nc" id="L139">      terms.add(localTerm);</span>
<span class="nc" id="L140">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see
     * org.apache.lucene.search.spans.SpanWeight#extractTermContexts(java.util
     * .Map)
     */
    @Override
    public void extractTermContexts(Map&lt;Term, TermContext&gt; contexts) {
<span class="fc" id="L151">      contexts.put(localTerm, termContext);</span>
<span class="fc" id="L152">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see
     * org.apache.lucene.search.spans.SpanWeight#getSpans(org.apache.lucene.
     * index.LeafReaderContext,
     * org.apache.lucene.search.spans.SpanWeight.Postings)
     */
    @Override
    public Spans getSpans(final LeafReaderContext context,
        Postings requiredPostings) throws IOException {
<span class="fc" id="L165">      final TermState state = termContext.get(context.ord);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">      if (state == null) { // term is not present in that reader</span>
<span class="pc bpc" id="L167" title="2 of 4 branches missed.">        assert context.reader().docFreq(</span>
<span class="fc" id="L168">            localTerm) == 0 : &quot;no termstate found but term exists in reader term=&quot;</span>
<span class="nc" id="L169">                + localTerm;</span>
<span class="fc" id="L170">        return null;</span>
      }

<span class="fc" id="L173">      final Terms terms = context.reader().terms(localTerm.field());</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">      if (terms == null) {</span>
<span class="nc" id="L175">        return null;</span>
      }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">      if (!terms.hasPositions())</span>
<span class="nc" id="L178">        throw new IllegalStateException(&quot;field \&quot;&quot; + localTerm.field()</span>
            + &quot;\&quot; was indexed without position data; cannot run SpanTermQuery (term=&quot;
<span class="nc" id="L180">            + localTerm.text() + &quot;)&quot;);</span>

<span class="fc" id="L182">      final TermsEnum termsEnum = terms.iterator();</span>
<span class="fc" id="L183">      termsEnum.seekExact(localTerm.bytes(), state);</span>

      final PostingsEnum postings;
      Spans matchSpans;

      try {
        // get leafreader
<span class="fc" id="L190">        LeafReader r = context.reader();</span>

        // get delegate
<span class="fc" id="L193">        Boolean hasMethod = true;</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        while (hasMethod) {</span>
<span class="fc" id="L195">          hasMethod = false;</span>
<span class="fc" id="L196">          Method[] methods = r.getClass().getMethods();</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">          for (Method m : methods) {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">            if (m.getName().equals(METHOD_GET_DELEGATE)) {</span>
<span class="fc" id="L199">              hasMethod = true;</span>
<span class="fc" id="L200">              r = (LeafReader) m.invoke(r, (Object[]) null);</span>
<span class="fc" id="L201">              break;</span>
            }
          }
<span class="fc" id="L204">        }</span>

<span class="fc" id="L206">        FieldInfo fieldInfo = r.getFieldInfos().fieldInfo(field);</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (CodecUtil.isSinglePositionPrefix(fieldInfo, prefix)) {</span>
<span class="fc" id="L209">          postings = termsEnum.postings(null,</span>
<span class="fc" id="L210">              requiredPostings.getRequiredPostings());</span>
<span class="fc" id="L211">          matchSpans = new MtasExtendedTermSpans(postings, localTerm, true);</span>
        } else {
<span class="fc" id="L213">          postings = termsEnum.postings(null, requiredPostings</span>
<span class="fc" id="L214">              .atLeast(Postings.PAYLOADS).getRequiredPostings());</span>
<span class="fc" id="L215">          matchSpans = new MtasExtendedTermSpans(postings, localTerm, false);</span>
        }
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (singlePosition) {</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">          return new FilterSpans(matchSpans) {</span>
            @Override
            protected AcceptStatus accept(Spans candidate) throws IOException {
<span class="pc bpc" id="L221" title="2 of 4 branches missed.">              assert candidate.startPosition() != candidate.endPosition();</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">              if ((candidate.endPosition() - candidate.startPosition()) == 1) {</span>
<span class="fc" id="L223">                return AcceptStatus.YES;</span>
              } else {
<span class="nc" id="L225">                return AcceptStatus.NO;</span>
              }
            }
          };
        } else {
<span class="fc" id="L230">          return matchSpans;</span>
        }
<span class="nc" id="L232">      } catch (Exception e) {</span>
        // e.printStackTrace();
<span class="nc" id="L234">        throw new IOException(&quot;Can't get reader: &quot; + e.getMessage(), e);</span>
      }

    }

    @Override
    public boolean isCacheable(LeafReaderContext arg0) {
<span class="nc" id="L241">      return false;</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see
   * org.apache.lucene.search.spans.SpanTermQuery#toString(java.lang.String)
   */
  @Override
  public String toString(String field) {
<span class="nc" id="L253">    StringBuilder buffer = new StringBuilder();</span>
<span class="nc" id="L254">    buffer.append(this.getClass().getSimpleName() + &quot;([&quot;);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L256">      buffer.append(field + &quot;:&quot; + prefix);</span>
    } else {
<span class="nc" id="L258">      buffer.append(field + &quot;:&quot; + prefix + &quot;=&quot; + value);</span>
    }
<span class="nc" id="L260">    buffer.append(&quot;])&quot;);</span>
<span class="nc" id="L261">    return buffer.toString();</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.SpanTermQuery#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">    if (this == obj)</span>
<span class="nc" id="L272">      return true;</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">    if (obj == null)</span>
<span class="nc" id="L274">      return false;</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    if (getClass() != obj.getClass())</span>
<span class="nc" id="L276">      return false;</span>
<span class="fc" id="L277">    MtasExtendedSpanTermQuery other = (MtasExtendedSpanTermQuery) obj;</span>
<span class="pc bpc" id="L278" title="1 of 4 branches missed.">    return other.localTerm.equals(localTerm)</span>
        &amp;&amp; (other.singlePosition == singlePosition);
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.SpanTermQuery#hashCode()
   */
  @Override
  public int hashCode() {
<span class="fc" id="L289">    return Objects.hash(this.getClass().getSimpleName(), localTerm, singlePosition);   </span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>