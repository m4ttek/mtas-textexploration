<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasSpanSequenceSpans.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.search.spans</a> &gt; <span class="el_source">MtasSpanSequenceSpans.java</span></div><h1>MtasSpanSequenceSpans.java</h1><pre class="source lang-java linenums">package mtas.search.spans;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

import mtas.search.spans.MtasSpanSequenceQuery.MtasSpanSequenceQuerySpans;
import mtas.search.spans.util.MtasIgnoreItem;
import mtas.search.spans.util.MtasSpans;

import org.apache.lucene.search.TwoPhaseIterator;
import org.apache.lucene.search.spans.SpanCollector;
import org.apache.lucene.search.spans.Spans;

/**
 * The Class MtasSpanSequenceSpans.
 */
<span class="pc bpc" id="L21" title="1 of 2 branches missed.">public class MtasSpanSequenceSpans extends MtasSpans {</span>

  /** The query. */
  private MtasSpanSequenceQuery query;

  /** The queue spans. */
  private List&lt;QueueItem&gt; queueSpans;

  /** The ignore item. */
  private MtasIgnoreItem ignoreItem;

  /** The queue matches. */
  private List&lt;Match&gt; queueMatches;

  /** The doc id. */
  private int docId;

  /** The current position. */
  private int currentPosition;

  /** The cost. */
  private long cost;

  /** The current match. */
  Match currentMatch;

  /**
   * Instantiates a new mtas span sequence spans.
   *
   * @param query the query
   * @param setSequenceSpans the set sequence spans
   * @param ignoreSpans the ignore spans
   * @param maximumIgnoreLength the maximum ignore length
   */
  public MtasSpanSequenceSpans(MtasSpanSequenceQuery query,
      List&lt;MtasSpanSequenceQuerySpans&gt; setSequenceSpans, Spans ignoreSpans,
      Integer maximumIgnoreLength) {
<span class="fc" id="L58">    super();</span>
<span class="fc" id="L59">    docId = -1;</span>
<span class="fc" id="L60">    this.query = query;</span>
<span class="fc" id="L61">    queueSpans = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L62">    queueMatches = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">    for (MtasSpanSequenceQuerySpans sequenceSpans : setSequenceSpans) {</span>
<span class="fc" id="L64">      queueSpans.add(new QueueItem(sequenceSpans));</span>
<span class="fc" id="L65">    }</span>
<span class="fc" id="L66">    ignoreItem = new MtasIgnoreItem(ignoreSpans, maximumIgnoreLength);</span>
<span class="fc" id="L67">    resetQueue();</span>
<span class="fc" id="L68">    computeCosts();</span>
<span class="fc" id="L69">  }</span>

  /**
   * Compute costs.
   */
  private void computeCosts() {
<span class="fc" id="L75">    cost = Long.MAX_VALUE;</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">    for (QueueItem item : queueSpans) {</span>
<span class="fc" id="L77">      cost = Math.min(cost, item.sequenceSpans.spans.cost());</span>
<span class="fc" id="L78">    }</span>
<span class="fc" id="L79">  }</span>

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#nextStartPosition()
   */
  @Override
  public int nextStartPosition() throws IOException {
<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (findMatches()) {</span>
<span class="fc" id="L89">      currentMatch = queueMatches.get(0);</span>
<span class="fc" id="L90">      currentPosition = currentMatch.startPosition();</span>
<span class="fc" id="L91">      queueMatches.remove(0);</span>
<span class="fc" id="L92">      return currentMatch.startPosition();</span>
    } else {
<span class="fc" id="L94">      currentMatch = new Match(NO_MORE_POSITIONS, NO_MORE_POSITIONS);</span>
<span class="fc" id="L95">      currentPosition = NO_MORE_POSITIONS;</span>
<span class="fc" id="L96">      return NO_MORE_POSITIONS;</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#startPosition()
   */
  @Override
  public int startPosition() {
<span class="fc bfc" id="L107" title="All 2 branches covered.">    if (currentMatch == null) {</span>
<span class="fc" id="L108">      return -1;</span>
    } else {
<span class="fc" id="L110">      return currentMatch.startPosition();</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#endPosition()
   */
  @Override
  public int endPosition() {
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (currentMatch == null) {</span>
<span class="fc" id="L122">      return -1;</span>
    } else {
<span class="fc" id="L124">      return currentMatch.endPosition();</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#width()
   */
  @Override
  public int width() {
<span class="nc" id="L135">    return 0;</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see
   * org.apache.lucene.search.spans.Spans#collect(org.apache.lucene.search.spans
   * .SpanCollector)
   */
  @Override
  public void collect(SpanCollector collector) throws IOException {
<span class="nc bnc" id="L147" title="All 2 branches missed.">    for (QueueItem item : queueSpans) {</span>
<span class="nc" id="L148">      item.sequenceSpans.spans.collect(collector);</span>
<span class="nc" id="L149">    }</span>
<span class="nc" id="L150">  }</span>

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#docID()
   */
  @Override
  public int docID() {
<span class="fc" id="L159">    return docId;</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#nextDoc()
   */
  @Override
  public int nextDoc() throws IOException {
<span class="fc" id="L169">    resetQueue();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">    while (!goToNextDoc())</span>
<span class="fc" id="L171">      ;</span>
<span class="fc" id="L172">    return docId;</span>
  }

  /**
   * Go to next doc.
   *
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private boolean goToNextDoc() throws IOException {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (docId == NO_MORE_DOCS) {</span>
<span class="nc" id="L183">      return true;</span>
    } else {
      // try to find docId with match for all items from sequence
      Integer spanDocId;
<span class="fc" id="L187">      Integer newDocId = null;</span>
<span class="fc" id="L188">      Integer minOptionalDocId = null;</span>
<span class="fc" id="L189">      boolean allItemsOptional = true;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">      for (QueueItem item : queueSpans) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (!item.sequenceSpans.optional) {</span>
<span class="fc" id="L192">          allItemsOptional = false;</span>
        }
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (!item.noMoreDocs) {</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">          if (item.sequenceSpans.spans == null) {</span>
<span class="nc" id="L196">            spanDocId = NO_MORE_DOCS;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">          } else if (newDocId == null) {</span>
<span class="fc" id="L198">            spanDocId = item.sequenceSpans.spans.nextDoc();</span>
          } else {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (!item.sequenceSpans.optional) {</span>
<span class="fc" id="L201">              spanDocId = item.sequenceSpans.spans.advance(newDocId);</span>
            } else {
<span class="fc bfc" id="L203" title="All 2 branches covered.">              if (item.sequenceSpans.spans.docID() == -1</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                  || newDocId &gt; item.sequenceSpans.spans.docID()) {</span>
<span class="fc" id="L205">                spanDocId = item.sequenceSpans.spans.advance(newDocId);</span>
              } else {
<span class="nc" id="L207">                spanDocId = item.sequenceSpans.spans.docID();</span>
              }
            }
          }
<span class="fc bfc" id="L211" title="All 2 branches covered.">          if (spanDocId.equals(NO_MORE_DOCS)) {</span>
<span class="fc" id="L212">            item.noMoreDocs = true;</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if (!item.sequenceSpans.optional) {</span>
              // a not optional span has NO_MORE_DOCS: stop
<span class="fc" id="L215">              docId = NO_MORE_DOCS;</span>
<span class="fc" id="L216">              return true;</span>
            }
<span class="fc bfc" id="L218" title="All 2 branches covered.">          } else if (!spanDocId.equals(newDocId)) {</span>
            // last found spanDocId not equal to potential new docId
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">            if (newDocId != null) {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">              if (!item.sequenceSpans.optional) {</span>
                // move also previous spans to at least spanDocId
<span class="nc" id="L223">                advance(spanDocId);</span>
<span class="nc" id="L224">                return true;</span>
              }
              // define potential new docId
            } else {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">              if (!item.sequenceSpans.optional) {</span>
                // previous optional span with lower docId
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">                if ((minOptionalDocId != null)</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                    &amp;&amp; (minOptionalDocId &lt; spanDocId)) {</span>
<span class="nc" id="L232">                  advance(spanDocId);</span>
<span class="nc" id="L233">                  return true;</span>
                } else {
                  // use spanDocId as potential newDocId
<span class="fc" id="L236">                  newDocId = spanDocId;</span>
                }
              } else {
                // remember minimum docId optional spans
<span class="nc bnc" id="L240" title="All 2 branches missed.">                minOptionalDocId = (minOptionalDocId == null) ? spanDocId</span>
<span class="nc" id="L241">                    : Math.min(minOptionalDocId, spanDocId);</span>
              }
            }
          }
        }
<span class="fc" id="L246">      }</span>
      // if all items are optional
<span class="pc bpc" id="L248" title="5 of 6 branches missed.">      if (allItemsOptional &amp;&amp; newDocId == null &amp;&amp; minOptionalDocId != null) {</span>
<span class="nc" id="L249">        newDocId = minOptionalDocId;</span>
      }
      // nothing found
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">      if (newDocId == null) {</span>
<span class="nc" id="L253">        docId = NO_MORE_DOCS;</span>
<span class="nc" id="L254">        return true;</span>
      } else {
<span class="fc" id="L256">        docId = newDocId;</span>
<span class="fc" id="L257">        ignoreItem.advanceToDoc(docId);</span>
        // try and glue together
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (findMatches()) {</span>
<span class="fc" id="L260">          return true;</span>
          // no matches
        } else {
<span class="fc" id="L263">          resetQueue();</span>
<span class="fc" id="L264">          return false;</span>
        }
      }
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#advance(int)
   */
  @Override
  public int advance(int target) throws IOException {
<span class="fc" id="L277">    resetQueue();</span>
<span class="fc" id="L278">    Integer newTarget = target;</span>
    do {
<span class="fc" id="L280">      newTarget = advanceToDoc(newTarget);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">    } while (newTarget != null);</span>
<span class="fc" id="L282">    return docId;</span>
  }

  /**
   * Advance to doc.
   *
   * @param target the target
   * @return the integer
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private Integer advanceToDoc(int target) throws IOException {
<span class="pc bpc" id="L293" title="2 of 4 branches missed.">    if (docId == NO_MORE_DOCS || target &lt;= docId) {</span>
<span class="nc" id="L294">      return null;</span>
    } else {
      Integer spanDocId;
<span class="fc" id="L297">      Integer newDocId = target;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">      for (QueueItem item : queueSpans) {</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (item.sequenceSpans.spans != null) {</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">          if (item.sequenceSpans.spans.docID() &lt; newDocId) {</span>
<span class="fc" id="L301">            spanDocId = item.sequenceSpans.spans.advance(newDocId);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (spanDocId.equals(NO_MORE_DOCS)) {</span>
<span class="fc" id="L303">              item.noMoreDocs = true;</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">              if (!item.sequenceSpans.optional) {</span>
                // a not optional span has NO_MORE_DOCS: stop
<span class="fc" id="L306">                docId = NO_MORE_DOCS;</span>
<span class="fc" id="L307">                return null;</span>
              }
            } else {
<span class="pc bpc" id="L310" title="3 of 4 branches missed.">              if (!spanDocId.equals(newDocId) &amp;&amp; !item.sequenceSpans.optional) {</span>
                // a not optional span has nothing for newDocId: stop
<span class="nc" id="L312">                return spanDocId;</span>
              }
            }
<span class="nc bnc" id="L315" title="All 2 branches missed.">          } else if (item.sequenceSpans.spans.docID() != newDocId) {</span>
<span class="nc" id="L316">            spanDocId = item.sequenceSpans.spans.docID();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (!item.sequenceSpans.optional) {</span>
              // a not optional span seems to have nothing for newDocId: stop
<span class="nc" id="L319">              return spanDocId;</span>
            }
          }
        }
<span class="fc" id="L323">      }</span>
      // find match
<span class="fc" id="L325">      docId = newDocId;</span>
<span class="fc" id="L326">      ignoreItem.advanceToDoc(docId);</span>
      // try and glue together
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">      if (findMatches()) {</span>
<span class="fc" id="L329">        return null;</span>
        // no matches
      } else {
<span class="nc" id="L332">        resetQueue();</span>
        // try next document
<span class="nc" id="L334">        return (newDocId + 1);</span>
      }
    }
  }

  /**
   * Find matches.
   *
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private boolean findMatches() throws IOException {
<span class="fc" id="L346">    Boolean status = _findMatches();</span>
<span class="fc bfc" id="L347" title="All 4 branches covered.">    while (!(status || (currentPosition == NO_MORE_POSITIONS))) {</span>
<span class="fc" id="L348">      status = _findMatches();</span>
    }
<span class="fc" id="L350">    return status;</span>
  }

  /**
   * Find matches.
   *
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private boolean _findMatches() throws IOException {
    // queue not empty
<span class="fc bfc" id="L361" title="All 2 branches covered.">    if (!queueMatches.isEmpty()) {</span>
<span class="fc" id="L362">      return true;</span>
      // no more matches to be found
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">    } else if (currentPosition == NO_MORE_POSITIONS) {</span>
<span class="nc" id="L365">      return false;</span>
      // try to find matches
    } else {
      // subMatches: try to build matches while collecting
<span class="fc" id="L369">      Integer subMatchesStartPosition = null;</span>
<span class="fc" id="L370">      Boolean subMatchesOptional = true;</span>
<span class="fc" id="L371">      List&lt;Match&gt; subMatchesQueue = new ArrayList&lt;&gt;();</span>
      // minimum startPosition previous, used to set lower boundary on
      // startPosition next
<span class="fc" id="L374">      Integer minStartPositionPrevious = null;</span>
      // maximum endPosition previous, used to set upper boundary on
      // startPosition next
<span class="fc" id="L377">      Integer maxEndPositionPrevious = null;</span>
      // other variables
<span class="fc" id="L379">      Integer minStartPositionNext = null;</span>
<span class="fc" id="L380">      Integer minStartPosition = null;</span>
<span class="fc" id="L381">      Integer minOptionalStartPosition = null;</span>
      // adjusted minimum ignoreItem
<span class="fc" id="L383">      boolean adjustedMinimumIgnoreItem = false;</span>
      // fill queue if necessary and possible
<span class="fc bfc" id="L385" title="All 2 branches covered.">      for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="fc" id="L386">        QueueItem item = queueSpans.get(i);</span>
        // if span is optional, check docId
<span class="pc bpc" id="L388" title="1 of 4 branches missed.">        if (!item.sequenceSpans.optional || (item.sequenceSpans.spans != null</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            &amp;&amp; item.sequenceSpans.spans.docID() == docId)) {</span>
          // compute minimum startPosition until next non-optional item
          // used as lower boundary on endPosition next
<span class="fc" id="L392">          minStartPositionNext = null;</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">          for (int j = (i + 1); j &lt; queueSpans.size(); j++) {</span>

            // check for available lowestPosition
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (!queueSpans.get(j).sequenceSpans.optional</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                &amp;&amp; queueSpans.get(j).lowestPosition != null) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">              minStartPositionNext = (minStartPositionNext == null)</span>
<span class="fc" id="L399">                  ? queueSpans.get(j).lowestPosition</span>
<span class="fc" id="L400">                  : Math.min(minStartPositionNext,</span>
<span class="fc" id="L401">                      queueSpans.get(j).lowestPosition);</span>
              // computing restrictions not possible
            } else {
<span class="fc bfc" id="L404" title="All 2 branches covered.">              if (!queueSpans.get(j).sequenceSpans.optional) {</span>
<span class="fc" id="L405">                minStartPositionNext = null;</span>
              }
              break;
            }
          }
          // fill queue
<span class="pc bpc" id="L411" title="1 of 4 branches missed.">          if ((minStartPositionPrevious == null) || subMatchesOptional) {</span>
<span class="fc" id="L412">            fillQueue(item, null, maxEndPositionPrevious, minStartPositionNext);</span>
          } else {
<span class="fc" id="L414">            fillQueue(item, minStartPositionPrevious, maxEndPositionPrevious,</span>
                minStartPositionNext);
          }
          // try to adjust minimum ignoreItem
<span class="pc bpc" id="L418" title="1 of 4 branches missed.">          if (!adjustedMinimumIgnoreItem &amp;&amp; !item.sequenceSpans.optional</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">              &amp;&amp; item.filledPosition) {</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (minOptionalStartPosition != null) {</span>
<span class="nc" id="L421">              ignoreItem.removeBefore(docId,</span>
<span class="nc" id="L422">                  Math.min(minOptionalStartPosition, item.lowestPosition));</span>
            } else {
<span class="fc" id="L424">              ignoreItem.removeBefore(docId, item.lowestPosition);</span>
            }
<span class="fc" id="L426">            adjustedMinimumIgnoreItem = true;</span>
          }
          // check for available positions
<span class="fc bfc" id="L429" title="All 4 branches covered.">          if (!item.sequenceSpans.optional &amp;&amp; item.noMorePositions</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">              &amp;&amp; !item.filledPosition) {</span>
<span class="fc" id="L431">            currentPosition = NO_MORE_POSITIONS;</span>
<span class="fc" id="L432">            return false;</span>
          }
          // build matches
<span class="fc" id="L435">          subMatchesQueue = _glue(subMatchesQueue, subMatchesOptional, item);</span>
          // update subMatchesOptional
<span class="fc bfc" id="L437" title="All 2 branches covered.">          if (!item.sequenceSpans.optional) {</span>
<span class="fc" id="L438">            subMatchesOptional = false;</span>
          }
          // check if matches are still achievable
<span class="pc bpc" id="L441" title="1 of 4 branches missed.">          if (!subMatchesOptional &amp;&amp; subMatchesQueue.isEmpty()) {</span>
            // clean up previous queues
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            if (subMatchesStartPosition != null) {</span>
<span class="fc" id="L444">              int cleanStartPosition = subMatchesStartPosition;</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">              for (int j = 0; j &lt;= i; j++) {</span>
<span class="fc" id="L446">                queueSpans.get(j).del(cleanStartPosition);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">                if (!queueSpans.get(j).sequenceSpans.optional) {</span>
<span class="fc" id="L448">                  cleanStartPosition++;</span>
                }
              }
            }
<span class="fc" id="L452">            return false;</span>
          }
          // update subMatchesStartPosition
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">          if (subMatchesQueue.isEmpty()) {</span>
<span class="nc" id="L456">            subMatchesStartPosition = null;</span>
          } else {
<span class="fc" id="L458">            subMatchesStartPosition = subMatchesQueue.get(0).startPosition;</span>
          }
          // compute minimum startPosition for next span
<span class="fc bfc" id="L461" title="All 2 branches covered.">          if (item.lowestPosition != null) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            minStartPositionPrevious = (minStartPositionPrevious == null)</span>
<span class="fc" id="L463">                ? item.lowestPosition</span>
<span class="fc" id="L464">                : Math.min(minStartPositionPrevious, item.lowestPosition);</span>
          }
          // for optional spans
<span class="fc bfc" id="L467" title="All 2 branches covered.">          if (item.sequenceSpans.optional) {</span>
            // update stats
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (item.lowestPosition != null) {</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">              minOptionalStartPosition = (minOptionalStartPosition == null)</span>
<span class="pc" id="L471">                  ? item.lowestPosition</span>
<span class="nc" id="L472">                  : Math.min(minOptionalStartPosition, item.lowestPosition);</span>
            }
            // for not optional spans
          } else {
            // update stats, item.lowestPosition should be set
<span class="fc bfc" id="L477" title="All 2 branches covered.">            minStartPosition = (minStartPosition == null) ? item.lowestPosition</span>
<span class="fc" id="L478">                : Math.min(minStartPosition, item.lowestPosition);</span>
            // reset maximum endPosition for next span
<span class="fc" id="L480">            maxEndPositionPrevious = null;</span>
          }
          // compute maximum endPosition for next span
<span class="fc bfc" id="L483" title="All 2 branches covered.">          if (item.lowestPosition != null) {</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">              maxEndPositionPrevious = (maxEndPositionPrevious == null)</span>
<span class="fc" id="L486">                  ? endPosition : Math.max(maxEndPositionPrevious, endPosition);</span>
<span class="fc" id="L487">            }</span>
          }
        }
      }
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">      if (subMatchesQueue.isEmpty()) {</span>
        // condition has only optional parts
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (subMatchesOptional) {</span>
          // check for
<span class="nc" id="L495">          boolean allFinished = true;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">          for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (!queueSpans.get(i).noMorePositions) {</span>
<span class="nc" id="L498">              allFinished = false;</span>
<span class="nc" id="L499">              break;</span>
            }
          }
<span class="nc bnc" id="L502" title="All 2 branches missed.">          if (allFinished) {</span>
<span class="nc" id="L503">            currentPosition = NO_MORE_POSITIONS;</span>
          }
        }
<span class="nc" id="L506">        return false;</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">      } else if ((minOptionalStartPosition != null)</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">          &amp;&amp; (minOptionalStartPosition &lt; subMatchesStartPosition)) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">          if (!queueSpans.get(i).sequenceSpans.optional) {</span>
<span class="nc" id="L511">            break;</span>
          } else {
<span class="nc" id="L513">            queueSpans.get(i).del(minOptionalStartPosition);</span>
          }
        }
<span class="nc" id="L516">        return false;</span>
      } else {
<span class="fc bfc" id="L518" title="All 2 branches covered.">        for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="fc" id="L519">          queueSpans.get(i).del(subMatchesStartPosition);</span>
        }
<span class="fc bfc" id="L521" title="All 2 branches covered.">        for (Match m : subMatchesQueue) {</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">          if (!queueMatches.contains(m)) {</span>
<span class="fc" id="L523">            queueMatches.add(m);</span>
          }
<span class="fc" id="L525">        }</span>
<span class="fc" id="L526">        ignoreItem.removeBefore(docId, queueMatches.get(0).startPosition);</span>
<span class="fc" id="L527">        return true;</span>
      }
    }
  }

  /**
   * Glue.
   *
   * @param subMatchesQueue the sub matches queue
   * @param subMatchesOptional the sub matches optional
   * @param item the item
   * @return the list
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private List&lt;Match&gt; _glue(List&lt;Match&gt; subMatchesQueue,
      Boolean subMatchesOptional, QueueItem item) throws IOException {
<span class="fc" id="L543">    List&lt;Match&gt; newSubMatchesQueue = new ArrayList&lt;&gt;();</span>
    // no previous queue, only use current item
<span class="fc bfc" id="L545" title="All 2 branches covered.">    if (subMatchesQueue.isEmpty()) {</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">      if (item.filledPosition) {</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="fc" id="L548">          Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">          if (!newSubMatchesQueue.contains(m)) {</span>
<span class="fc" id="L550">            newSubMatchesQueue.add(m);</span>
          }
<span class="fc" id="L552">        }</span>
      }
<span class="fc" id="L554">      return newSubMatchesQueue;</span>
      // previous queue
    } else {
      // startposition from queue
<span class="fc" id="L558">      int startPosition = subMatchesQueue.get(0).startPosition;</span>
      // previous queue optional, current item optional
<span class="pc bpc" id="L560" title="3 of 4 branches missed.">      if (subMatchesOptional &amp;&amp; item.sequenceSpans.optional) {</span>
        // forget previous, because current has lower startposition
<span class="nc bnc" id="L562" title="All 4 branches missed.">        if (item.filledPosition &amp;&amp; item.lowestPosition &lt; startPosition) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">          for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="nc" id="L564">            Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (!newSubMatchesQueue.contains(m)) {</span>
<span class="nc" id="L566">              newSubMatchesQueue.add(m);</span>
            }
<span class="nc" id="L568">          }</span>
          // merge with previous
<span class="nc bnc" id="L570" title="All 2 branches missed.">        } else if (item.filledPosition) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">          if (item.lowestPosition.equals(startPosition)) {</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="nc" id="L573">              Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">              if (!newSubMatchesQueue.contains(m)) {</span>
<span class="nc" id="L575">                newSubMatchesQueue.add(m);</span>
              }
<span class="nc" id="L577">            }</span>
          }
<span class="nc" id="L579">          newSubMatchesQueue.addAll(subMatchesQueue);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">          for (Match m : subMatchesQueue) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            if (item.queue.containsKey(m.endPosition)) {</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">              for (Integer endPosition : item.queue.get(m.endPosition)) {</span>
<span class="nc" id="L583">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="nc" id="L585">                  newSubMatchesQueue.add(o);</span>
                }
<span class="nc" id="L587">              }</span>
            }
<span class="nc" id="L589">          }</span>
          // no filled position
        } else {
<span class="nc" id="L592">          newSubMatchesQueue.addAll(subMatchesQueue);</span>
        }
        // previous queue optional, current item not optional
<span class="pc bpc" id="L595" title="3 of 4 branches missed.">      } else if (subMatchesOptional &amp;&amp; !item.sequenceSpans.optional) {</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">        assert item.filledPosition : &quot;span not optional, should contain items&quot;;</span>
        // forget previous
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (item.lowestPosition &lt; startPosition) {</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">          for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="nc" id="L600">            Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (!newSubMatchesQueue.contains(m)) {</span>
<span class="nc" id="L602">              newSubMatchesQueue.add(m);</span>
            }
<span class="nc" id="L604">          }</span>
          // merge with previous
        } else {
<span class="nc bnc" id="L607" title="All 2 branches missed.">          if (item.lowestPosition.equals(startPosition)) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="nc" id="L609">              Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">              if (!newSubMatchesQueue.contains(m)) {</span>
<span class="nc" id="L611">                newSubMatchesQueue.add(m);</span>
              }
<span class="nc" id="L613">            }</span>
          }
<span class="nc bnc" id="L615" title="All 2 branches missed.">          for (Match m : subMatchesQueue) {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (item.queue.containsKey(m.endPosition)) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">              for (Integer endPosition : item.queue.get(m.endPosition)) {</span>
<span class="nc" id="L618">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="nc" id="L620">                  newSubMatchesQueue.add(o);</span>
                }
<span class="nc" id="L622">              }</span>
            }
<span class="nc" id="L624">          }</span>
        }
        // previous queue not optional, current item optional
<span class="pc bpc" id="L627" title="1 of 4 branches missed.">      } else if (!subMatchesOptional &amp;&amp; item.sequenceSpans.optional) {</span>
<span class="fc" id="L628">        newSubMatchesQueue.addAll(subMatchesQueue);</span>
        // merge with previous
<span class="fc bfc" id="L630" title="All 2 branches covered.">        if (item.filledPosition) {</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">          for (Match m : subMatchesQueue) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">            if (item.queue.containsKey(m.endPosition)) {</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">              for (Integer endPosition : item.queue.get(m.endPosition)) {</span>
<span class="fc" id="L634">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="fc" id="L636">                  newSubMatchesQueue.add(o);</span>
                }
<span class="fc" id="L638">              }</span>
            }
<span class="fc" id="L640">          }</span>
        }
        // previous queue not optional, current item not optional
<span class="pc bpc" id="L643" title="2 of 4 branches missed.">      } else if (!subMatchesOptional &amp;&amp; !item.sequenceSpans.optional</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">          &amp;&amp; item.filledPosition) {</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">        for (Match m : subMatchesQueue) {</span>
<span class="fc" id="L646">          Set&lt;Integer&gt; ignoreList = ignoreItem.getFullEndPositionList(docId,</span>
<span class="fc" id="L647">              m.endPosition);</span>
          Integer[] checkList;
<span class="fc bfc" id="L649" title="All 2 branches covered.">          if (ignoreList == null) {</span>
<span class="fc" id="L650">            checkList = new Integer[] { m.endPosition };</span>
          } else {
<span class="fc" id="L652">            checkList = new Integer[1 + ignoreList.size()];</span>
<span class="fc" id="L653">            checkList = ignoreList.toArray(checkList);</span>
<span class="fc" id="L654">            checkList[ignoreList.size()] = m.endPosition;</span>
          }
<span class="fc bfc" id="L656" title="All 2 branches covered.">          for (Integer checkEndPosition : checkList) {</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">            if (item.queue.containsKey(checkEndPosition)) {</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">              for (Integer endPosition : item.queue.get(checkEndPosition)) {</span>
<span class="fc" id="L659">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="fc" id="L661">                  newSubMatchesQueue.add(o);</span>
                }
<span class="fc" id="L663">              }</span>
            }
          }
<span class="fc" id="L666">        }</span>
      }
    }
<span class="fc" id="L669">    return newSubMatchesQueue;</span>
  }

  /**
   * Fill queue.
   *
   * @param item the item
   * @param minStartPosition the min start position
   * @param maxStartPosition the max start position
   * @param minEndPosition the min end position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private void fillQueue(QueueItem item, Integer minStartPosition,
      Integer maxStartPosition, Integer minEndPosition) throws IOException {
    int newStartPosition;
    int newEndPosition;
<span class="fc" id="L685">    Integer firstRetrievedPosition = null;</span>
    // remove everything below minStartPosition
<span class="fc bfc" id="L687" title="All 4 branches covered.">    if ((minStartPosition != null) &amp;&amp; (item.lowestPosition != null)</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">        &amp;&amp; (item.lowestPosition &lt; minStartPosition)) {</span>
<span class="fc" id="L689">      item.del((minStartPosition - 1));</span>
    }
    // fill queue
<span class="fc bfc" id="L692" title="All 2 branches covered.">    while (!item.noMorePositions) {</span>
      boolean doNotCollectAnotherPosition;
<span class="pc bpc" id="L694" title="1 of 6 branches missed.">      doNotCollectAnotherPosition = item.filledPosition</span>
          &amp;&amp; (minStartPosition == null) &amp;&amp; (maxStartPosition == null);
<span class="fc bfc" id="L696" title="All 4 branches covered.">      doNotCollectAnotherPosition |= item.filledPosition</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">          &amp;&amp; (maxStartPosition != null) &amp;&amp; (item.lastRetrievedPosition != null)</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">          &amp;&amp; (maxStartPosition &lt; item.lastRetrievedPosition);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">      if (doNotCollectAnotherPosition) {</span>
<span class="fc" id="L700">        return;</span>
      } else {
        // collect another full position
<span class="fc" id="L703">        firstRetrievedPosition = null;</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        while (!item.noMorePositions) {</span>
<span class="fc" id="L705">          newStartPosition = item.sequenceSpans.spans.nextStartPosition();</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">          if (newStartPosition == NO_MORE_POSITIONS) {</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">            if (!item.queue.isEmpty()) {</span>
<span class="fc" id="L708">              item.filledPosition = true;</span>
<span class="fc" id="L709">              item.lastFilledPosition = item.lastRetrievedPosition;</span>
            }
<span class="fc" id="L711">            item.noMorePositions = true;</span>
<span class="fc" id="L712">            return;</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">          } else if ((minStartPosition != null)</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">              &amp;&amp; (newStartPosition &lt; minStartPosition)) {</span>
            // do nothing
          } else {
<span class="fc" id="L717">            newEndPosition = item.sequenceSpans.spans.endPosition();</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if ((minEndPosition == null) || (newEndPosition &gt;= minEndPosition</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                - ignoreItem.getMinStartPosition(docId, newEndPosition))) {</span>
<span class="fc" id="L720">              item.add(newStartPosition, newEndPosition);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">              if (firstRetrievedPosition == null) {</span>
<span class="fc" id="L722">                firstRetrievedPosition = newStartPosition;</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">              } else if (!firstRetrievedPosition.equals(newStartPosition)) {</span>
<span class="fc" id="L724">                break;</span>
              }
            }
          }
        }
      }
<span class="fc" id="L730">    }</span>
<span class="fc" id="L731">  }</span>

  /**
   * Reset queue.
   */
  void resetQueue() {
<span class="fc" id="L737">    currentPosition = -1;</span>
<span class="fc" id="L738">    queueMatches.clear();</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">    for (QueueItem item : queueSpans) {</span>
<span class="fc" id="L740">      item.reset();</span>
<span class="fc" id="L741">    }</span>
<span class="fc" id="L742">    currentMatch = null;</span>
<span class="fc" id="L743">  }</span>

  /**
   * The Class QueueItem.
   */
  private static class QueueItem {

    /** The no more docs. */
    private boolean noMoreDocs;

    /** The no more positions. */
    private boolean noMorePositions;

    /** The filled position. */
    private boolean filledPosition;

    /** The lowest position. */
    private Integer lowestPosition;

    /** The last filled position. */
    private Integer lastFilledPosition;

    /** The last retrieved position. */
    private Integer lastRetrievedPosition;

    /** The queue. */
    private HashMap&lt;Integer, List&lt;Integer&gt;&gt; queue;

    /** The sequence spans. */
    public MtasSpanSequenceQuerySpans sequenceSpans;

    /**
     * Instantiates a new queue item.
     *
     * @param sequenceSpans the sequence spans
     */
<span class="fc" id="L779">    QueueItem(MtasSpanSequenceQuerySpans sequenceSpans) {</span>
<span class="fc" id="L780">      noMoreDocs = false;</span>
<span class="fc" id="L781">      this.sequenceSpans = sequenceSpans;</span>
<span class="fc" id="L782">      queue = new HashMap&lt;&gt;();</span>
<span class="fc" id="L783">      reset();</span>
<span class="fc" id="L784">    }</span>

    /**
     * Reset.
     */
    public void reset() {
<span class="fc" id="L790">      noMorePositions = false;</span>
<span class="fc" id="L791">      lowestPosition = null;</span>
<span class="fc" id="L792">      lastFilledPosition = null;</span>
<span class="fc" id="L793">      lastRetrievedPosition = null;</span>
<span class="fc" id="L794">      filledPosition = false;</span>
<span class="fc" id="L795">      queue.clear();</span>
<span class="fc" id="L796">    }</span>

    /**
     * Adds the.
     *
     * @param startPosition the start position
     * @param endPosition the end position
     */
    public void add(int startPosition, int endPosition) {
<span class="fc bfc" id="L805" title="All 2 branches covered.">      if (!queue.keySet().contains(startPosition)) {</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">        if (!queue.isEmpty()) {</span>
<span class="fc" id="L807">          filledPosition = true;</span>
<span class="fc" id="L808">          lastFilledPosition = lastRetrievedPosition;</span>
        }
<span class="fc" id="L810">        queue.put(startPosition, new ArrayList&lt;Integer&gt;());</span>
      }
<span class="fc" id="L812">      queue.get(startPosition).add(endPosition);</span>
<span class="pc bpc" id="L813" title="1 of 4 branches missed.">      if ((lowestPosition == null) || (lowestPosition &gt; startPosition)) {</span>
<span class="fc" id="L814">        lowestPosition = startPosition;</span>
      }
<span class="fc" id="L816">      lastRetrievedPosition = startPosition;</span>
<span class="fc" id="L817">    }</span>

    /**
     * Del.
     *
     * @param position the position
     */
    public void del(int position) {
<span class="fc" id="L825">      ArrayList&lt;Integer&gt; removePositions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">      for (int p : queue.keySet()) {</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        if (p &lt;= position) {</span>
<span class="fc" id="L828">          removePositions.add(p);</span>
        }
<span class="fc" id="L830">      }</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">      if (!removePositions.isEmpty()) {</span>
        // positions.removeAll(removePositions);
<span class="fc bfc" id="L833" title="All 2 branches covered.">        for (int p : removePositions) {</span>
<span class="fc" id="L834">          queue.remove(p);</span>
<span class="fc" id="L835">        }</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">        if (queue.isEmpty()) {</span>
<span class="fc" id="L837">          lowestPosition = null;</span>
<span class="fc" id="L838">          lastFilledPosition = null;</span>
<span class="fc" id="L839">          filledPosition = false;</span>
        } else {
<span class="fc" id="L841">          lowestPosition = Collections.min(queue.keySet());</span>
<span class="pc bpc" id="L842" title="1 of 4 branches missed.">          if (filledPosition &amp;&amp; !queue.keySet().contains(lastFilledPosition)) {</span>
<span class="fc" id="L843">            lastFilledPosition = null;</span>
<span class="fc" id="L844">            filledPosition = false;</span>
          }
        }
      }
<span class="fc" id="L848">    }</span>
  }

  /**
   * The Class Match.
   */
  private static class Match {

    /** The start position. */
    private int startPosition;

    /** The end position. */
    private int endPosition;

    /**
     * Instantiates a new match.
     *
     * @param startPosition the start position
     * @param endPosition the end position
     */
<span class="fc" id="L868">    Match(int startPosition, int endPosition) {</span>
<span class="fc" id="L869">      this.startPosition = startPosition;</span>
<span class="fc" id="L870">      this.endPosition = endPosition;</span>
<span class="fc" id="L871">    }</span>

    /**
     * Start position.
     *
     * @return the int
     */
    public int startPosition() {
<span class="fc" id="L879">      return startPosition;</span>
    }

    /**
     * End position.
     *
     * @return the int
     */
    public int endPosition() {
<span class="fc" id="L888">      return endPosition;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">      if (this == obj)</span>
<span class="nc" id="L899">        return true;</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">      if (obj == null)</span>
<span class="nc" id="L901">        return false;</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">      if (getClass() != obj.getClass())</span>
<span class="nc" id="L903">        return false;</span>
<span class="fc" id="L904">      final Match that = (Match) obj;</span>
<span class="pc bpc" id="L905" title="2 of 4 branches missed.">      return startPosition == that.startPosition</span>
          &amp;&amp; endPosition == that.endPosition;
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="nc" id="L916">      int h = this.getClass().getSimpleName().hashCode();</span>
<span class="nc" id="L917">      h = (h * 5) ^ startPosition;</span>
<span class="nc" id="L918">      h = (h * 7) ^ endPosition;</span>
<span class="nc" id="L919">      return h;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="nc" id="L929">      return &quot;[&quot; + startPosition + &quot;,&quot; + endPosition + &quot;]&quot;;</span>
    }

  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#cost()
   */
  @Override
  public long cost() {
<span class="fc" id="L941">    return cost;</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#positionsCost()
   */
  @Override
  public float positionsCost() {
<span class="fc" id="L951">    return 0;</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see mtas.search.spans.util.MtasSpans#asTwoPhaseIterator()
   */
  @Override
  public TwoPhaseIterator asTwoPhaseIterator() {
<span class="pc bpc" id="L961" title="1 of 4 branches missed.">    if (queueSpans == null || !query.twoPhaseIteratorAllowed()) {</span>
<span class="fc" id="L962">      return null;</span>
    } else {
      // TODO
<span class="fc" id="L965">      return null;</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>