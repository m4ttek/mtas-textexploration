<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasSolrComponentHeatmap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.solr.handler.component.util</a> &gt; <span class="el_source">MtasSolrComponentHeatmap.java</span></div><h1>MtasSolrComponentHeatmap.java</h1><pre class="source lang-java linenums">package mtas.solr.handler.component.util;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.lucene.spatial.prefix.PrefixTreeStrategy;
import org.apache.lucene.spatial.query.SpatialArgs;
import org.apache.lucene.spatial.query.SpatialOperation;
import org.apache.solr.common.SolrException;
import org.apache.solr.common.util.NamedList;
import org.apache.solr.common.util.SimpleOrderedMap;
import org.apache.solr.handler.component.ResponseBuilder;
import org.apache.solr.handler.component.SearchComponent;
import org.apache.solr.handler.component.ShardRequest;
import org.apache.solr.handler.component.ShardResponse;
import org.apache.solr.schema.AbstractSpatialPrefixTreeFieldType;
import org.apache.solr.schema.FieldType;
import org.apache.solr.schema.RptWithGeometrySpatialField;
import org.apache.solr.schema.SchemaField;
import org.apache.solr.schema.SpatialRecursivePrefixTreeFieldType;
import org.apache.solr.util.DistanceUnits;
import org.apache.solr.util.SpatialUtils;
import org.locationtech.spatial4j.context.SpatialContext;
import org.locationtech.spatial4j.shape.Shape;

import mtas.codec.util.CodecComponent.ComponentField;
import mtas.codec.util.CodecComponent.ComponentFields;
import mtas.codec.util.CodecComponent.ComponentHeatmap;
import mtas.codec.util.CodecComponent.SubComponentFunction;
import mtas.codec.util.collector.MtasDataCollector;
import mtas.codec.util.heatmap.HeatmapMtasCounter.Heatmap;
import mtas.parser.function.ParseException;
import mtas.search.spans.util.MtasSpanQuery;
import mtas.solr.handler.component.MtasSolrSearchComponent;

/**
 * The Class MtasSolrComponentGroup.
 */
public class MtasSolrComponentHeatmap implements MtasSolrComponent&lt;ComponentHeatmap&gt; {

  
  /** The Constant log. */
<span class="fc" id="L50">  private static final Log log = LogFactory</span>
<span class="fc" id="L51">      .getLog(MtasSolrComponentHeatmap.class);</span>

  /** The search component. */
  MtasSolrSearchComponent searchComponent;

  /** The Constant NAME. */
  public static final String NAME = &quot;heatmap&quot;;

  /** The Constant PARAM_MTAS_GROUP. */
  public static final String PARAM_MTAS_HEATMAP = MtasSolrSearchComponent.PARAM_MTAS + &quot;.&quot; + NAME;

  /** The Constant NAME_MTAS_GROUP_FIELD. */
  public static final String NAME_MTAS_HEATMAP_HEATMAP_FIELD = &quot;heatmapField&quot;;
  
  /** The Constant NAME_MTAS_STATS_TOKENS_TYPE. */
  public static final String NAME_MTAS_HEATMAP_TYPE = &quot;type&quot;;
  
  /** The Constant NAME_MTAS_STATS_SPANS_MINIMUM. */
  public static final String NAME_MTAS_HEATMAP_MINIMUM = &quot;minimum&quot;;

  /** The Constant NAME_MTAS_STATS_SPANS_MAXIMUM. */
  public static final String NAME_MTAS_HEATMAP_MAXIMUM = &quot;maximum&quot;;


  /** The Constant NAME_MTAS_HEATMAP_QUERY_FIELD. */
  public static final String NAME_MTAS_HEATMAP_QUERY_FIELD = &quot;queryField&quot;;
  
  /** The Constant NAME_MTAS_STATS_SPANS_FUNCTION. */
  public static final String NAME_MTAS_HEATMAP_FUNCTION = &quot;function&quot;;

  /** The Constant SUBNAME_MTAS_STATS_SPANS_FUNCTION_EXPRESSION. */
  public static final String SUBNAME_MTAS_HEATMAP_FUNCTION_EXPRESSION = &quot;expression&quot;;

  /** The Constant SUBNAME_MTAS_STATS_SPANS_FUNCTION_KEY. */
  public static final String SUBNAME_MTAS_HEATMAP_FUNCTION_KEY = &quot;key&quot;;

  /** The Constant SUBNAME_MTAS_STATS_SPANS_FUNCTION_TYPE. */
  public static final String SUBNAME_MTAS_HEATMAP_FUNCTION_TYPE = &quot;type&quot;;
  
  
  /** The Constant NAME_MTAS_HEATMAP_GEOM. */
  public static final String NAME_MTAS_HEATMAP_GEOM = &quot;geom&quot;;
  
  /** The Constant NAME_MTAS_HEATMAP_GRID_LEVEL. */
  public static final String NAME_MTAS_HEATMAP_GRID_LEVEL = &quot;gridLevel&quot;;
  
  /** The Constant NAME_MTAS_HEATMAP_DIST_ERR_PCT. */
  public static final String NAME_MTAS_HEATMAP_DIST_ERR_PCT = &quot;distErrPct&quot;;
  
  /** The Constant NAME_MTAS_HEATMAP_DIST_ERR. */
  public static final String NAME_MTAS_HEATMAP_DIST_ERR = &quot;distErr&quot;;

  /** The Constant NAME_MTAS_HEATMAP_MAX_CELLS. */
  public static final String NAME_MTAS_HEATMAP_MAX_CELLS = &quot;maxCells&quot;;
  
  /** The Constant NAME_MTAS_GROUP_KEY. */
  public static final String NAME_MTAS_HEATMAP_KEY = &quot;key&quot;;
  
  
  
  
  /** The Constant NAME_MTAS_HEATMAP_QUERY. */
  private static final String NAME_MTAS_HEATMAP_QUERY = &quot;query&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_TYPE. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_TYPE = &quot;type&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_VALUE. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_VALUE = &quot;value&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_PREFIX. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_PREFIX = &quot;prefix&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_IGNORE. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_IGNORE = &quot;ignore&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_MAXIMUM_IGNORE_LENGTH. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_MAXIMUM_IGNORE_LENGTH = &quot;maximumIgnoreLength&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE = &quot;variable&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE_NAME. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE_NAME = &quot;name&quot;;

  /** The Constant SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE_VALUE. */
  public static final String SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE_VALUE = &quot;value&quot;;

  
  
  

  /** The Constant DEFAULT_DIST_ERR_PCT. */
<span class="fc" id="L144">  public static final double DEFAULT_DIST_ERR_PCT = 0.15;</span>

 
  /**
   * Instantiates a new mtas solr component group.
   *
   * @param searchComponent
   *          the search component
   */
<span class="fc" id="L153">  public MtasSolrComponentHeatmap(MtasSolrSearchComponent searchComponent) {</span>
<span class="fc" id="L154">    this.searchComponent = searchComponent;</span>
<span class="fc" id="L155">  }</span>

  /*
   * (non-Javadoc)
   * 
   * @see
   * mtas.solr.handler.component.util.MtasSolrComponent#prepare(org.apache.solr.
   * handler.component.ResponseBuilder,
   * mtas.codec.util.CodecComponent.ComponentFields)
   */
  public void prepare(ResponseBuilder rb, ComponentFields mtasFields) throws IOException {
<span class="fc" id="L166">    Set&lt;String&gt; ids = MtasSolrResultUtil.getIdsFromParameters(rb.req.getParams(), PARAM_MTAS_HEATMAP);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    if (!ids.isEmpty()) {</span>
<span class="fc" id="L168">      int tmpCounter = 0;</span>
<span class="fc" id="L169">      String[] heatmapFields = new String[ids.size()];</span>
<span class="fc" id="L170">      String[] queryFields = new String[ids.size()];</span>
<span class="fc" id="L171">      String[] minima = new String[ids.size()];</span>
<span class="fc" id="L172">      String[] maxima = new String[ids.size()];</span>
<span class="fc" id="L173">      String[] types = new String[ids.size()];</span>
<span class="fc" id="L174">      String[][] functionExpressions = new String[ids.size()][];</span>
<span class="fc" id="L175">      String[][] functionKeys = new String[ids.size()][];</span>
<span class="fc" id="L176">      String[][] functionTypes = new String[ids.size()][];</span>
<span class="fc" id="L177">      String[][] queryTypes = new String[ids.size()][];</span>
<span class="fc" id="L178">      String[][] queryValues = new String[ids.size()][];</span>
<span class="fc" id="L179">      String[][] queryPrefixes = new String[ids.size()][];</span>
<span class="fc" id="L180">      String[][] queryIgnores = new String[ids.size()][];</span>
<span class="fc" id="L181">      String[][] queryMaximumIgnoreLengths = new String[ids.size()][];</span>
<span class="fc" id="L182">      HashMap&lt;String, String[]&gt;[][] queryVariables = new HashMap[ids.size()][];</span>
<span class="fc" id="L183">      String[] keys = new String[ids.size()];</span>
<span class="fc" id="L184">      String[] geoms = new String[ids.size()];</span>
<span class="fc" id="L185">      String[] gridLevels = new String[ids.size()];</span>
<span class="fc" id="L186">      String[] distErrPcts = new String[ids.size()];</span>
<span class="fc" id="L187">      String[] distErrs = new String[ids.size()];</span>
<span class="fc" id="L188">      String[] maxCells = new String[ids.size()];</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">      for (String id : ids) {</span>
<span class="fc" id="L190">        keys[tmpCounter] = rb.req.getParams()</span>
<span class="fc" id="L191">            .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_KEY, String.valueOf(tmpCounter)).trim();</span>
<span class="fc" id="L192">        heatmapFields[tmpCounter] = rb.req.getParams()</span>
<span class="fc" id="L193">            .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_HEATMAP_FIELD, null);</span>
<span class="fc" id="L194">        queryFields[tmpCounter] = rb.req.getParams()</span>
<span class="fc" id="L195">            .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY_FIELD, null);</span>
        
<span class="fc" id="L197">        minima[tmpCounter] = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot;</span>
<span class="fc" id="L198">            + id + &quot;.&quot; + NAME_MTAS_HEATMAP_MINIMUM, null);</span>
<span class="fc" id="L199">        maxima[tmpCounter] = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot;</span>
<span class="fc" id="L200">            + id + &quot;.&quot; + NAME_MTAS_HEATMAP_MAXIMUM, null);</span>
<span class="fc" id="L201">        types[tmpCounter] = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot;</span>
<span class="fc" id="L202">            + id + &quot;.&quot; + NAME_MTAS_HEATMAP_TYPE, null);</span>
<span class="fc" id="L203">        Set&lt;String&gt; functionIds = MtasSolrResultUtil</span>
<span class="fc" id="L204">            .getIdsFromParameters(rb.req.getParams(), PARAM_MTAS_HEATMAP</span>
<span class="fc" id="L205">                + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_FUNCTION);</span>
<span class="fc" id="L206">        functionExpressions[tmpCounter] = new String[functionIds.size()];</span>
<span class="fc" id="L207">        functionKeys[tmpCounter] = new String[functionIds.size()];</span>
<span class="fc" id="L208">        functionTypes[tmpCounter] = new String[functionIds.size()];</span>
<span class="fc" id="L209">        int tmpSubCounter = 0;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (String functionId : functionIds) {</span>
<span class="fc" id="L211">          functionKeys[tmpCounter][tmpSubCounter] = rb.req.getParams()</span>
<span class="fc" id="L212">              .get(</span>
<span class="fc" id="L213">                  PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot;</span>
<span class="fc" id="L214">                      + NAME_MTAS_HEATMAP_FUNCTION + &quot;.&quot; + functionId + &quot;.&quot;</span>
<span class="fc" id="L215">                      + SUBNAME_MTAS_HEATMAP_FUNCTION_KEY,</span>
<span class="fc" id="L216">                  String.valueOf(tmpSubCounter))</span>
<span class="fc" id="L217">              .trim();</span>
<span class="fc" id="L218">          functionExpressions[tmpCounter][tmpSubCounter] = rb.req.getParams()</span>
<span class="fc" id="L219">              .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot;</span>
<span class="fc" id="L220">                  + NAME_MTAS_HEATMAP_FUNCTION + &quot;.&quot; + functionId + &quot;.&quot;</span>
<span class="fc" id="L221">                  + SUBNAME_MTAS_HEATMAP_FUNCTION_EXPRESSION, null);</span>
<span class="fc" id="L222">          functionTypes[tmpCounter][tmpSubCounter] = rb.req.getParams()</span>
<span class="fc" id="L223">              .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot;</span>
<span class="fc" id="L224">                  + NAME_MTAS_HEATMAP_FUNCTION + &quot;.&quot; + functionId + &quot;.&quot;</span>
<span class="fc" id="L225">                  + SUBNAME_MTAS_HEATMAP_FUNCTION_TYPE, null);</span>
<span class="fc" id="L226">          tmpSubCounter++;</span>
        }
        
<span class="fc" id="L229">        Set&lt;String&gt; qIds = MtasSolrResultUtil.getIdsFromParameters(</span>
<span class="fc" id="L230">            rb.req.getParams(),</span>
<span class="fc" id="L231">            PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (!qIds.isEmpty()) {</span>
<span class="fc" id="L233">          int tmpQCounter = 0;</span>
<span class="fc" id="L234">          queryTypes[tmpCounter] = new String[qIds.size()];</span>
<span class="fc" id="L235">          queryValues[tmpCounter] = new String[qIds.size()];</span>
<span class="fc" id="L236">          queryPrefixes[tmpCounter] = new String[qIds.size()];</span>
<span class="fc" id="L237">          queryIgnores[tmpCounter] = new String[qIds.size()];</span>
<span class="fc" id="L238">          queryMaximumIgnoreLengths[tmpCounter] = new String[qIds.size()];</span>
<span class="fc" id="L239">          queryVariables[tmpCounter] = new HashMap[qIds.size()];</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">          for (String qId : qIds) {</span>
<span class="fc" id="L241">            queryTypes[tmpCounter][tmpQCounter] = rb.req.getParams()</span>
<span class="fc" id="L242">                .get(</span>
<span class="fc" id="L243">                    PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY</span>
<span class="fc" id="L244">                        + &quot;.&quot; + qId + &quot;.&quot; + SUBNAME_MTAS_HEATMAP_QUERY_TYPE,</span>
<span class="fc" id="L245">                    null);</span>
<span class="fc" id="L246">            queryValues[tmpCounter][tmpQCounter] = rb.req.getParams()</span>
<span class="fc" id="L247">                .get(</span>
<span class="fc" id="L248">                    PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY</span>
<span class="fc" id="L249">                        + &quot;.&quot; + qId + &quot;.&quot; + SUBNAME_MTAS_HEATMAP_QUERY_VALUE,</span>
<span class="fc" id="L250">                    null);</span>
<span class="fc" id="L251">            queryPrefixes[tmpCounter][tmpQCounter] = rb.req.getParams()</span>
<span class="fc" id="L252">                .get(</span>
<span class="fc" id="L253">                    PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY</span>
<span class="fc" id="L254">                        + &quot;.&quot; + qId + &quot;.&quot; + SUBNAME_MTAS_HEATMAP_QUERY_PREFIX,</span>
<span class="fc" id="L255">                    null);</span>
<span class="fc" id="L256">            queryIgnores[tmpCounter][tmpQCounter] = rb.req.getParams()</span>
<span class="fc" id="L257">                .get(</span>
<span class="fc" id="L258">                    PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY</span>
<span class="fc" id="L259">                        + &quot;.&quot; + qId + &quot;.&quot; + SUBNAME_MTAS_HEATMAP_QUERY_IGNORE,</span>
<span class="fc" id="L260">                    null);</span>
<span class="fc" id="L261">            queryMaximumIgnoreLengths[tmpCounter][tmpQCounter] = rb.req</span>
<span class="fc" id="L262">                .getParams()</span>
<span class="fc" id="L263">                .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY</span>
<span class="fc" id="L264">                    + &quot;.&quot; + qId + &quot;.&quot;</span>
<span class="fc" id="L265">                    + SUBNAME_MTAS_HEATMAP_QUERY_MAXIMUM_IGNORE_LENGTH, null);</span>
<span class="fc" id="L266">            Set&lt;String&gt; vIds = MtasSolrResultUtil.getIdsFromParameters(</span>
<span class="fc" id="L267">                rb.req.getParams(),</span>
<span class="fc" id="L268">                PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY + &quot;.&quot;</span>
<span class="fc" id="L269">                    + qId + &quot;.&quot; + SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE);</span>
<span class="fc" id="L270">            queryVariables[tmpCounter][tmpQCounter] = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">            if (!vIds.isEmpty()) {</span>
<span class="nc" id="L272">              HashMap&lt;String, ArrayList&lt;String&gt;&gt; tmpVariables = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">              for (String vId : vIds) {</span>
<span class="nc" id="L274">                String name = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id</span>
<span class="nc" id="L275">                    + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY + &quot;.&quot; + qId + &quot;.&quot;</span>
<span class="nc" id="L276">                    + SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE + &quot;.&quot; + vId + &quot;.&quot;</span>
<span class="nc" id="L277">                    + SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE_NAME, null);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                if (name != null) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                  if (!tmpVariables.containsKey(name)) {</span>
<span class="nc" id="L280">                    tmpVariables.put(name, new ArrayList&lt;String&gt;());</span>
                  }
<span class="nc" id="L282">                  String value = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot;</span>
<span class="nc" id="L283">                      + id + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY + &quot;.&quot; + qId + &quot;.&quot;</span>
<span class="nc" id="L284">                      + SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE + &quot;.&quot; + vId + &quot;.&quot;</span>
<span class="nc" id="L285">                      + SUBNAME_MTAS_HEATMAP_QUERY_VARIABLE_VALUE, null);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                  if (value != null) {</span>
<span class="nc" id="L287">                    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L288">                    String[] subList = value.split(&quot;(?&lt;!\\\\),&quot;);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                    for (int i = 0; i &lt; subList.length; i++) {</span>
<span class="nc" id="L290">                      list.add(</span>
<span class="nc" id="L291">                          subList[i].replace(&quot;\\,&quot;, &quot;,&quot;).replace(&quot;\\\\&quot;, &quot;\\&quot;));</span>
                    }
<span class="nc" id="L293">                    tmpVariables.get(name).addAll(list);</span>
                  }
                }
              }
<span class="nc bnc" id="L297" title="All 2 branches missed.">              for (Entry&lt;String, ArrayList&lt;String&gt;&gt; entry : tmpVariables</span>
<span class="nc" id="L298">                  .entrySet()) {</span>
<span class="nc" id="L299">                queryVariables[tmpCounter][tmpQCounter].put(entry.getKey(),</span>
<span class="nc" id="L300">                    entry.getValue()</span>
<span class="nc" id="L301">                        .toArray(new String[entry.getValue().size()]));</span>
              }
            }
<span class="fc" id="L304">            tmpQCounter++;</span>
          }
<span class="fc" id="L306">        } else {</span>
<span class="nc" id="L307">          throw new IOException(</span>
<span class="nc" id="L308">              &quot;no &quot; + NAME_MTAS_HEATMAP_QUERY + &quot; for mtas heatmap &quot; + id);</span>
        }
<span class="fc" id="L310">        geoms[tmpCounter] = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_GEOM, null);</span>
<span class="fc" id="L311">        gridLevels[tmpCounter] = rb.req.getParams()</span>
<span class="fc" id="L312">            .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_GRID_LEVEL, null);</span>
<span class="fc" id="L313">        distErrPcts[tmpCounter] = rb.req.getParams()</span>
<span class="fc" id="L314">            .get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_DIST_ERR_PCT, null);</span>
<span class="fc" id="L315">        distErrs[tmpCounter] = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_DIST_ERR,</span>
<span class="fc" id="L316">            null);</span>
<span class="fc" id="L317">        maxCells[tmpCounter] = rb.req.getParams().get(PARAM_MTAS_HEATMAP + &quot;.&quot; + id + &quot;.&quot; + NAME_MTAS_HEATMAP_MAX_CELLS,</span>
<span class="fc" id="L318">            null);</span>
      }
<span class="fc" id="L320">      String uniqueKeyField = rb.req.getSchema().getUniqueKeyField().getName();</span>
<span class="fc" id="L321">      mtasFields.doHeatmap = true;</span>
<span class="fc" id="L322">      rb.setNeedDocSet(true);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">      for (String field : queryFields) {</span>
<span class="pc bpc" id="L324" title="2 of 4 branches missed.">        if (field == null || field.isEmpty()) {</span>
<span class="nc" id="L325">          throw new IOException(&quot;no (valid) field in mtas heatmap&quot;);</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        } else if (!mtasFields.list.containsKey(field)) {</span>
<span class="fc" id="L327">          mtasFields.list.put(field, new ComponentField(uniqueKeyField));</span>
        }
      }
<span class="fc" id="L330">      MtasSolrResultUtil.compareAndCheck(keys, heatmapFields, NAME_MTAS_HEATMAP_KEY, NAME_MTAS_HEATMAP_HEATMAP_FIELD,</span>
<span class="fc" id="L331">          true);</span>
<span class="fc" id="L332">      MtasSolrResultUtil.compareAndCheck(keys, queryFields, NAME_MTAS_HEATMAP_KEY, NAME_MTAS_HEATMAP_QUERY_FIELD, true);</span>
<span class="fc" id="L333">      MtasSolrResultUtil.compareAndCheck(keys, geoms, NAME_MTAS_HEATMAP_KEY, NAME_MTAS_HEATMAP_GEOM, true);</span>
<span class="fc" id="L334">      MtasSolrResultUtil.compareAndCheck(keys, gridLevels, NAME_MTAS_HEATMAP_KEY, NAME_MTAS_HEATMAP_GRID_LEVEL, true);</span>
<span class="fc" id="L335">      MtasSolrResultUtil.compareAndCheck(keys, distErrPcts, NAME_MTAS_HEATMAP_KEY, NAME_MTAS_HEATMAP_DIST_ERR_PCT,</span>
<span class="fc" id="L336">          true);</span>
<span class="fc" id="L337">      MtasSolrResultUtil.compareAndCheck(keys, distErrs, NAME_MTAS_HEATMAP_KEY, NAME_MTAS_HEATMAP_DIST_ERR, true);</span>
<span class="fc" id="L338">      MtasSolrResultUtil.compareAndCheck(keys, maxCells, NAME_MTAS_HEATMAP_KEY, NAME_MTAS_HEATMAP_MAX_CELLS, true);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">      for (int i = 0; i &lt; heatmapFields.length; i++) {</span>
<span class="fc" id="L340">        ComponentField cf = mtasFields.list.get(queryFields[i]);</span>
<span class="pc bpc" id="L341" title="2 of 4 branches missed.">        String key = (keys[i] == null) || (keys[i].isEmpty()) ? String.valueOf(i) + &quot;:&quot; + heatmapFields[i]</span>
<span class="fc" id="L342">            : keys[i].trim();</span>
<span class="fc" id="L343">        String heatmapField = heatmapFields[i];</span>
<span class="fc" id="L344">        String queryField = queryFields[i];</span>
        
<span class="fc" id="L346">        int queryNumber = queryValues[i].length;</span>
<span class="fc" id="L347">        MtasSpanQuery[] ql = new MtasSpanQuery[queryNumber];</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (int j = 0; j &lt; queryNumber; j++) {</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">          Integer maximumIgnoreLength = (queryMaximumIgnoreLengths[i][j] == null)</span>
<span class="pc" id="L350">              ? null : Integer.parseInt(queryMaximumIgnoreLengths[i][j]);</span>
<span class="fc" id="L351">          MtasSpanQuery q = MtasSolrResultUtil.constructQuery(queryValues[i][j],</span>
<span class="fc" id="L352">              queryTypes[i][j], queryPrefixes[i][j], queryVariables[i][j],</span>
<span class="fc" id="L353">              queryFields[i], queryIgnores[i][j], maximumIgnoreLength);</span>
          // minimize number of queries
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">          if (cf.spanQueryList.contains(q)) {</span>
<span class="nc" id="L356">            q = cf.spanQueryList.get(cf.spanQueryList.indexOf(q));</span>
<span class="nc" id="L357">          } else {</span>
<span class="fc" id="L358">            cf.spanQueryList.add(q);</span>
          }
<span class="fc" id="L360">          ql[j] = q;</span>
        }
<span class="pc bpc" id="L362" title="2 of 4 branches missed.">        Double minimum = (minima[i] == null) || (minima[i].isEmpty()) ? null</span>
<span class="fc" id="L363">            : Double.parseDouble(minima[i]);</span>
<span class="pc bpc" id="L364" title="3 of 4 branches missed.">        Double maximum = (maxima[i] == null) || (maxima[i].isEmpty()) ? null</span>
<span class="nc" id="L365">            : Double.parseDouble(maxima[i]);</span>
<span class="pc bpc" id="L366" title="3 of 4 branches missed.">        String type = (types[i] == null) || (types[i].isEmpty()) ? null</span>
<span class="nc" id="L367">            : types[i].trim();</span>
<span class="fc" id="L368">        String[] functionKey = functionKeys[i];</span>
<span class="fc" id="L369">        String[] functionExpression = functionExpressions[i];</span>
<span class="fc" id="L370">        String[] functionType = functionTypes[i];</span>
        
        
<span class="fc" id="L373">        String geom = geoms[i];</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        Integer gridLevel = gridLevels[i] != null ? Integer.parseInt(gridLevels[i]) : null;</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        Double distErrPct = distErrPcts[i] != null ? Double.parseDouble(distErrPcts[i]) : null;</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        Double distErr = distErrs[i] != null ? Double.parseDouble(distErrs[i]) : null;</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        Integer maxCellsValue = maxCells[i] != null ? Integer.parseInt(maxCells[i]) : null;</span>
        
<span class="fc" id="L379">        final SchemaField schemaField = rb.req.getSchema().getField(heatmapField);</span>
<span class="fc" id="L380">        final FieldType fieldType = schemaField.getType();</span>
        final PrefixTreeStrategy strategy;
        final DistanceUnits distanceUnits;

        // get strategy and distanceUnits
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        if ((fieldType instanceof AbstractSpatialPrefixTreeFieldType)) {</span>
<span class="nc" id="L386">          AbstractSpatialPrefixTreeFieldType&lt;?&gt; rptType = (AbstractSpatialPrefixTreeFieldType&lt;?&gt;) fieldType;</span>
<span class="nc" id="L387">          strategy = (PrefixTreeStrategy) rptType.getStrategy(heatmapField);</span>
<span class="nc" id="L388">          distanceUnits = rptType.getDistanceUnits();</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        } else if (fieldType instanceof RptWithGeometrySpatialField) {</span>
<span class="fc" id="L390">          RptWithGeometrySpatialField rptSdvType = (RptWithGeometrySpatialField) fieldType;</span>
<span class="fc" id="L391">          strategy = rptSdvType.getStrategy(heatmapField).getIndexStrategy();</span>
<span class="fc" id="L392">          distanceUnits = rptSdvType.getDistanceUnits();</span>
<span class="fc" id="L393">        } else {</span>
          // FYI we support the term query one too but few people use that one
<span class="nc" id="L395">          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, &quot;heatmap field needs to be of type &quot;</span>
<span class="nc" id="L396">              + SpatialRecursivePrefixTreeFieldType.class + &quot; or &quot; + RptWithGeometrySpatialField.class);</span>
        }
        // get context
<span class="fc" id="L399">        final SpatialContext ctx = strategy.getSpatialContext();</span>
        // get bounds
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        final Shape boundsShape = geom == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geom, ctx);</span>
        // get gridLevel
<span class="fc" id="L403">        final int maxGridLevel = strategy.getGrid().getMaxLevels();</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (gridLevel != null) {</span>
<span class="pc bpc" id="L405" title="2 of 4 branches missed.">          if (gridLevel &lt;= 0 || gridLevel &gt; maxGridLevel) {</span>
<span class="nc" id="L406">            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,</span>
<span class="nc" id="L407">                NAME_MTAS_HEATMAP_GRID_LEVEL + &quot; should be &gt; 0 and &lt;= &quot; + maxGridLevel);</span>
          }
        } else {
          // SpatialArgs has utility methods to resolve a 'distErr' from optionally set
          // distErr &amp; distErrPct. Arguably that
          // should be refactored to feel less weird than using it like this.
<span class="nc" id="L413">          SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/* ignored */,</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">              boundsShape == null ? ctx.getWorldBounds() : boundsShape);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">          if (distErr != null) {</span>
            // convert distErr units based on configured units
<span class="nc" id="L417">            spatialArgs.setDistErr(distErr * distanceUnits.multiplierFromThisUnitToDegrees());</span>
          }
<span class="nc" id="L419">          spatialArgs.setDistErrPct(distErrPct);</span>
<span class="nc" id="L420">          distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">          if (distErr &lt;= 0) {</span>
<span class="nc" id="L422">            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,</span>
<span class="nc" id="L423">                NAME_MTAS_HEATMAP_DIST_ERR_PCT + &quot; or &quot; + NAME_MTAS_HEATMAP_DIST_ERR</span>
<span class="nc" id="L424">                    + &quot; should be &gt; 0 or instead provide &quot; + NAME_MTAS_HEATMAP_GRID_LEVEL + &quot;=&quot; + maxGridLevel</span>
<span class="nc" id="L425">                    + &quot; if you insist on maximum detail&quot;);</span>
          }
          // The SPT (grid) can lookup a grid level satisfying an error distance
          // constraint
<span class="nc" id="L429">          gridLevel = strategy.getGrid().getLevelForDistance(distErr);</span>
        }
        // add component
        try {
<span class="fc" id="L433">          mtasFields.list.get(queryFields[i]).heatmapList.add(new ComponentHeatmap(key, ql, minimum, maximum, type,</span>
<span class="fc" id="L434">            functionKey, functionExpression, functionType,</span>
<span class="fc" id="L435">            strategy, boundsShape, gridLevel, maxCellsValue));</span>
<span class="pc" id="L436">        } catch (ParseException e) {</span>
<span class="nc" id="L437">          throw new IOException(e.getMessage());</span>
        }  
      }
    }
<span class="fc" id="L441">  }</span>

  /* (non-Javadoc)
   * @see mtas.solr.handler.component.util.MtasSolrComponent#create(mtas.codec.util.CodecComponent.BasicComponent, java.lang.Boolean)
   */
  @Override
  public SimpleOrderedMap&lt;Object&gt; create(ComponentHeatmap heatmap, Boolean encode) throws IOException {
<span class="fc" id="L448">    SimpleOrderedMap&lt;Object&gt; mtasHeatmapResponse = new SimpleOrderedMap&lt;&gt;();</span>
<span class="fc" id="L449">    mtasHeatmapResponse.add(&quot;key&quot;, heatmap.key);</span>
<span class="fc" id="L450">    heatmap.hm.dataCollector.close();</span>
<span class="fc" id="L451">    Map&lt;MtasDataCollector&lt;?, ?&gt;, HashMap&lt;String, MtasSolrMtasResult&gt;&gt; functionData = new HashMap&lt;&gt;();</span>
<span class="fc" id="L452">    HashMap&lt;String, MtasSolrMtasResult&gt; functionResults = new HashMap&lt;&gt;();    </span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">    for (SubComponentFunction function : heatmap.hm.functions) {</span>
<span class="fc" id="L454">      function.dataCollector.close();</span>
<span class="fc" id="L455">      functionResults.put(function.key, new MtasSolrMtasResult(function.dataCollector,</span>
<span class="fc" id="L456">                      function.dataType,</span>
<span class="fc" id="L457">                      function.statsType,</span>
<span class="fc" id="L458">                      function.statsItems, null, null));</span>
    } 
<span class="fc" id="L460">    functionData.put(heatmap.hm.dataCollector, functionResults);</span>
<span class="fc" id="L461">    MtasSolrMtasHeatmapResult data = new MtasSolrMtasHeatmapResult(heatmap, new MtasSolrMtasResult(</span>
<span class="fc" id="L462">        heatmap.hm.dataCollector,</span>
<span class="fc" id="L463">        heatmap.dataType,</span>
<span class="fc" id="L464">        heatmap.statsType,</span>
<span class="fc" id="L465">        heatmap.statsItems,</span>
<span class="fc" id="L466">        null, functionData));</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">    if (encode) {</span>
<span class="fc" id="L468">      mtasHeatmapResponse.add(&quot;_encoded_&quot;, MtasSolrResultUtil.encode(data));</span>
<span class="fc" id="L469">      } else {</span>
<span class="fc" id="L470">      mtasHeatmapResponse.add(&quot;heatmap&quot;, data);</span>
<span class="fc" id="L471">      MtasSolrResultUtil.rewrite(mtasHeatmapResponse, searchComponent);</span>
    }
<span class="fc" id="L473">    return mtasHeatmapResponse;</span>
  }

  @Override
  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {
<span class="nc bnc" id="L478" title="All 2 branches missed.">    if (sreq.params.getBool(MtasSolrSearchComponent.PARAM_MTAS, false)</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        &amp;&amp; sreq.params.getBool(PARAM_MTAS_HEATMAP, false)) {</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      if ((sreq.purpose &amp; ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {</span>
        // do nothing
      } else {
        // remove prefix for other requests
<span class="nc" id="L484">        Set&lt;String&gt; keys = MtasSolrResultUtil</span>
<span class="nc" id="L485">            .getIdsFromParameters(rb.req.getParams(), PARAM_MTAS_HEATMAP);</span>
<span class="nc" id="L486">        sreq.params.remove(PARAM_MTAS_HEATMAP);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        for (String key : keys) {</span>
<span class="nc" id="L488">          sreq.params.remove(</span>
<span class="nc" id="L489">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_QUERY_FIELD);</span>
<span class="nc" id="L490">          sreq.params.remove(</span>
<span class="nc" id="L491">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_HEATMAP_FIELD);</span>
<span class="nc" id="L492">          sreq.params.remove(</span>
<span class="nc" id="L493">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_GRID_LEVEL);</span>
<span class="nc" id="L494">          sreq.params.remove(</span>
<span class="nc" id="L495">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_GEOM);</span>
<span class="nc" id="L496">          sreq.params.remove(</span>
<span class="nc" id="L497">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_KEY); </span>
<span class="nc" id="L498">          sreq.params.remove(</span>
<span class="nc" id="L499">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_MAX_CELLS);          </span>
<span class="nc" id="L500">          sreq.params.remove(</span>
<span class="nc" id="L501">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_DIST_ERR);</span>
<span class="nc" id="L502">          sreq.params.remove(</span>
<span class="nc" id="L503">              PARAM_MTAS_HEATMAP + &quot;.&quot; + key + &quot;.&quot; + NAME_MTAS_HEATMAP_DIST_ERR_PCT);</span>
        }
      }
    }
<span class="nc" id="L507">  }</span>

  @Override
  public void finishStage(ResponseBuilder rb) {
<span class="nc bnc" id="L511" title="All 2 branches missed.">    if (rb.req.getParams().getBool(MtasSolrSearchComponent.PARAM_MTAS, false)</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">        &amp;&amp; rb.stage &gt;= ResponseBuilder.STAGE_EXECUTE_QUERY</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        &amp;&amp; rb.stage &lt; ResponseBuilder.STAGE_GET_FIELDS) {</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">      for (ShardRequest sreq : rb.finished) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (sreq.params.getBool(MtasSolrSearchComponent.PARAM_MTAS, false)</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            &amp;&amp; sreq.params.getBool(PARAM_MTAS_HEATMAP, false)) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">          for (ShardResponse shardResponse : sreq.responses) {</span>
<span class="nc" id="L518">            NamedList&lt;Object&gt; response = shardResponse.getSolrResponse()</span>
<span class="nc" id="L519">                .getResponse();</span>
            try {
<span class="nc" id="L521">              ArrayList&lt;NamedList&lt;Object&gt;&gt; data = (ArrayList&lt;NamedList&lt;Object&gt;&gt;) response</span>
<span class="nc" id="L522">                  .findRecursive(&quot;mtas&quot;, NAME);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">              if (data != null) {</span>
<span class="nc" id="L524">                MtasSolrResultUtil.decode(data);</span>
              }
<span class="nc" id="L526">            } catch (ClassCastException e) {</span>
<span class="nc" id="L527">              log.debug(e);</span>
              // shouldn't happen
            }
          }
        }
      }
    }
<span class="nc" id="L534">  }</span>

  @Override
  public void distributedProcess(ResponseBuilder rb, ComponentFields mtasFields) throws IOException {
 // rewrite
<span class="fc" id="L539">    NamedList&lt;Object&gt; mtasResponse = null;</span>
    try {
<span class="fc" id="L541">      mtasResponse = (NamedList&lt;Object&gt;) rb.rsp.getValues().get(&quot;mtas&quot;);</span>
<span class="pc" id="L542">    } catch (ClassCastException e) {</span>
<span class="nc" id="L543">      log.debug(e);</span>
<span class="nc" id="L544">      mtasResponse = null;</span>
    }
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">    if (mtasResponse != null) {</span>
      ArrayList&lt;Object&gt; mtasResponseHeatmap;
      try {
<span class="fc" id="L549">        mtasResponseHeatmap = (ArrayList&lt;Object&gt;) mtasResponse.get(NAME);</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if (mtasResponseHeatmap != null) {</span>
<span class="fc" id="L551">          MtasSolrResultUtil.rewrite(mtasResponseHeatmap, searchComponent);</span>
        }
<span class="pc" id="L553">      } catch (ClassCastException e) {</span>
<span class="nc" id="L554">        log.debug(e);</span>
<span class="nc" id="L555">        mtasResponse.remove(NAME);</span>
      }
    }
<span class="fc" id="L558">  }</span>

  /**
   * Format counts val.
   *
   * @param format the format
   * @param columns the columns
   * @param rows the rows
   * @param counts the counts
   * @return the object
   */
  public static Object formatCountsVal(Heatmap hm) {
<span class="nc" id="L570">    return null;</span>
  }
  

  /**
   * As ints 2 D.
   *
   * @param columns the columns
   * @param rows the rows
   * @param counts the counts
   * @return the list
   */
  static List&lt;List&lt;MtasDataCollector&lt;?,?&gt;&gt;&gt; as2D(final int columns, final int rows, final MtasDataCollector&lt;?,?&gt;[] counts) {
<span class="nc" id="L583">    return null;</span>
  }
  
  static String asCompressed(final int columns, final int rows, final MtasDataCollector&lt;?,?&gt;[] counts) {
<span class="nc" id="L587">    return null;</span>
  }
  
 

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>