<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasPayloadEncoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.codec.payload</a> &gt; <span class="el_source">MtasPayloadEncoder.java</span></div><h1>MtasPayloadEncoder.java</h1><pre class="source lang-java linenums">package mtas.codec.payload;

import java.io.IOException;
import java.util.Arrays;

import mtas.analysis.token.MtasPosition;
import mtas.analysis.token.MtasToken;
import mtas.analysis.token.MtasTokenString;

import org.apache.lucene.util.BytesRef;

/**
 * The Class MtasPayloadEncoder.
 */

/**
 * The Class MtasPayloadEncoder.
 */
public class MtasPayloadEncoder {

  /** The mtas token. */
  private MtasToken mtasToken;

  /** The byte stream. */
  private MtasBitOutputStream byteStream;

  /** The encoding flags. */
  private int encodingFlags;

  /** The Constant ENCODE_PAYLOAD. */
  public static final int ENCODE_PAYLOAD = 1;

  /** The Constant ENCODE_OFFSET. */
  public static final int ENCODE_OFFSET = 2;

  /** The Constant ENCODE_REALOFFSET. */
  public static final int ENCODE_REALOFFSET = 4;

  /** The Constant ENCODE_PARENT. */
  public static final int ENCODE_PARENT = 8;

  /** The Constant ENCODE_DEFAULT. */
  public static final int ENCODE_DEFAULT = ENCODE_PAYLOAD | ENCODE_OFFSET
      | ENCODE_PARENT;

  /** The Constant ENCODE_ALL. */
  public static final int ENCODE_ALL = ENCODE_PAYLOAD | ENCODE_OFFSET
      | ENCODE_REALOFFSET | ENCODE_PARENT;

  /**
   * Instantiates a new mtas payload encoder.
   *
   * @param token the token
   * @param flags the flags
   */
<span class="fc" id="L56">  public MtasPayloadEncoder(MtasToken token, int flags) {</span>
<span class="fc" id="L57">    mtasToken = token;</span>
<span class="fc" id="L58">    byteStream = new MtasBitOutputStream();</span>
<span class="fc" id="L59">    encodingFlags = flags;</span>
<span class="fc" id="L60">  }</span>

  /**
   * Instantiates a new mtas payload encoder.
   *
   * @param token the token
   */
  public MtasPayloadEncoder(MtasToken token) {
<span class="nc" id="L68">    this(token, ENCODE_DEFAULT);</span>
<span class="nc" id="L69">  }</span>

  /**
   * Gets the payload.
   *
   * @return the payload
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public BytesRef getPayload() throws IOException {

    // initial bits - position
<span class="fc bfc" id="L80" title="All 2 branches covered.">    if (mtasToken.checkPositionType(MtasPosition.POSITION_SINGLE)) {</span>
<span class="fc" id="L81">      byteStream.writeBit(0);</span>
<span class="fc" id="L82">      byteStream.writeBit(0);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">    } else if (mtasToken.checkPositionType(MtasPosition.POSITION_RANGE)) {</span>
<span class="fc" id="L84">      byteStream.writeBit(1);</span>
<span class="fc" id="L85">      byteStream.writeBit(0);</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">    } else if (mtasToken.checkPositionType(MtasPosition.POSITION_SET)) {</span>
<span class="fc" id="L87">      byteStream.writeBit(0);</span>
<span class="fc" id="L88">      byteStream.writeBit(1);</span>
    } else {
<span class="nc" id="L90">      byteStream.writeBit(1);</span>
<span class="nc" id="L91">      byteStream.writeBit(1);</span>
    }
    // initial bits - offset
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_OFFSET) == ENCODE_OFFSET</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        &amp;&amp; mtasToken.checkOffset()) {</span>
<span class="nc" id="L96">      byteStream.writeBit(1);</span>
    } else {
<span class="fc" id="L98">      byteStream.writeBit(0);</span>
    }
    // initial bits - realOffset
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_REALOFFSET) == ENCODE_REALOFFSET</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        &amp;&amp; mtasToken.checkRealOffset()) {</span>
<span class="nc" id="L103">      byteStream.writeBit(1);</span>
    } else {
<span class="fc" id="L105">      byteStream.writeBit(0);</span>
    }
    // initial bits - parentId
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_PARENT) == ENCODE_PARENT</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        &amp;&amp; mtasToken.checkParentId()) {</span>
<span class="fc" id="L110">      byteStream.writeBit(1);</span>
    } else {
<span class="fc" id="L112">      byteStream.writeBit(0);</span>
    }
    // initial bits - original payload
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_PAYLOAD) == ENCODE_PAYLOAD</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        &amp;&amp; mtasToken.getPayload() != null) {</span>
<span class="nc" id="L117">      byteStream.writeBit(1);</span>
    } else {
<span class="fc" id="L119">      byteStream.writeBit(0);</span>
    }
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">    if (mtasToken.getType().equals(MtasTokenString.TOKEN_TYPE)) {</span>
<span class="fc" id="L122">      byteStream.writeBit(0);</span>
    } else {
      // to add other token types later on
<span class="nc" id="L125">      byteStream.writeBit(1);</span>
    }
    // add id (EliasGammaCoding)
<span class="fc" id="L128">    byteStream.writeEliasGammaCodingNonNegativeInteger(mtasToken.getId());</span>
    // add position info (EliasGammaCoding)
<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (mtasToken.checkPositionType(MtasPosition.POSITION_SINGLE)) {</span>
      // do nothing
<span class="fc bfc" id="L132" title="All 2 branches covered.">    } else if (mtasToken.checkPositionType(MtasPosition.POSITION_RANGE)) {</span>
      // write length
<span class="fc" id="L134">      byteStream.writeEliasGammaCodingPositiveInteger(</span>
<span class="fc" id="L135">          1 + mtasToken.getPositionEnd() - mtasToken.getPositionStart());</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">    } else if (mtasToken.checkPositionType(MtasPosition.POSITION_SET)) {</span>
      // write number of positions
<span class="fc" id="L138">      int[] positionList = mtasToken.getPositions();</span>
<span class="fc" id="L139">      byteStream.writeEliasGammaCodingPositiveInteger(positionList.length);</span>
<span class="fc" id="L140">      int previousPosition = positionList[0];</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">      for (int i = 1; i &lt; positionList.length; i++) {</span>
<span class="fc" id="L142">        byteStream.writeEliasGammaCodingPositiveInteger(</span>
            positionList[i] - previousPosition);
<span class="fc" id="L144">        previousPosition = positionList[i];</span>
      }
    } else {
      // do nothing
    }
    // add offset info (EliasGammaCoding)
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_OFFSET) == ENCODE_OFFSET</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        &amp;&amp; mtasToken.checkOffset()) {</span>
<span class="nc" id="L152">      byteStream</span>
<span class="nc" id="L153">          .writeEliasGammaCodingNonNegativeInteger(mtasToken.getOffsetStart());</span>
<span class="nc" id="L154">      byteStream.writeEliasGammaCodingPositiveInteger(</span>
<span class="nc" id="L155">          1 + mtasToken.getOffsetEnd() - mtasToken.getOffsetStart());</span>
    }
    // add realOffset info (EliasGammaCoding)
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_REALOFFSET) == ENCODE_REALOFFSET</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        &amp;&amp; mtasToken.checkRealOffset()) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      if ((encodingFlags &amp; ENCODE_OFFSET) == ENCODE_OFFSET</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">          &amp;&amp; mtasToken.checkOffset()) {</span>
<span class="nc" id="L162">        byteStream.writeEliasGammaCodingInteger(</span>
<span class="nc" id="L163">            mtasToken.getRealOffsetStart() - mtasToken.getOffsetStart());</span>
<span class="nc" id="L164">        byteStream.writeEliasGammaCodingPositiveInteger(</span>
<span class="nc" id="L165">            1 + mtasToken.getRealOffsetEnd() - mtasToken.getRealOffsetStart());</span>
      } else {
<span class="nc" id="L167">        byteStream.writeEliasGammaCodingNonNegativeInteger(</span>
<span class="nc" id="L168">            mtasToken.getRealOffsetStart());</span>
<span class="nc" id="L169">        byteStream.writeEliasGammaCodingPositiveInteger(</span>
<span class="nc" id="L170">            1 + mtasToken.getRealOffsetEnd() - mtasToken.getRealOffsetStart());</span>
      }
    }
    // add parent info (EliasGammaCoding)
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_PARENT) == ENCODE_PARENT</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        &amp;&amp; mtasToken.checkParentId()) {</span>
<span class="fc" id="L176">      byteStream.writeEliasGammaCodingInteger(</span>
<span class="fc" id="L177">          mtasToken.getParentId() - mtasToken.getId());</span>
    }
    // add minimal number of zero-bits to get round number of bytes
<span class="fc" id="L180">    byteStream.createByte();</span>
    // finally add original payload bytes
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if ((encodingFlags &amp; ENCODE_PAYLOAD) == ENCODE_PAYLOAD</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        &amp;&amp; mtasToken.getPayload() != null) {</span>
<span class="nc" id="L184">      BytesRef payload = mtasToken.getPayload();</span>
<span class="nc" id="L185">      byteStream.write(Arrays.copyOfRange(payload.bytes, payload.offset,</span>
          (payload.offset + payload.length)));
    }
    // construct new payload
<span class="fc" id="L189">    return new BytesRef(byteStream.toByteArray());</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>