<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasCQLParserSentenceCondition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.parser.cql.util</a> &gt; <span class="el_source">MtasCQLParserSentenceCondition.java</span></div><h1>MtasCQLParserSentenceCondition.java</h1><pre class="source lang-java linenums">package mtas.parser.cql.util;

import java.util.ArrayList;
import java.util.List;

import mtas.parser.cql.ParseException;
import mtas.search.spans.MtasSpanOrQuery;
import mtas.search.spans.MtasSpanRecurrenceQuery;
import mtas.search.spans.MtasSpanSequenceItem;
import mtas.search.spans.MtasSpanSequenceQuery;
import mtas.search.spans.util.MtasSpanQuery;

/**
 * The Class MtasCQLParserSentenceCondition.
 */
public class MtasCQLParserSentenceCondition {

  /** The sequence list. */
  // parent list: multiple items for OR
  // child list: sequence
  private List&lt;List&lt;MtasCQLParserSentenceCondition&gt;&gt; sequenceList;

  /** The basic sentence. */
<span class="fc" id="L24">  private MtasCQLParserBasicSentenceCondition basicSentence = null;</span>

  /** The minimum occurence. */
  private int minimumOccurence;

  /** The maximum occurence. */
  private int maximumOccurence;

  /** The basic. */
  private boolean basic;

  /** The simplified. */
  private boolean simplified;

  /** The optional. */
  private boolean optional;

  /** The ignore. */
  private MtasSpanQuery ignore;

  /** The maximum ignore length. */
  private Integer maximumIgnoreLength;

  /**
   * Instantiates a new mtas CQL parser sentence condition.
   *
   * @param s the s
   * @param ignore the ignore
   * @param maximumIgnoreLength the maximum ignore length
   * @throws ParseException the parse exception
   */
  public MtasCQLParserSentenceCondition(MtasCQLParserBasicSentenceCondition s,
<span class="fc" id="L56">      MtasSpanQuery ignore, Integer maximumIgnoreLength) throws ParseException {</span>
<span class="fc" id="L57">    sequenceList = new ArrayList&lt;List&lt;MtasCQLParserSentenceCondition&gt;&gt;();</span>
<span class="fc" id="L58">    basicSentence = s;</span>
<span class="fc" id="L59">    minimumOccurence = 1;</span>
<span class="fc" id="L60">    maximumOccurence = 1;</span>
<span class="fc" id="L61">    simplified = false;</span>
<span class="fc" id="L62">    basic = true;</span>
<span class="fc" id="L63">    optional = false;</span>
<span class="fc" id="L64">    this.ignore = ignore;</span>
<span class="fc" id="L65">    this.maximumIgnoreLength = maximumIgnoreLength;</span>
<span class="fc" id="L66">  }</span>

  /**
   * Instantiates a new mtas CQL parser sentence condition.
   *
   * @param sp the sp
   * @param ignore the ignore
   * @param maximumIgnoreLength the maximum ignore length
   * @throws ParseException the parse exception
   */
  public MtasCQLParserSentenceCondition(MtasCQLParserSentenceCondition sp,
<span class="fc" id="L77">      MtasSpanQuery ignore, Integer maximumIgnoreLength) throws ParseException {</span>
<span class="fc" id="L78">    sequenceList = new ArrayList&lt;List&lt;MtasCQLParserSentenceCondition&gt;&gt;();</span>
<span class="fc" id="L79">    addSentenceToEndLatestSequence(sp);</span>
<span class="fc" id="L80">    minimumOccurence = 1;</span>
<span class="fc" id="L81">    maximumOccurence = 1;</span>
<span class="fc" id="L82">    simplified = false;</span>
<span class="fc" id="L83">    basic = false;</span>
<span class="fc" id="L84">    optional = false;</span>
<span class="fc" id="L85">    this.ignore = ignore;</span>
<span class="fc" id="L86">    this.maximumIgnoreLength = maximumIgnoreLength;</span>
<span class="fc" id="L87">  }</span>

  /**
   * Adds the basic sentence to end latest sequence.
   *
   * @param s the s
   * @throws ParseException the parse exception
   */
  public void addBasicSentenceToEndLatestSequence(
      MtasCQLParserBasicSentenceCondition s) throws ParseException {
<span class="nc bnc" id="L97" title="All 2 branches missed.">    if (!simplified) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">      if (isBasic()) {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (basicSentence == null) {</span>
<span class="nc" id="L100">          basicSentence = s;</span>
        } else {
<span class="nc" id="L102">          basicSentence.addBasicSentence(s);</span>
        }
      } else {
<span class="nc" id="L105">        MtasCQLParserSentenceCondition sentenceCurrent = new MtasCQLParserSentenceCondition(</span>
            s, ignore, maximumIgnoreLength);
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (sequenceList.size() == 0) {</span>
<span class="nc" id="L108">          sequenceList.add(new ArrayList&lt;MtasCQLParserSentenceCondition&gt;());</span>
        }
<span class="nc" id="L110">        sequenceList.get(sequenceList.size() - 1).add(sentenceCurrent);</span>
<span class="nc" id="L111">      }</span>
    } else {
<span class="nc" id="L113">      throw new ParseException(&quot;already simplified&quot;);</span>
    }
<span class="nc" id="L115">  }</span>

  /**
   * Adds the sentence to end latest sequence.
   *
   * @param s the s
   * @throws ParseException the parse exception
   */
  // public void addBasicSentenceAsOption(MtasCQLParserBasicSentenceCondition s)
  // throws ParseException {
  // if (!simplified) {
  // MtasCQLParserSentenceCondition sentenceCurrent;
  // List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence;
  // if (isBasic()) {
  // if (basicSentence == null) {
  // basicSentence = s;
  // } else {
  // // add previous basic sentence as first option
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = new MtasCQLParserSentenceCondition(basicSentence,
  // ignore, maximumIgnoreLength);
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // basicSentence = null;
  // // create new option for current basic sentence
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = new MtasCQLParserSentenceCondition(s, ignore,
  // maximumIgnoreLength);
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // // not basic anymore
  // basic = false;
  // }
  // } else {
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = new MtasCQLParserSentenceCondition(s, ignore,
  // maximumIgnoreLength);
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // }
  // } else {
  // throw new ParseException(&quot;already simplified&quot;);
  // }
  // }

  /**
   * Adds the sentence to start first sequence.
   *
   * @param s
   *          the s
   * @throws ParseException
   *           the parse exception
   */
  // public void addSentenceToStartFirstSequence(MtasCQLParserSentenceCondition
  // s)
  // throws ParseException {
  // if (!simplified) {
  // MtasCQLParserSentenceCondition sentenceCurrent;
  // List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence;
  // if (isBasic()) {
  // if (basicSentence == null) {
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = s;
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // // not basic anymore
  // basic = false;
  // } else {
  // // add sentence as first item in new sequence
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // // add sentence to first option
  // sentenceCurrent = s;
  // sentenceSequence.add(sentenceCurrent);
  // // add basic sentence as second item
  // sentenceCurrent = new MtasCQLParserSentenceCondition(basicSentence,
  // ignore, maximumIgnoreLength);
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // basicSentence = null;
  // // not simple anymore
  // basic = false;
  // }
  // } else {
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceSequence.add(s);
  // sentenceSequence.addAll(sequenceList.get(0));
  // sequenceList.set(0, sentenceSequence);
  // sentenceSequence = sequenceList.get((sequenceList.size() - 1));
  // sentenceCurrent = sentenceSequence.get((sentenceSequence.size() - 1));
  // }
  // } else {
  // throw new ParseException(&quot;already simplified&quot;);
  // }
  // }

  /**
   * Adds the sentence to end latest sequence.
   *
   * @param s
   *          the s
   * @throws ParseException
   *           the parse exception
   */
  public void addSentenceToEndLatestSequence(MtasCQLParserSentenceCondition s)
      throws ParseException {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (!simplified) {</span>
      MtasCQLParserSentenceCondition sentenceCurrent;
      List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence;
<span class="fc bfc" id="L223" title="All 2 branches covered.">      if (isBasic()) {</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (basicSentence == null) {</span>
<span class="nc" id="L225">          sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();</span>
<span class="nc" id="L226">          sentenceCurrent = s;</span>
<span class="nc" id="L227">          sentenceSequence.add(sentenceCurrent);</span>
<span class="nc" id="L228">          sequenceList.add(sentenceSequence);</span>
          // not simple anymore
<span class="nc" id="L230">          basic = false;</span>
        } else {
          // add previous basic sentence as first option
<span class="fc" id="L233">          sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();</span>
<span class="fc" id="L234">          sentenceCurrent = new MtasCQLParserSentenceCondition(basicSentence,</span>
              ignore, maximumIgnoreLength);
<span class="fc" id="L236">          sentenceSequence.add(sentenceCurrent);</span>
<span class="fc" id="L237">          sequenceList.add(sentenceSequence);</span>
<span class="fc" id="L238">          basicSentence = null;</span>
          // add sentence to first option
<span class="fc" id="L240">          sentenceCurrent = s;</span>
<span class="fc" id="L241">          sentenceSequence.add(sentenceCurrent);</span>
          // not simple anymore
<span class="fc" id="L243">          basic = false;</span>
        }
      } else {
<span class="fc" id="L246">        sentenceCurrent = s;</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (sequenceList.size() == 0) {</span>
<span class="fc" id="L248">          sequenceList.add(new ArrayList&lt;MtasCQLParserSentenceCondition&gt;());</span>
        }
<span class="fc" id="L250">        sequenceList.get(sequenceList.size() - 1).add(sentenceCurrent);</span>
      }
<span class="fc" id="L252">    } else {</span>
<span class="nc" id="L253">      throw new ParseException(&quot;already simplified&quot;);</span>
    }
<span class="fc" id="L255">  }</span>

  /**
   * Adds the sentence as first option.
   *
   * @param s the s
   * @throws ParseException the parse exception
   */
  public void addSentenceAsFirstOption(MtasCQLParserSentenceCondition s)
      throws ParseException {
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">    if (!simplified) {</span>
      MtasCQLParserSentenceCondition sentenceCurrent;
      List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence;
<span class="fc bfc" id="L268" title="All 2 branches covered.">      if (isBasic()) {</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (basicSentence == null) {</span>
<span class="nc" id="L270">          sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();</span>
<span class="nc" id="L271">          sentenceCurrent = s;</span>
<span class="nc" id="L272">          sentenceSequence.add(sentenceCurrent);</span>
<span class="nc" id="L273">          sequenceList.add(sentenceSequence);</span>
          // not simple anymore
<span class="nc" id="L275">          basic = false;</span>
        } else {
          // add sentence as first option
<span class="fc" id="L278">          sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();</span>
<span class="fc" id="L279">          sentenceCurrent = s;</span>
<span class="fc" id="L280">          sentenceSequence.add(sentenceCurrent);</span>
<span class="fc" id="L281">          sequenceList.add(sentenceSequence);</span>
          // add previous basic sentence as new option
<span class="fc" id="L283">          sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();</span>
<span class="fc" id="L284">          sentenceCurrent = new MtasCQLParserSentenceCondition(basicSentence,</span>
              ignore, maximumIgnoreLength);
<span class="fc" id="L286">          sentenceSequence.add(sentenceCurrent);</span>
<span class="fc" id="L287">          sequenceList.add(sentenceSequence);</span>
<span class="fc" id="L288">          basicSentence = null;</span>
          // not simple anymore
<span class="fc" id="L290">          basic = false;</span>
        }
      } else {
<span class="fc" id="L293">        sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();</span>
<span class="fc" id="L294">        sentenceCurrent = s;</span>
<span class="fc" id="L295">        sentenceSequence.add(sentenceCurrent);</span>
<span class="fc" id="L296">        List&lt;List&lt;MtasCQLParserSentenceCondition&gt;&gt; newsequenceList = new ArrayList&lt;List&lt;MtasCQLParserSentenceCondition&gt;&gt;();</span>
<span class="fc" id="L297">        newsequenceList.add(sentenceSequence);</span>
<span class="fc" id="L298">        newsequenceList.addAll(sequenceList);</span>
<span class="fc" id="L299">        sequenceList = newsequenceList;</span>
      }
<span class="fc" id="L301">    } else {</span>
<span class="nc" id="L302">      throw new ParseException(&quot;already simplified&quot;);</span>
    }
<span class="fc" id="L304">  }</span>

  /**
   * Checks if is basic.
   *
   * @return true, if is basic
   */
  // public void addSentenceAsOption(MtasCQLParserSentenceCondition s)
  // throws ParseException {
  // if (!simplified) {
  // MtasCQLParserSentenceCondition sentenceCurrent;
  // List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence;
  // if (isBasic()) {
  // if (basicSentence == null) {
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = s;
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // // not simple anymore
  // basic = false;
  // } else {
  // // add previous basic sentence as first option
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = new MtasCQLParserSentenceCondition(basicSentence,
  // ignore, maximumIgnoreLength);
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // basicSentence = null;
  // // add sentence as new option
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = s;
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // // not simple anymore
  // basic = false;
  // }
  // } else {
  // sentenceSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();
  // sentenceCurrent = s;
  // sentenceSequence.add(sentenceCurrent);
  // sequenceList.add(sentenceSequence);
  // }
  // } else {
  // throw new ParseException(&quot;already simplified&quot;);
  // }
  // }

  /**
   * Checks if is basic.
   *
   * @return true, if is basic
   */
  private boolean isBasic() {
<span class="fc" id="L357">    return basic;</span>
  }

  /**
   * Checks if is single.
   *
   * @return true, if is single
   */
  private boolean isSingle() {
<span class="pc bpc" id="L366" title="1 of 4 branches missed.">    return basic ? true : ((sequenceList.size() &gt; 1) ? false : true);</span>
  }

  /**
   * Simplify.
   *
   * @throws ParseException the parse exception
   */
  public void simplify() throws ParseException {
<span class="fc bfc" id="L375" title="All 2 branches covered.">    if (!simplified) {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">      if (!isBasic()) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (List&lt;MtasCQLParserSentenceCondition&gt; sequence : sequenceList) {</span>
<span class="fc" id="L378">          simplifySequence(sequence);</span>
<span class="fc" id="L379">        }</span>
        // flatten
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (sequenceList.size() &gt; 1) {</span>
<span class="fc" id="L382">          List&lt;List&lt;MtasCQLParserSentenceCondition&gt;&gt; newSequenceList = new ArrayList&lt;List&lt;MtasCQLParserSentenceCondition&gt;&gt;();</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">          for (List&lt;MtasCQLParserSentenceCondition&gt; sequence : sequenceList) {</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">            if (sequence.size() == 1) {</span>
<span class="fc" id="L385">              MtasCQLParserSentenceCondition subSentence = sequence.get(0);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">              if (subSentence.isBasic()) {</span>
<span class="fc" id="L387">                newSequenceList.add(sequence);</span>
              } else {
<span class="fc" id="L389">                newSequenceList.addAll(subSentence.sequenceList);</span>
              }
            }
<span class="fc" id="L392">          }</span>
<span class="fc" id="L393">          sequenceList = newSequenceList;</span>
        }
      }
<span class="fc" id="L396">      simplified = true;</span>
    }
<span class="fc" id="L398">  }</span>

  /**
   * Simplify sequence.
   *
   * @param sequence the sequence
   * @throws ParseException the parse exception
   */
  private void simplifySequence(List&lt;MtasCQLParserSentenceCondition&gt; sequence)
      throws ParseException {
<span class="fc" id="L408">    List&lt;MtasCQLParserSentenceCondition&gt; newSequence = new ArrayList&lt;MtasCQLParserSentenceCondition&gt;();</span>
<span class="fc" id="L409">    MtasCQLParserSentenceCondition lastSentence = null;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">    for (MtasCQLParserSentenceCondition sentence : sequence) {</span>
<span class="fc" id="L411">      sentence.simplify();</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">      if (lastSentence == null) {</span>
<span class="fc" id="L413">        lastSentence = sentence;</span>
<span class="fc bfc" id="L414" title="All 4 branches covered.">      } else if (lastSentence.isBasic() &amp;&amp; sentence.isBasic()) {</span>
<span class="fc bfc" id="L415" title="All 4 branches covered.">        if (!lastSentence.isOptional() &amp;&amp; !sentence.isOptional()</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">            &amp;&amp; sentence.getMaximumOccurence() == 1</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">            &amp;&amp; lastSentence.getMaximumOccurence() == 1) {</span>
<span class="fc" id="L418">          lastSentence.basicSentence.addBasicSentence(sentence.basicSentence);</span>
        } else {
<span class="fc" id="L420">          newSequence.add(lastSentence);</span>
<span class="fc" id="L421">          lastSentence = sentence;</span>
        }
<span class="pc bpc" id="L423" title="1 of 4 branches missed.">      } else if (lastSentence.isBasic() &amp;&amp; !sentence.isBasic()) {</span>
<span class="pc bpc" id="L424" title="1 of 4 branches missed.">        if (sentence.isSingle() &amp;&amp; !sentence.isOptional()</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            &amp;&amp; sentence.getMaximumOccurence() == 1</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">            &amp;&amp; lastSentence.getMaximumOccurence() == 1) {</span>
          // add all items from (first) sequenceList potentially to the new
          // sequence
          for (MtasCQLParserSentenceCondition subSentence : sentence.sequenceList
<span class="fc bfc" id="L430" title="All 2 branches covered.">              .get(0)) {</span>
<span class="fc" id="L431">            newSequence.add(lastSentence);</span>
<span class="fc" id="L432">            lastSentence = subSentence;</span>
<span class="fc" id="L433">          }</span>
        } else {
          // add sentence potentially to the new sequence
<span class="fc" id="L436">          newSequence.add(lastSentence);</span>
<span class="fc" id="L437">          lastSentence = sentence;</span>
        }
<span class="pc bpc" id="L439" title="2 of 4 branches missed.">      } else if (!lastSentence.isBasic() &amp;&amp; sentence.isBasic()) {</span>
<span class="pc bpc" id="L440" title="3 of 4 branches missed.">        if (lastSentence.isSingle() &amp;&amp; !lastSentence.isOptional()</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            &amp;&amp; sentence.getMaximumOccurence() == 1</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            &amp;&amp; lastSentence.getMaximumOccurence() == 1) {</span>
          // add basic sentence to end latest sequence
<span class="nc" id="L444">          lastSentence</span>
<span class="nc" id="L445">              .addBasicSentenceToEndLatestSequence(sentence.basicSentence);</span>
        } else {
          // add sentence potentially to the new sequence
<span class="fc" id="L448">          newSequence.add(lastSentence);</span>
<span class="fc" id="L449">          lastSentence = sentence;</span>
        }
      } else {
<span class="nc bnc" id="L452" title="All 4 branches missed.">        if (sentence.isSingle() &amp;&amp; !sentence.isOptional()</span>
<span class="nc bnc" id="L453" title="All 4 branches missed.">            &amp;&amp; lastSentence.isSingle() &amp;&amp; !lastSentence.isOptional()</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            &amp;&amp; sentence.getMaximumOccurence() == 1</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            &amp;&amp; lastSentence.getMaximumOccurence() == 1) {</span>
          // combine sentences
          for (MtasCQLParserSentenceCondition subSentence : sentence.sequenceList
<span class="nc bnc" id="L458" title="All 2 branches missed.">              .get(0)) {</span>
<span class="nc" id="L459">            lastSentence.sequenceList.get(0).add(subSentence);</span>
<span class="nc" id="L460">          }</span>
        } else {
          // add sentence potentially to the new sequence (both not basic)
<span class="nc" id="L463">          newSequence.add(lastSentence);</span>
<span class="nc" id="L464">          lastSentence = sentence;</span>
        }
      }
<span class="fc" id="L467">    }</span>
    // add last to newSequence
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">    if (lastSentence != null) {</span>
<span class="fc" id="L470">      newSequence.add(lastSentence);</span>
    }
    // replace content sequence with newSequence
<span class="fc" id="L473">    sequence.clear();</span>
<span class="fc" id="L474">    sequence.addAll(newSequence);</span>
<span class="fc" id="L475">  }</span>

  /**
   * Gets the minimum occurence.
   *
   * @return the minimum occurence
   */
  public int getMinimumOccurence() {
<span class="nc" id="L483">    return minimumOccurence;</span>
  }

  /**
   * Gets the maximum occurence.
   *
   * @return the maximum occurence
   */
  public int getMaximumOccurence() {
<span class="fc" id="L492">    return maximumOccurence;</span>
  }

  /**
   * Sets the occurence.
   *
   * @param min the min
   * @param max the max
   * @throws ParseException the parse exception
   */
  public void setOccurence(int min, int max) throws ParseException {
<span class="pc bpc" id="L503" title="3 of 6 branches missed.">    if ((min &lt; 0) || (min &gt; max) || (max &lt; 1)) {</span>
<span class="nc" id="L504">      throw new ParseException(&quot;Illegal number {&quot; + min + &quot;,&quot; + max + &quot;}&quot;);</span>
    }
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">    if (min == 0) {</span>
<span class="nc" id="L507">      optional = true;</span>
    }
<span class="fc" id="L509">    minimumOccurence = Math.max(1, min);</span>
<span class="fc" id="L510">    maximumOccurence = max;</span>
<span class="fc" id="L511">  }</span>

  /**
   * Checks if is optional.
   *
   * @return true, if is optional
   */
  public boolean isOptional() {
<span class="fc" id="L519">    return optional;</span>
  }

  /**
   * Sets the optional.
   *
   * @param status the new optional
   */
  // public boolean hasOptionalParts() throws ParseException {
  // if (simplified) {
  // return optionalParts;
  // } else {
  // throw new ParseException(&quot;can't be called when not simplified&quot;);
  // }
  // }

  /**
   * Sets the optional.
   *
   * @param status
   *          the new optional
   */
  public void setOptional(boolean status) {
<span class="fc" id="L542">    optional = status;</span>
<span class="fc" id="L543">  }</span>

  /**
   * Creates the query.
   *
   * @param sentenceSequence the sentence sequence
   * @return the mtas span query
   * @throws ParseException the parse exception
   */
  private MtasSpanQuery createQuery(
      List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence)
      throws ParseException {
<span class="fc bfc" id="L555" title="All 2 branches covered.">    if (sentenceSequence.size() == 1) {</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">      if (maximumOccurence &gt; 1) {</span>
<span class="fc" id="L557">        return new MtasSpanRecurrenceQuery(sentenceSequence.get(0).getQuery(),</span>
            minimumOccurence, maximumOccurence, ignore, maximumIgnoreLength);
      } else {
<span class="fc" id="L560">        return sentenceSequence.get(0).getQuery();</span>
      }
    } else {
<span class="fc" id="L563">      List&lt;MtasSpanSequenceItem&gt; clauses = new ArrayList&lt;MtasSpanSequenceItem&gt;();</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">      for (MtasCQLParserSentenceCondition sentence : sentenceSequence) {</span>
<span class="fc" id="L565">        clauses.add(</span>
<span class="fc" id="L566">            new MtasSpanSequenceItem(sentence.getQuery(), sentence.optional));</span>
<span class="fc" id="L567">      }</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">      if (maximumOccurence &gt; 1) {</span>
<span class="nc" id="L569">        return new MtasSpanRecurrenceQuery(</span>
            new MtasSpanSequenceQuery(clauses, ignore, maximumIgnoreLength),
            minimumOccurence, maximumOccurence, ignore, maximumIgnoreLength);
      } else {
<span class="fc" id="L573">        return new MtasSpanSequenceQuery(clauses, ignore, maximumIgnoreLength);</span>
      }
    }
  }

  /**
   * Gets the query.
   *
   * @return the query
   * @throws ParseException the parse exception
   */
  public MtasSpanQuery getQuery() throws ParseException {
<span class="fc" id="L585">    simplify();</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">    if (isBasic()) {</span>
      MtasSpanQuery query;
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">      if (basicSentence == null) {</span>
<span class="nc" id="L589">        throw new ParseException(&quot;no condition&quot;);</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">      } else if (basicSentence.isOptional()) {</span>
<span class="nc" id="L591">        List&lt;MtasSpanSequenceItem&gt; clauses = new ArrayList&lt;MtasSpanSequenceItem&gt;();</span>
<span class="nc" id="L592">        clauses.add(new MtasSpanSequenceItem(basicSentence.getQuery(),</span>
<span class="nc" id="L593">            basicSentence.isOptional()));</span>
<span class="nc" id="L594">        query = new MtasSpanSequenceQuery(clauses, ignore, maximumIgnoreLength);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (maximumOccurence &gt; 1) {</span>
<span class="nc" id="L596">          query = new MtasSpanRecurrenceQuery(query, minimumOccurence,</span>
              maximumOccurence, ignore, maximumIgnoreLength);
        }
<span class="nc" id="L599">      } else {</span>
<span class="fc" id="L600">        query = basicSentence.getQuery();</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (maximumOccurence &gt; 1) {</span>
<span class="fc" id="L602">          query = new MtasSpanRecurrenceQuery(query, minimumOccurence,</span>
              maximumOccurence, ignore, maximumIgnoreLength);
        }
      }
<span class="fc" id="L606">      return query;</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">    } else if (sequenceList.isEmpty()) {</span>
<span class="nc" id="L608">      throw new ParseException(&quot;no condition&quot;);</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">    } else if (isSingle()) {</span>
<span class="fc" id="L610">      return createQuery(sequenceList.get(0));</span>
    } else {
<span class="fc" id="L612">      List&lt;MtasSpanQuery&gt; clauses = new ArrayList&lt;MtasSpanQuery&gt;();</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">      for (List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence : sequenceList) {</span>
<span class="fc" id="L614">        clauses.add(createQuery(sentenceSequence));</span>
<span class="fc" id="L615">      }</span>
<span class="fc" id="L616">      return new MtasSpanOrQuery(</span>
<span class="fc" id="L617">          clauses.toArray(new MtasSpanQuery[clauses.size()]));</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#toString()
   */
  @Override
  public String toString() {
<span class="nc" id="L628">    return toString(&quot;&quot;, &quot;&quot;);</span>
  }

  /**
   * To string.
   *
   * @param firstIndent the first indent
   * @param indent the indent
   * @return the string
   */
  public String toString(String firstIndent, String indent) {
<span class="nc" id="L639">    String text = &quot;&quot;;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">    if (isBasic()) {</span>
      try {
<span class="nc bnc" id="L642" title="All 2 branches missed.">        text += firstIndent + &quot;BASIC SENTENCE&quot; + (optional ? &quot; OPTIONAL&quot; : &quot;&quot;)</span>
<span class="nc" id="L643">            + &quot;: &quot; + basicSentence.getQuery()</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            + (basicSentence.isOptional() ? &quot; OPTIONAL&quot; : &quot;&quot;) + &quot;\n&quot;;</span>
<span class="nc" id="L645">      } catch (ParseException e) {</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">        text += firstIndent + &quot;BASIC SENTENCE&quot; + (optional ? &quot; OPTIONAL&quot; : &quot;&quot;)</span>
<span class="nc" id="L647">            + &quot;: &quot; + e.getMessage() + &quot;\n&quot;;</span>
<span class="nc" id="L648">      }</span>
    } else {
<span class="nc bnc" id="L650" title="All 2 branches missed.">      text += firstIndent + &quot;SENTENCE&quot; + (optional ? &quot; OPTIONAL&quot; : &quot;&quot;) + &quot;\n&quot;;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">      if (simplified) {</span>
        try {
<span class="nc" id="L653">          text += indent + &quot;- Query: &quot;</span>
<span class="nc" id="L654">              + getQuery().toString(getQuery().getField());</span>
<span class="nc" id="L655">        } catch (ParseException e) {</span>
<span class="nc" id="L656">          text += indent + &quot;- Query: &quot; + e.getMessage();</span>
<span class="nc" id="L657">        }</span>
<span class="nc" id="L658">        text += &quot;\n&quot;;</span>
      } else {
<span class="nc bnc" id="L660" title="All 2 branches missed.">        for (List&lt;MtasCQLParserSentenceCondition&gt; sentenceSequence : sequenceList) {</span>
<span class="nc" id="L661">          text += indent + &quot;- Sequence :\n&quot;;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">          for (MtasCQLParserSentenceCondition sentence : sentenceSequence) {</span>
<span class="nc" id="L663">            text += sentence.toString(indent + &quot;  - &quot;, indent + &quot;    &quot;);</span>
<span class="nc" id="L664">          }</span>
<span class="nc" id="L665">        }</span>
<span class="nc" id="L666">        text += &quot;\n&quot;;</span>
      }
    }
<span class="nc" id="L669">    return text;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>