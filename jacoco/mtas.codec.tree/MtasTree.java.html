<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.codec.tree</a> &gt; <span class="el_source">MtasTree.java</span></div><h1>MtasTree.java</h1><pre class="source lang-java linenums">package mtas.codec.tree;

import java.util.TreeMap;
import java.io.IOException;
import java.util.Map.Entry;
import java.util.SortedMap;

import mtas.analysis.token.MtasPosition;
import mtas.analysis.token.MtasToken;

/**
 * The Class MtasTree.
 *
 * @param &lt;N&gt; the number type
 */
abstract public class MtasTree&lt;N extends MtasTreeNode&lt;N&gt;&gt; {

  /** The Constant SINGLE_POSITION_TREE. */
  final public static byte SINGLE_POSITION_TREE = 1;

  /** The Constant STORE_ADDITIONAL_ID. */
  final public static byte STORE_ADDITIONAL_ID = 2;

  /** The root. */
  protected N root;

  /** The closed. */
  private Boolean closed;

  /** The single point. */
  protected Boolean singlePoint;

  /** The store prefix and term ref. */
  protected Boolean storePrefixAndTermRef;

  /**
   * Instantiates a new mtas tree.
   *
   * @param singlePoint the single point
   * @param storePrefixAndTermRef the store prefix and term ref
   */
<span class="fc" id="L42">  public MtasTree(boolean singlePoint, boolean storePrefixAndTermRef) {</span>
<span class="fc" id="L43">    root = null;</span>
<span class="fc" id="L44">    closed = false;</span>
<span class="fc" id="L45">    this.singlePoint = singlePoint;</span>
<span class="fc" id="L46">    this.storePrefixAndTermRef = storePrefixAndTermRef;</span>
<span class="fc" id="L47">  }</span>

  /**
   * Adds the id from doc.
   *
   * @param docId the doc id
   * @param reference the reference
   */
  final public void addIdFromDoc(Integer docId, Long reference) {
<span class="pc bpc" id="L56" title="2 of 4 branches missed.">    if (!closed &amp;&amp; (docId != null)) {</span>
<span class="fc" id="L57">      addSinglePoint(docId, 0, 0, docId, reference);</span>
    }
<span class="fc" id="L59">  }</span>

  /**
   * Adds the parent from token.
   *
   * @param token the token
   * @throws IOException Signals that an I/O exception has occurred.
   */
  final public void addParentFromToken(MtasToken token) throws IOException {
<span class="pc bpc" id="L68" title="2 of 4 branches missed.">    if (!closed &amp;&amp; (token != null)) {</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">      if (token.checkParentId()) {</span>
<span class="fc" id="L70">        addSinglePoint(token.getParentId(), token.getPrefixId(),</span>
<span class="fc" id="L71">            token.getTermRef(), token.getId(), token.getTokenRef());</span>
      }
    }
<span class="fc" id="L74">  }</span>

  /**
   * Adds the position and object from token.
   *
   * @param token the token
   * @throws IOException Signals that an I/O exception has occurred.
   */
  final public void addPositionAndObjectFromToken(MtasToken token)
      throws IOException {
<span class="fc" id="L84">    addPositionFromToken(token, token.getTokenRef());</span>
<span class="fc" id="L85">  }</span>

  // final public &lt;T&gt; void addPositionAndTermFromToken(MtasToken&lt;T&gt; token) {
  // addPositionFromToken(token, token.getTermRef());
  // }

  /**
   * Adds the position from token.
   *
   * @param token the token
   * @param ref the ref
   * @throws IOException Signals that an I/O exception has occurred.
   */
  final private void addPositionFromToken(MtasToken token, Long ref)
      throws IOException {
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">    int prefixId = storePrefixAndTermRef ? token.getPrefixId() : 0;</span>
<span class="pc bpc" id="L101" title="2 of 4 branches missed.">    if (!closed &amp;&amp; (token != null)) {</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">      if (token.checkPositionType(MtasPosition.POSITION_SINGLE)) {</span>
<span class="fc" id="L103">        addSinglePoint(token.getPositionStart(), prefixId, token.getTermRef(),</span>
<span class="fc" id="L104">            token.getId(), ref);</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">      } else if (token.checkPositionType(MtasPosition.POSITION_RANGE)) {</span>
<span class="fc" id="L106">        addRange(token.getPositionStart(), token.getPositionEnd(), prefixId,</span>
<span class="fc" id="L107">            token.getTermRef(), token.getId(), ref);</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">      } else if (token.checkPositionType(MtasPosition.POSITION_SET)) {</span>
        // split set into minimum number of single points and ranges
<span class="fc" id="L110">        SortedMap&lt;Integer, Integer&gt; list = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L111">        int[] positions = token.getPositions();</span>
<span class="fc" id="L112">        Integer lastPoint = null;</span>
<span class="fc" id="L113">        Integer startPoint = null;</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        for (int position : positions) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">          if (lastPoint == null) {</span>
<span class="fc" id="L116">            startPoint = position;</span>
<span class="fc" id="L117">            lastPoint = position;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">          } else if ((position - lastPoint) != 1) {</span>
<span class="fc" id="L119">            list.put(startPoint, lastPoint);</span>
<span class="fc" id="L120">            startPoint = position;</span>
          }
<span class="fc" id="L122">          lastPoint = position;</span>
        }
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (lastPoint != null) {</span>
<span class="fc" id="L125">          list.put(startPoint, lastPoint);</span>
        }
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (Entry&lt;Integer, Integer&gt; entry : list.entrySet()) {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">          if (entry.getKey().equals(entry.getValue())) {</span>
<span class="fc" id="L129">            addSinglePoint(entry.getKey(), prefixId, token.getTermRef(),</span>
<span class="fc" id="L130">                token.getId(), ref);</span>
          } else {
<span class="fc" id="L132">            addRange(entry.getKey(), entry.getValue(), prefixId,</span>
<span class="fc" id="L133">                token.getTermRef(), token.getId(), ref);</span>
          }
<span class="fc" id="L135">        }</span>
      }
    }
<span class="fc" id="L138">  }</span>

  /**
   * Close.
   *
   * @return the n
   */
  final public N close() {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">    if (root == null) {</span>
<span class="nc" id="L147">      addRangeEmpty(0, 0, 0, 0);</span>
    }
<span class="fc" id="L149">    closed = true;</span>
<span class="fc" id="L150">    return root;</span>
  }

  /**
   * Adds the single point.
   *
   * @param position the position
   * @param additionalId the additional id
   * @param additionalRef the additional ref
   * @param id the id
   * @param ref the ref
   */
  abstract protected void addSinglePoint(int position, int additionalId,
      long additionalRef, Integer id, Long ref);

  /**
   * Adds the range.
   *
   * @param left the left
   * @param right the right
   * @param additionalId the additional id
   * @param additionalRef the additional ref
   * @param id the id
   * @param ref the ref
   */
  abstract protected void addRange(int left, int right, int additionalId,
      long additionalRef, Integer id, Long ref);

  /**
   * Adds the range empty.
   *
   * @param left the left
   * @param right the right
   * @param additionalId the additional id
   * @param additionalRef the additional ref
   */
  abstract protected void addRangeEmpty(int left, int right, int additionalId,
      long additionalRef);

  /**
   * Checks if is single point.
   *
   * @return true, if is single point
   */
  final public boolean isSinglePoint() {
<span class="fc" id="L195">    return singlePoint;</span>
  }

  /**
   * Checks if is store prefix and term ref.
   *
   * @return true, if is store prefix and term ref
   */
  final public boolean isStorePrefixAndTermRef() {
<span class="fc" id="L204">    return storePrefixAndTermRef;</span>
  }

  /**
   * Prints the balance.
   */
  final public void printBalance() {
<span class="nc" id="L211">    printBalance(1, root);</span>
<span class="nc" id="L212">  }</span>

  /**
   * Prints the balance.
   *
   * @param p the p
   * @param n the n
   */
  final private void printBalance(Integer p, N n) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">    if (n != null) {</span>
<span class="nc" id="L222">      printBalance((p + 1), n.leftChild);</span>
<span class="nc" id="L223">      String format = &quot;%&quot; + (3 * p) + &quot;s&quot;;</span>
<span class="nc" id="L224">      System.out.print(String.format(format, &quot;&quot;));</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">      if (n.left == n.right) {</span>
<span class="nc" id="L226">        System.out.println(</span>
<span class="nc" id="L227">            &quot;[&quot; + n.left + &quot;] (&quot; + n.max + &quot;) : &quot; + n.ids.size() + &quot; tokens&quot;);</span>
      } else {
<span class="nc" id="L229">        System.out.println(&quot;[&quot; + n.left + &quot;-&quot; + n.right + &quot;] (&quot; + n.max + &quot;) : &quot;</span>
<span class="nc" id="L230">            + n.ids.size() + &quot; tokens&quot;);</span>
      }
<span class="nc" id="L232">      printBalance((p + 1), n.rightChild);</span>
    }
<span class="nc" id="L234">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>